{
  "id": "backend_development_cqrs_implementation",
  "name": "cqrs-implementation",
  "source": "backend-development",
  "originalPath": "plugins/backend-development/skills/cqrs-implementation/SKILL.md",
  "activationCriteria": "Implement Command Query Responsibility Segregation for scalable architectures. Use when separating read and write models, optimizing query performance, or building event-sourced systems.",
  "tier1_metadata": "cqrs-implementation: Implement Command Query Responsibility Segregation for scalable architectures. Use when separating r",
  "tier2_instructions": "# CQRS Implementation\n\nComprehensive guide to implementing CQRS (Command Query Responsibility Segregation) patterns.\n\n## When to Use This Skill\n\n- Separating read and write concerns\n- Scaling reads independently from writes\n- Building event-sourced systems\n- Optimizing complex query scenarios\n- Different read/write data models needed\n- High-performance reporting requirements\n\n## Core Concepts\n\n### 1. CQRS Architecture\n\n```\n                    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                    \u2502   Client    \u2502\n                    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                           \u2502\n              \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n              \u2502                         \u2502\n              \u25bc                         \u25bc\n       \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510          \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n       \u2502  Commands   \u2502          \u2502   Queries   \u2502\n       \u2502    API      \u2502          \u2502    API      \u2502\n       \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518          \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n              \u2502                         \u2502\n              \u25bc                         \u25bc\n       \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510          \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n       \u2502  Command    \u2502          \u2502   Query     \u2502\n       \u2502  Handlers   \u2502          \u2502  Handlers   \u2502\n       \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518          \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n              \u2502                         \u2502\n              \u25bc                         \u25bc\n       \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510          \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n       \u2502   Write     \u2502\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25ba\u2502    Read     \u2502\n       \u2502   Model     \u2502  Events  \u2502   Model     \u2502\n       \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518          \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n```\n\n### 2. Key Components\n\n| Component | Responsibility |\n|-----------|---------------|\n| **Command** | Intent to change state |\n| **Command Handler** | Validates and executes commands |\n| **Event** | Record of state change |\n| **Query** | Request for data |\n| **Query Handler** | Retrieves data from read model |\n| **Projector** | Updates read model from events |\n\n## Templates\n\n### Template 1: Command Infrastructure\n\n```python\nfrom abc import ABC, abstractmethod\nfrom dataclasses import dataclass\nfrom typing import TypeVar, Generic, Dict, Any, Type\nfrom datetim",
  "tier3_resources": "e import datetime\nimport uuid\n\n# Command base\n@dataclass\nclass Command:\n    command_id: str = None\n    timestamp: datetime = None\n\n    def __post_init__(self):\n        self.command_id = self.command_id or str(uuid.uuid4())\n        self.timestamp = self.timestamp or datetime.utcnow()\n\n\n# Concrete commands\n@dataclass\nclass CreateOrder(Command):\n    customer_id: str\n    items: list\n    shipping_address: dict\n\n\n@dataclass\nclass AddOrderItem(Command):\n    order_id: str\n    product_id: str\n    quantity: int\n    price: float\n\n\n@dataclass\nclass CancelOrder(Command):\n    order_id: str\n    reason: str\n\n\n# Command handler base\nT = TypeVar('T', bound=Command)\n\nclass CommandHandler(ABC, Generic[T]):\n    @abstractmethod\n    async def handle(self, command: T) -> Any:\n        pass\n\n\n# Command bus\nclass CommandBus:\n    def __init__(self):\n        self._handlers: Dict[Type[Command], CommandHandler] = {}\n\n    def register(self, command_type: Type[Command], handler: CommandHandler):\n        self._handlers[command_type] = handler\n\n    async def dispatch(self, command: Command) -> Any:\n        handler = self._handlers.get(type(command))\n        if not handler:\n            raise ValueError(f\"No handler for {type(command).__name__}\")\n        return await handler.handle(command)\n\n\n# Command handler implementation\nclass CreateOrderHandler(CommandHandler[CreateOrder]):\n    def __init__(self, order_repository, event_store):\n        self.order_repository = order_repository\n        self.event_store = event_store\n\n    async def handle(self, command: CreateOrder) -> str:\n        # Validate\n        if not command.items:\n            raise ValueError(\"Order must have at least one item\")\n\n        # Create aggregate\n        order = Order.create(\n            customer_id=command.customer_id,\n            items=command.items,\n            shipping_address=command.shipping_address\n        )\n\n        # Persist events\n        await self.event_store.append_events(\n            stream_id=f\"Order-{order.id}\",\n            stream_type=\"Order\",\n            events=order.uncommitted_events\n        )\n\n        return order.id\n```\n\n### Template 2: Query Infrastructure\n\n```python\nfrom abc import ABC, abstractmethod\nfrom dataclasses import dataclass\nfrom typing import TypeVar, Generic, List, Optional\n\n# Query base\n@dataclass\nclass Query:\n    pass\n\n\n# Concrete queries\n@dataclass\nclass GetOrderById(Query):\n    order_id: str\n\n\n@dataclass\nclass GetCustomerOrders(Query):\n    customer_id: str\n    status: Optional[str] = None\n    page: int = 1\n    page_size: int = 20\n\n\n@dataclass\nclass SearchOrders(Query):\n    query: str\n    filters: dict = None\n    sort_by: str = \"created_at\"\n    sort_order: str = \"desc\"\n\n\n# Query result types\n@dataclass\nclass OrderView:\n    order_id: str\n    customer_id: str\n    status: str\n    total_amount: float\n    item_count: int\n    created_at: datetime\n    shipped_at: Optional[datetime] = None\n\n\n@dataclass\nclass PaginatedResult(Generic[T]):\n    items: List[T]\n    total: int\n    page: in",
  "tokenEstimate": {
    "tier1": 16.900000000000002,
    "tier2": 278.2,
    "tier3": 1523.6000000000001
  },
  "fullDefinition": "---\nname: cqrs-implementation\ndescription: Implement Command Query Responsibility Segregation for scalable architectures. Use when separating read and write models, optimizing query performance, or building event-sourced systems.\n---\n\n# CQRS Implementation\n\nComprehensive guide to implementing CQRS (Command Query Responsibility Segregation) patterns.\n\n## When to Use This Skill\n\n- Separating read and write concerns\n- Scaling reads independently from writes\n- Building event-sourced systems\n- Optimizing complex query scenarios\n- Different read/write data models needed\n- High-performance reporting requirements\n\n## Core Concepts\n\n### 1. CQRS Architecture\n\n```\n                    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                    \u2502   Client    \u2502\n                    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                           \u2502\n              \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n              \u2502                         \u2502\n              \u25bc                         \u25bc\n       \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510          \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n       \u2502  Commands   \u2502          \u2502   Queries   \u2502\n       \u2502    API      \u2502          \u2502    API      \u2502\n       \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518          \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n              \u2502                         \u2502\n              \u25bc                         \u25bc\n       \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510          \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n       \u2502  Command    \u2502          \u2502   Query     \u2502\n       \u2502  Handlers   \u2502          \u2502  Handlers   \u2502\n       \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518          \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n              \u2502                         \u2502\n              \u25bc                         \u25bc\n       \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510          \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n       \u2502   Write     \u2502\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25ba\u2502    Read     \u2502\n       \u2502   Model     \u2502  Events  \u2502   Model     \u2502\n       \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518          \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n```\n\n### 2. Key Components\n\n| Component | Responsibility |\n|-----------|---------------|\n| **Command** | Intent to change state |\n| **Command Handler** | Validates and executes commands |\n| **Event** | Record of state change |\n| **Query** | Request for data |\n| **Query Handler** | Retrieves data from read model |\n| **Projector** | Updates read model from events |\n\n## Templates\n\n### Template 1: Command Infrastructure\n\n```python\nfrom abc import ABC, abstractmethod\nfrom dataclasses import dataclass\nfrom typing import TypeVar, Generic, Dict, Any, Type\nfrom datetime import datetime\nimport uuid\n\n# Command base\n@dataclass\nclass Command:\n    command_id: str = None\n    timestamp: datetime = None\n\n    def __post_init__(self):\n        self.command_id = self.command_id or str(uuid.uuid4())\n        self.timestamp = self.timestamp or datetime.utcnow()\n\n\n# Concrete commands\n@dataclass\nclass CreateOrder(Command):\n    customer_id: str\n    items: list\n    shipping_address: dict\n\n\n@dataclass\nclass AddOrderItem(Command):\n    order_id: str\n    product_id: str\n    quantity: int\n    price: float\n\n\n@dataclass\nclass CancelOrder(Command):\n    order_id: str\n    reason: str\n\n\n# Command handler base\nT = TypeVar('T', bound=Command)\n\nclass CommandHandler(ABC, Generic[T]):\n    @abstractmethod\n    async def handle(self, command: T) -> Any:\n        pass\n\n\n# Command bus\nclass CommandBus:\n    def __init__(self):\n        self._handlers: Dict[Type[Command], CommandHandler] = {}\n\n    def register(self, command_type: Type[Command], handler: CommandHandler):\n        self._handlers[command_type] = handler\n\n    async def dispatch(self, command: Command) -> Any:\n        handler = self._handlers.get(type(command))\n        if not handler:\n            raise ValueError(f\"No handler for {type(command).__name__}\")\n        return await handler.handle(command)\n\n\n# Command handler implementation\nclass CreateOrderHandler(CommandHandler[CreateOrder]):\n    def __init__(self, order_repository, event_store):\n        self.order_repository = order_repository\n        self.event_store = event_store\n\n    async def handle(self, command: CreateOrder) -> str:\n        # Validate\n        if not command.items:\n            raise ValueError(\"Order must have at least one item\")\n\n        # Create aggregate\n        order = Order.create(\n            customer_id=command.customer_id,\n            items=command.items,\n            shipping_address=command.shipping_address\n        )\n\n        # Persist events\n        await self.event_store.append_events(\n            stream_id=f\"Order-{order.id}\",\n            stream_type=\"Order\",\n            events=order.uncommitted_events\n        )\n\n        return order.id\n```\n\n### Template 2: Query Infrastructure\n\n```python\nfrom abc import ABC, abstractmethod\nfrom dataclasses import dataclass\nfrom typing import TypeVar, Generic, List, Optional\n\n# Query base\n@dataclass\nclass Query:\n    pass\n\n\n# Concrete queries\n@dataclass\nclass GetOrderById(Query):\n    order_id: str\n\n\n@dataclass\nclass GetCustomerOrders(Query):\n    customer_id: str\n    status: Optional[str] = None\n    page: int = 1\n    page_size: int = 20\n\n\n@dataclass\nclass SearchOrders(Query):\n    query: str\n    filters: dict = None\n    sort_by: str = \"created_at\"\n    sort_order: str = \"desc\"\n\n\n# Query result types\n@dataclass\nclass OrderView:\n    order_id: str\n    customer_id: str\n    status: str\n    total_amount: float\n    item_count: int\n    created_at: datetime\n    shipped_at: Optional[datetime] = None\n\n\n@dataclass\nclass PaginatedResult(Generic[T]):\n    items: List[T]\n    total: int\n    page: int\n    page_size: int\n\n    @property\n    def total_pages(self) -> int:\n        return (self.total + self.page_size - 1) // self.page_size\n\n\n# Query handler base\nT = TypeVar('T', bound=Query)\nR = TypeVar('R')\n\nclass QueryHandler(ABC, Generic[T, R]):\n    @abstractmethod\n    async def handle(self, query: T) -> R:\n        pass\n\n\n# Query bus\nclass QueryBus:\n    def __init__(self):\n        self._handlers: Dict[Type[Query], QueryHandler] = {}\n\n    def register(self, query_type: Type[Query], handler: QueryHandler):\n        self._handlers[query_type] = handler\n\n    async def dispatch(self, query: Query) -> Any:\n        handler = self._handlers.get(type(query))\n        if not handler:\n            raise ValueError(f\"No handler for {type(query).__name__}\")\n        return await handler.handle(query)\n\n\n# Query handler implementation\nclass GetOrderByIdHandler(QueryHandler[GetOrderById, Optional[OrderView]]):\n    def __init__(self, read_db):\n        self.read_db = read_db\n\n    async def handle(self, query: GetOrderById) -> Optional[OrderView]:\n        async with self.read_db.acquire() as conn:\n            row = await conn.fetchrow(\n                \"\"\"\n                SELECT order_id, customer_id, status, total_amount,\n                       item_count, created_at, shipped_at\n                FROM order_views\n                WHERE order_id = $1\n                \"\"\",\n                query.order_id\n            )\n            if row:\n                return OrderView(**dict(row))\n            return None\n\n\nclass GetCustomerOrdersHandler(QueryHandler[GetCustomerOrders, PaginatedResult[OrderView]]):\n    def __init__(self, read_db):\n        self.read_db = read_db\n\n    async def handle(self, query: GetCustomerOrders) -> PaginatedResult[OrderView]:\n        async with self.read_db.acquire() as conn:\n            # Build query with optional status filter\n            where_clause = \"customer_id = $1\"\n            params = [query.customer_id]\n\n            if query.status:\n                where_clause += \" AND status = $2\"\n                params.append(query.status)\n\n            # Get total count\n            total = await conn.fetchval(\n                f\"SELECT COUNT(*) FROM order_views WHERE {where_clause}\",\n                *params\n            )\n\n            # Get paginated results\n            offset = (query.page - 1) * query.page_size\n            rows = await conn.fetch(\n                f\"\"\"\n                SELECT order_id, customer_id, status, total_amount,\n                       item_count, created_at, shipped_at\n                FROM order_views\n                WHERE {where_clause}\n                ORDER BY created_at DESC\n                LIMIT ${len(params) + 1} OFFSET ${len(params) + 2}\n                \"\"\",\n                *params, query.page_size, offset\n            )\n\n            return PaginatedResult(\n                items=[OrderView(**dict(row)) for row in rows],\n                total=total,\n                page=query.page,\n                page_size=query.page_size\n            )\n```\n\n### Template 3: FastAPI CQRS Application\n\n```python\nfrom fastapi import FastAPI, HTTPException, Depends\nfrom pydantic import BaseModel\nfrom typing import List, Optional\n\napp = FastAPI()\n\n# Request/Response models\nclass CreateOrderRequest(BaseModel):\n    customer_id: str\n    items: List[dict]\n    shipping_address: dict\n\n\nclass OrderResponse(BaseModel):\n    order_id: str\n    customer_id: str\n    status: str\n    total_amount: float\n    item_count: int\n    created_at: datetime\n\n\n# Dependency injection\ndef get_command_bus() -> CommandBus:\n    return app.state.command_bus\n\n\ndef get_query_bus() -> QueryBus:\n    return app.state.query_bus\n\n\n# Command endpoints (POST, PUT, DELETE)\n@app.post(\"/orders\", response_model=dict)\nasync def create_order(\n    request: CreateOrderRequest,\n    command_bus: CommandBus = Depends(get_command_bus)\n):\n    command = CreateOrder(\n        customer_id=request.customer_id,\n        items=request.items,\n        shipping_address=request.shipping_address\n    )\n    order_id = await command_bus.dispatch(command)\n    return {\"order_id\": order_id}\n\n\n@app.post(\"/orders/{order_id}/items\")\nasync def add_item(\n    order_id: str,\n    product_id: str,\n    quantity: int,\n    price: float,\n    command_bus: CommandBus = Depends(get_command_bus)\n):\n    command = AddOrderItem(\n        order_id=order_id,\n        product_id=product_id,\n        quantity=quantity,\n        price=price\n    )\n    await command_bus.dispatch(command)\n    return {\"status\": \"item_added\"}\n\n\n@app.delete(\"/orders/{order_id}\")\nasync def cancel_order(\n    order_id: str,\n    reason: str,\n    command_bus: CommandBus = Depends(get_command_bus)\n):\n    command = CancelOrder(order_id=order_id, reason=reason)\n    await command_bus.dispatch(command)\n    return {\"status\": \"cancelled\"}\n\n\n# Query endpoints (GET)\n@app.get(\"/orders/{order_id}\", response_model=OrderResponse)\nasync def get_order(\n    order_id: str,\n    query_bus: QueryBus = Depends(get_query_bus)\n):\n    query = GetOrderById(order_id=order_id)\n    result = await query_bus.dispatch(query)\n    if not result:\n        raise HTTPException(status_code=404, detail=\"Order not found\")\n    return result\n\n\n@app.get(\"/customers/{customer_id}/orders\")\nasync def get_customer_orders(\n    customer_id: str,\n    status: Optional[str] = None,\n    page: int = 1,\n    page_size: int = 20,\n    query_bus: QueryBus = Depends(get_query_bus)\n):\n    query = GetCustomerOrders(\n        customer_id=customer_id,\n        status=status,\n        page=page,\n        page_size=page_size\n    )\n    return await query_bus.dispatch(query)\n\n\n@app.get(\"/orders/search\")\nasync def search_orders(\n    q: str,\n    sort_by: str = \"created_at\",\n    query_bus: QueryBus = Depends(get_query_bus)\n):\n    query = SearchOrders(query=q, sort_by=sort_by)\n    return await query_bus.dispatch(query)\n```\n\n### Template 4: Read Model Synchronization\n\n```python\nclass ReadModelSynchronizer:\n    \"\"\"Keeps read models in sync with events.\"\"\"\n\n    def __init__(self, event_store, read_db, projections: List[Projection]):\n        self.event_store = event_store\n        self.read_db = read_db\n        self.projections = {p.name: p for p in projections}\n\n    async def run(self):\n        \"\"\"Continuously sync read models.\"\"\"\n        while True:\n            for name, projection in self.projections.items():\n                await self._sync_projection(projection)\n            await asyncio.sleep(0.1)\n\n    async def _sync_projection(self, projection: Projection):\n        checkpoint = await self._get_checkpoint(projection.name)\n\n        events = await self.event_store.read_all(\n            from_position=checkpoint,\n            limit=100\n        )\n\n        for event in events:\n            if event.event_type in projection.handles():\n                try:\n                    await projection.apply(event)\n                except Exception as e:\n                    # Log error, possibly retry or skip\n                    logger.error(f\"Projection error: {e}\")\n                    continue\n\n            await self._save_checkpoint(projection.name, event.global_position)\n\n    async def rebuild_projection(self, projection_name: str):\n        \"\"\"Rebuild a projection from scratch.\"\"\"\n        projection = self.projections[projection_name]\n\n        # Clear existing data\n        await projection.clear()\n\n        # Reset checkpoint\n        await self._save_checkpoint(projection_name, 0)\n\n        # Rebuild\n        while True:\n            checkpoint = await self._get_checkpoint(projection_name)\n            events = await self.event_store.read_all(checkpoint, 1000)\n\n            if not events:\n                break\n\n            for event in events:\n                if event.event_type in projection.handles():\n                    await projection.apply(event)\n\n            await self._save_checkpoint(\n                projection_name,\n                events[-1].global_position\n            )\n```\n\n### Template 5: Eventual Consistency Handling\n\n```python\nclass ConsistentQueryHandler:\n    \"\"\"Query handler that can wait for consistency.\"\"\"\n\n    def __init__(self, read_db, event_store):\n        self.read_db = read_db\n        self.event_store = event_store\n\n    async def query_after_command(\n        self,\n        query: Query,\n        expected_version: int,\n        stream_id: str,\n        timeout: float = 5.0\n    ):\n        \"\"\"\n        Execute query, ensuring read model is at expected version.\n        Used for read-your-writes consistency.\n        \"\"\"\n        start_time = time.time()\n\n        while time.time() - start_time < timeout:\n            # Check if read model is caught up\n            projection_version = await self._get_projection_version(stream_id)\n\n            if projection_version >= expected_version:\n                return await self.execute_query(query)\n\n            # Wait a bit and retry\n            await asyncio.sleep(0.1)\n\n        # Timeout - return stale data with warning\n        return {\n            \"data\": await self.execute_query(query),\n            \"_warning\": \"Data may be stale\"\n        }\n\n    async def _get_projection_version(self, stream_id: str) -> int:\n        \"\"\"Get the last processed event version for a stream.\"\"\"\n        async with self.read_db.acquire() as conn:\n            return await conn.fetchval(\n                \"SELECT last_event_version FROM projection_state WHERE stream_id = $1\",\n                stream_id\n            ) or 0\n```\n\n## Best Practices\n\n### Do's\n- **Separate command and query models** - Different needs\n- **Use eventual consistency** - Accept propagation delay\n- **Validate in command handlers** - Before state change\n- **Denormalize read models** - Optimize for queries\n- **Version your events** - For schema evolution\n\n### Don'ts\n- **Don't query in commands** - Use only for writes\n- **Don't couple read/write schemas** - Independent evolution\n- **Don't over-engineer** - Start simple\n- **Don't ignore consistency SLAs** - Define acceptable lag\n\n## Resources\n\n- [CQRS Pattern](https://martinfowler.com/bliki/CQRS.html)\n- [Microsoft CQRS Guidance](https://docs.microsoft.com/en-us/azure/architecture/patterns/cqrs)\n"
}