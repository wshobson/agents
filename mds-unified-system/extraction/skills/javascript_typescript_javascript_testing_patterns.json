{
  "id": "javascript_typescript_javascript_testing_patterns",
  "name": "javascript-testing-patterns",
  "source": "javascript-typescript",
  "originalPath": "plugins/javascript-typescript/skills/javascript-testing-patterns/SKILL.md",
  "activationCriteria": "Implement comprehensive testing strategies using Jest, Vitest, and Testing Library for unit tests, integration tests, and end-to-end testing with mocking, fixtures, and test-driven development. Use wh",
  "tier1_metadata": "javascript-testing-patterns: Implement comprehensive testing strategies using Jest, Vitest, and Testing Library for unit tests, i",
  "tier2_instructions": "# JavaScript Testing Patterns\n\nComprehensive guide for implementing robust testing strategies in JavaScript/TypeScript applications using modern testing frameworks and best practices.\n\n## When to Use This Skill\n\n- Setting up test infrastructure for new projects\n- Writing unit tests for functions and classes\n- Creating integration tests for APIs and services\n- Implementing end-to-end tests for user flows\n- Mocking external dependencies and APIs\n- Testing React, Vue, or other frontend components\n- Implementing test-driven development (TDD)\n- Setting up continuous testing in CI/CD pipelines\n\n## Testing Frameworks\n\n### Jest - Full-Featured Testing Framework\n\n**Setup:**\n```typescript\n// jest.config.ts\nimport type { Config } from 'jest';\n\nconst config: Config = {\n  preset: 'ts-jest',\n  testEnvironment: 'node',\n  roots: ['<rootDir>/src'],\n  testMatch: ['**/__tests__/**/*.ts', '**/?(*.)+(spec|test).ts'],\n  collectCoverageFrom: [\n    'src/**/*.ts',\n    '!src/**/*.d.ts',\n    '!src/**/*.interface.ts',\n  ],\n  coverageThreshold: {\n    global: {\n      branches: 80,\n      functions: 80,\n      lines: 80,\n      statements: 80,\n    },\n  },\n  setupFilesAfterEnv: ['<rootDir>/src/test/setup.ts'],\n};\n\nexport default config;\n```\n\n### Vitest - Fast, Vite-Native Testing\n\n**Setup:**\n```typescript\n// vitest.config.ts\nimport { defineConfig } from 'vitest/config';\n\nexport default defineConfig({\n  test: {\n    globals: true,\n    environment: 'node',\n    coverage: {\n      provider: 'v8',\n      reporter: ['text', 'json', 'html'],\n      exclude: ['**/*.d.ts', '**/*.config.ts', '**/dist/**'],\n    },\n    setupFiles: ['./src/test/setup.ts'],\n  },\n});\n```\n\n## Unit Testing Patterns\n\n### Pattern 1: Testing Pure Functions\n\n```typescript\n// utils/calculator.ts\nexport function add(a: number, b: number): number {\n  return a + b;\n}\n\nexport function divide(a: number, b: number): number {\n  if (b === 0) {\n    throw new Error('Division by zero');\n  }\n  return a / b;\n}\n\n// utils/calculator.test.ts\nimport { describ",
  "tier3_resources": "e, it, expect } from 'vitest';\nimport { add, divide } from './calculator';\n\ndescribe('Calculator', () => {\n  describe('add', () => {\n    it('should add two positive numbers', () => {\n      expect(add(2, 3)).toBe(5);\n    });\n\n    it('should add negative numbers', () => {\n      expect(add(-2, -3)).toBe(-5);\n    });\n\n    it('should handle zero', () => {\n      expect(add(0, 5)).toBe(5);\n      expect(add(5, 0)).toBe(5);\n    });\n  });\n\n  describe('divide', () => {\n    it('should divide two numbers', () => {\n      expect(divide(10, 2)).toBe(5);\n    });\n\n    it('should handle decimal results', () => {\n      expect(divide(5, 2)).toBe(2.5);\n    });\n\n    it('should throw error when dividing by zero', () => {\n      expect(() => divide(10, 0)).toThrow('Division by zero');\n    });\n  });\n});\n```\n\n### Pattern 2: Testing Classes\n\n```typescript\n// services/user.service.ts\nexport class UserService {\n  private users: Map<string, User> = new Map();\n\n  create(user: User): User {\n    if (this.users.has(user.id)) {\n      throw new Error('User already exists');\n    }\n    this.users.set(user.id, user);\n    return user;\n  }\n\n  findById(id: string): User | undefined {\n    return this.users.get(id);\n  }\n\n  update(id: string, updates: Partial<User>): User {\n    const user = this.users.get(id);\n    if (!user) {\n      throw new Error('User not found');\n    }\n    const updated = { ...user, ...updates };\n    this.users.set(id, updated);\n    return updated;\n  }\n\n  delete(id: string): boolean {\n    return this.users.delete(id);\n  }\n}\n\n// services/user.service.test.ts\nimport { describe, it, expect, beforeEach } from 'vitest';\nimport { UserService } from './user.service';\n\ndescribe('UserService', () => {\n  let service: UserService;\n\n  beforeEach(() => {\n    service = new UserService();\n  });\n\n  describe('create', () => {\n    it('should create a new user', () => {\n      const user = { id: '1', name: 'John', email: 'john@example.com' };\n      const created = service.create(user);\n\n      expect(created).toEqual(user);\n      expect(service.findById('1')).toEqual(user);\n    });\n\n    it('should throw error if user already exists', () => {\n      const user = { id: '1', name: 'John', email: 'john@example.com' };\n      service.create(user);\n\n      expect(() => service.create(user)).toThrow('User already exists');\n    });\n  });\n\n  describe('update', () => {\n    it('should update existing user', () => {\n      const user = { id: '1', name: 'John', email: 'john@example.com' };\n      service.create(user);\n\n      const updated = service.update('1', { name: 'Jane' });\n\n      expect(updated.name).toBe('Jane');\n      expect(updated.email).toBe('john@example.com');\n    });\n\n    it('should throw error if user not found', () => {\n      expect(() => service.update('999', { name: 'Jane' }))\n        .toThrow('User not found');\n    });\n  });\n});\n```\n\n### Pattern 3: Testing Async Functions\n\n```typescript\n// services/api.service.ts\nexport class ApiService {\n  async fetchUser(id: string): Promise<User> {\n    co",
  "tokenEstimate": {
    "tier1": 19.5,
    "tier2": 317.2,
    "tier3": 3209.7000000000003
  },
  "fullDefinition": "---\nname: javascript-testing-patterns\ndescription: Implement comprehensive testing strategies using Jest, Vitest, and Testing Library for unit tests, integration tests, and end-to-end testing with mocking, fixtures, and test-driven development. Use when writing JavaScript/TypeScript tests, setting up test infrastructure, or implementing TDD/BDD workflows.\n---\n\n# JavaScript Testing Patterns\n\nComprehensive guide for implementing robust testing strategies in JavaScript/TypeScript applications using modern testing frameworks and best practices.\n\n## When to Use This Skill\n\n- Setting up test infrastructure for new projects\n- Writing unit tests for functions and classes\n- Creating integration tests for APIs and services\n- Implementing end-to-end tests for user flows\n- Mocking external dependencies and APIs\n- Testing React, Vue, or other frontend components\n- Implementing test-driven development (TDD)\n- Setting up continuous testing in CI/CD pipelines\n\n## Testing Frameworks\n\n### Jest - Full-Featured Testing Framework\n\n**Setup:**\n```typescript\n// jest.config.ts\nimport type { Config } from 'jest';\n\nconst config: Config = {\n  preset: 'ts-jest',\n  testEnvironment: 'node',\n  roots: ['<rootDir>/src'],\n  testMatch: ['**/__tests__/**/*.ts', '**/?(*.)+(spec|test).ts'],\n  collectCoverageFrom: [\n    'src/**/*.ts',\n    '!src/**/*.d.ts',\n    '!src/**/*.interface.ts',\n  ],\n  coverageThreshold: {\n    global: {\n      branches: 80,\n      functions: 80,\n      lines: 80,\n      statements: 80,\n    },\n  },\n  setupFilesAfterEnv: ['<rootDir>/src/test/setup.ts'],\n};\n\nexport default config;\n```\n\n### Vitest - Fast, Vite-Native Testing\n\n**Setup:**\n```typescript\n// vitest.config.ts\nimport { defineConfig } from 'vitest/config';\n\nexport default defineConfig({\n  test: {\n    globals: true,\n    environment: 'node',\n    coverage: {\n      provider: 'v8',\n      reporter: ['text', 'json', 'html'],\n      exclude: ['**/*.d.ts', '**/*.config.ts', '**/dist/**'],\n    },\n    setupFiles: ['./src/test/setup.ts'],\n  },\n});\n```\n\n## Unit Testing Patterns\n\n### Pattern 1: Testing Pure Functions\n\n```typescript\n// utils/calculator.ts\nexport function add(a: number, b: number): number {\n  return a + b;\n}\n\nexport function divide(a: number, b: number): number {\n  if (b === 0) {\n    throw new Error('Division by zero');\n  }\n  return a / b;\n}\n\n// utils/calculator.test.ts\nimport { describe, it, expect } from 'vitest';\nimport { add, divide } from './calculator';\n\ndescribe('Calculator', () => {\n  describe('add', () => {\n    it('should add two positive numbers', () => {\n      expect(add(2, 3)).toBe(5);\n    });\n\n    it('should add negative numbers', () => {\n      expect(add(-2, -3)).toBe(-5);\n    });\n\n    it('should handle zero', () => {\n      expect(add(0, 5)).toBe(5);\n      expect(add(5, 0)).toBe(5);\n    });\n  });\n\n  describe('divide', () => {\n    it('should divide two numbers', () => {\n      expect(divide(10, 2)).toBe(5);\n    });\n\n    it('should handle decimal results', () => {\n      expect(divide(5, 2)).toBe(2.5);\n    });\n\n    it('should throw error when dividing by zero', () => {\n      expect(() => divide(10, 0)).toThrow('Division by zero');\n    });\n  });\n});\n```\n\n### Pattern 2: Testing Classes\n\n```typescript\n// services/user.service.ts\nexport class UserService {\n  private users: Map<string, User> = new Map();\n\n  create(user: User): User {\n    if (this.users.has(user.id)) {\n      throw new Error('User already exists');\n    }\n    this.users.set(user.id, user);\n    return user;\n  }\n\n  findById(id: string): User | undefined {\n    return this.users.get(id);\n  }\n\n  update(id: string, updates: Partial<User>): User {\n    const user = this.users.get(id);\n    if (!user) {\n      throw new Error('User not found');\n    }\n    const updated = { ...user, ...updates };\n    this.users.set(id, updated);\n    return updated;\n  }\n\n  delete(id: string): boolean {\n    return this.users.delete(id);\n  }\n}\n\n// services/user.service.test.ts\nimport { describe, it, expect, beforeEach } from 'vitest';\nimport { UserService } from './user.service';\n\ndescribe('UserService', () => {\n  let service: UserService;\n\n  beforeEach(() => {\n    service = new UserService();\n  });\n\n  describe('create', () => {\n    it('should create a new user', () => {\n      const user = { id: '1', name: 'John', email: 'john@example.com' };\n      const created = service.create(user);\n\n      expect(created).toEqual(user);\n      expect(service.findById('1')).toEqual(user);\n    });\n\n    it('should throw error if user already exists', () => {\n      const user = { id: '1', name: 'John', email: 'john@example.com' };\n      service.create(user);\n\n      expect(() => service.create(user)).toThrow('User already exists');\n    });\n  });\n\n  describe('update', () => {\n    it('should update existing user', () => {\n      const user = { id: '1', name: 'John', email: 'john@example.com' };\n      service.create(user);\n\n      const updated = service.update('1', { name: 'Jane' });\n\n      expect(updated.name).toBe('Jane');\n      expect(updated.email).toBe('john@example.com');\n    });\n\n    it('should throw error if user not found', () => {\n      expect(() => service.update('999', { name: 'Jane' }))\n        .toThrow('User not found');\n    });\n  });\n});\n```\n\n### Pattern 3: Testing Async Functions\n\n```typescript\n// services/api.service.ts\nexport class ApiService {\n  async fetchUser(id: string): Promise<User> {\n    const response = await fetch(`https://api.example.com/users/${id}`);\n    if (!response.ok) {\n      throw new Error('User not found');\n    }\n    return response.json();\n  }\n\n  async createUser(user: CreateUserDTO): Promise<User> {\n    const response = await fetch('https://api.example.com/users', {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify(user),\n    });\n    return response.json();\n  }\n}\n\n// services/api.service.test.ts\nimport { describe, it, expect, vi, beforeEach } from 'vitest';\nimport { ApiService } from './api.service';\n\n// Mock fetch globally\nglobal.fetch = vi.fn();\n\ndescribe('ApiService', () => {\n  let service: ApiService;\n\n  beforeEach(() => {\n    service = new ApiService();\n    vi.clearAllMocks();\n  });\n\n  describe('fetchUser', () => {\n    it('should fetch user successfully', async () => {\n      const mockUser = { id: '1', name: 'John', email: 'john@example.com' };\n\n      (fetch as any).mockResolvedValueOnce({\n        ok: true,\n        json: async () => mockUser,\n      });\n\n      const user = await service.fetchUser('1');\n\n      expect(user).toEqual(mockUser);\n      expect(fetch).toHaveBeenCalledWith('https://api.example.com/users/1');\n    });\n\n    it('should throw error if user not found', async () => {\n      (fetch as any).mockResolvedValueOnce({\n        ok: false,\n      });\n\n      await expect(service.fetchUser('999')).rejects.toThrow('User not found');\n    });\n  });\n\n  describe('createUser', () => {\n    it('should create user successfully', async () => {\n      const newUser = { name: 'John', email: 'john@example.com' };\n      const createdUser = { id: '1', ...newUser };\n\n      (fetch as any).mockResolvedValueOnce({\n        ok: true,\n        json: async () => createdUser,\n      });\n\n      const user = await service.createUser(newUser);\n\n      expect(user).toEqual(createdUser);\n      expect(fetch).toHaveBeenCalledWith(\n        'https://api.example.com/users',\n        expect.objectContaining({\n          method: 'POST',\n          body: JSON.stringify(newUser),\n        })\n      );\n    });\n  });\n});\n```\n\n## Mocking Patterns\n\n### Pattern 1: Mocking Modules\n\n```typescript\n// services/email.service.ts\nimport nodemailer from 'nodemailer';\n\nexport class EmailService {\n  private transporter = nodemailer.createTransport({\n    host: process.env.SMTP_HOST,\n    port: 587,\n    auth: {\n      user: process.env.SMTP_USER,\n      pass: process.env.SMTP_PASS,\n    },\n  });\n\n  async sendEmail(to: string, subject: string, html: string) {\n    await this.transporter.sendMail({\n      from: process.env.EMAIL_FROM,\n      to,\n      subject,\n      html,\n    });\n  }\n}\n\n// services/email.service.test.ts\nimport { describe, it, expect, vi, beforeEach } from 'vitest';\nimport { EmailService } from './email.service';\n\nvi.mock('nodemailer', () => ({\n  default: {\n    createTransport: vi.fn(() => ({\n      sendMail: vi.fn().mockResolvedValue({ messageId: '123' }),\n    })),\n  },\n}));\n\ndescribe('EmailService', () => {\n  let service: EmailService;\n\n  beforeEach(() => {\n    service = new EmailService();\n  });\n\n  it('should send email successfully', async () => {\n    await service.sendEmail(\n      'test@example.com',\n      'Test Subject',\n      '<p>Test Body</p>'\n    );\n\n    expect(service['transporter'].sendMail).toHaveBeenCalledWith(\n      expect.objectContaining({\n        to: 'test@example.com',\n        subject: 'Test Subject',\n      })\n    );\n  });\n});\n```\n\n### Pattern 2: Dependency Injection for Testing\n\n```typescript\n// services/user.service.ts\nexport interface IUserRepository {\n  findById(id: string): Promise<User | null>;\n  create(user: User): Promise<User>;\n}\n\nexport class UserService {\n  constructor(private userRepository: IUserRepository) {}\n\n  async getUser(id: string): Promise<User> {\n    const user = await this.userRepository.findById(id);\n    if (!user) {\n      throw new Error('User not found');\n    }\n    return user;\n  }\n\n  async createUser(userData: CreateUserDTO): Promise<User> {\n    // Business logic here\n    const user = { id: generateId(), ...userData };\n    return this.userRepository.create(user);\n  }\n}\n\n// services/user.service.test.ts\nimport { describe, it, expect, vi, beforeEach } from 'vitest';\nimport { UserService, IUserRepository } from './user.service';\n\ndescribe('UserService', () => {\n  let service: UserService;\n  let mockRepository: IUserRepository;\n\n  beforeEach(() => {\n    mockRepository = {\n      findById: vi.fn(),\n      create: vi.fn(),\n    };\n    service = new UserService(mockRepository);\n  });\n\n  describe('getUser', () => {\n    it('should return user if found', async () => {\n      const mockUser = { id: '1', name: 'John', email: 'john@example.com' };\n      vi.mocked(mockRepository.findById).mockResolvedValue(mockUser);\n\n      const user = await service.getUser('1');\n\n      expect(user).toEqual(mockUser);\n      expect(mockRepository.findById).toHaveBeenCalledWith('1');\n    });\n\n    it('should throw error if user not found', async () => {\n      vi.mocked(mockRepository.findById).mockResolvedValue(null);\n\n      await expect(service.getUser('999')).rejects.toThrow('User not found');\n    });\n  });\n\n  describe('createUser', () => {\n    it('should create user successfully', async () => {\n      const userData = { name: 'John', email: 'john@example.com' };\n      const createdUser = { id: '1', ...userData };\n\n      vi.mocked(mockRepository.create).mockResolvedValue(createdUser);\n\n      const user = await service.createUser(userData);\n\n      expect(user).toEqual(createdUser);\n      expect(mockRepository.create).toHaveBeenCalled();\n    });\n  });\n});\n```\n\n### Pattern 3: Spying on Functions\n\n```typescript\n// utils/logger.ts\nexport const logger = {\n  info: (message: string) => console.log(`INFO: ${message}`),\n  error: (message: string) => console.error(`ERROR: ${message}`),\n};\n\n// services/order.service.ts\nimport { logger } from '../utils/logger';\n\nexport class OrderService {\n  async processOrder(orderId: string): Promise<void> {\n    logger.info(`Processing order ${orderId}`);\n    // Process order logic\n    logger.info(`Order ${orderId} processed successfully`);\n  }\n}\n\n// services/order.service.test.ts\nimport { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';\nimport { OrderService } from './order.service';\nimport { logger } from '../utils/logger';\n\ndescribe('OrderService', () => {\n  let service: OrderService;\n  let loggerSpy: any;\n\n  beforeEach(() => {\n    service = new OrderService();\n    loggerSpy = vi.spyOn(logger, 'info');\n  });\n\n  afterEach(() => {\n    loggerSpy.mockRestore();\n  });\n\n  it('should log order processing', async () => {\n    await service.processOrder('123');\n\n    expect(loggerSpy).toHaveBeenCalledWith('Processing order 123');\n    expect(loggerSpy).toHaveBeenCalledWith('Order 123 processed successfully');\n    expect(loggerSpy).toHaveBeenCalledTimes(2);\n  });\n});\n```\n\n## Integration Testing\n\n### Pattern 1: API Integration Tests\n\n```typescript\n// tests/integration/user.api.test.ts\nimport request from 'supertest';\nimport { app } from '../../src/app';\nimport { pool } from '../../src/config/database';\n\ndescribe('User API Integration Tests', () => {\n  beforeAll(async () => {\n    // Setup test database\n    await pool.query('CREATE TABLE IF NOT EXISTS users (...)');\n  });\n\n  afterAll(async () => {\n    // Cleanup\n    await pool.query('DROP TABLE IF EXISTS users');\n    await pool.end();\n  });\n\n  beforeEach(async () => {\n    // Clear data before each test\n    await pool.query('TRUNCATE TABLE users CASCADE');\n  });\n\n  describe('POST /api/users', () => {\n    it('should create a new user', async () => {\n      const userData = {\n        name: 'John Doe',\n        email: 'john@example.com',\n        password: 'password123',\n      };\n\n      const response = await request(app)\n        .post('/api/users')\n        .send(userData)\n        .expect(201);\n\n      expect(response.body).toMatchObject({\n        name: userData.name,\n        email: userData.email,\n      });\n      expect(response.body).toHaveProperty('id');\n      expect(response.body).not.toHaveProperty('password');\n    });\n\n    it('should return 400 if email is invalid', async () => {\n      const userData = {\n        name: 'John Doe',\n        email: 'invalid-email',\n        password: 'password123',\n      };\n\n      const response = await request(app)\n        .post('/api/users')\n        .send(userData)\n        .expect(400);\n\n      expect(response.body).toHaveProperty('error');\n    });\n\n    it('should return 409 if email already exists', async () => {\n      const userData = {\n        name: 'John Doe',\n        email: 'john@example.com',\n        password: 'password123',\n      };\n\n      await request(app).post('/api/users').send(userData);\n\n      const response = await request(app)\n        .post('/api/users')\n        .send(userData)\n        .expect(409);\n\n      expect(response.body.error).toContain('already exists');\n    });\n  });\n\n  describe('GET /api/users/:id', () => {\n    it('should get user by id', async () => {\n      const createResponse = await request(app)\n        .post('/api/users')\n        .send({\n          name: 'John Doe',\n          email: 'john@example.com',\n          password: 'password123',\n        });\n\n      const userId = createResponse.body.id;\n\n      const response = await request(app)\n        .get(`/api/users/${userId}`)\n        .expect(200);\n\n      expect(response.body).toMatchObject({\n        id: userId,\n        name: 'John Doe',\n        email: 'john@example.com',\n      });\n    });\n\n    it('should return 404 if user not found', async () => {\n      await request(app)\n        .get('/api/users/999')\n        .expect(404);\n    });\n  });\n\n  describe('Authentication', () => {\n    it('should require authentication for protected routes', async () => {\n      await request(app)\n        .get('/api/users/me')\n        .expect(401);\n    });\n\n    it('should allow access with valid token', async () => {\n      // Create user and login\n      await request(app)\n        .post('/api/users')\n        .send({\n          name: 'John Doe',\n          email: 'john@example.com',\n          password: 'password123',\n        });\n\n      const loginResponse = await request(app)\n        .post('/api/auth/login')\n        .send({\n          email: 'john@example.com',\n          password: 'password123',\n        });\n\n      const token = loginResponse.body.token;\n\n      const response = await request(app)\n        .get('/api/users/me')\n        .set('Authorization', `Bearer ${token}`)\n        .expect(200);\n\n      expect(response.body.email).toBe('john@example.com');\n    });\n  });\n});\n```\n\n### Pattern 2: Database Integration Tests\n\n```typescript\n// tests/integration/user.repository.test.ts\nimport { describe, it, expect, beforeAll, afterAll, beforeEach } from 'vitest';\nimport { Pool } from 'pg';\nimport { UserRepository } from '../../src/repositories/user.repository';\n\ndescribe('UserRepository Integration Tests', () => {\n  let pool: Pool;\n  let repository: UserRepository;\n\n  beforeAll(async () => {\n    pool = new Pool({\n      host: 'localhost',\n      port: 5432,\n      database: 'test_db',\n      user: 'test_user',\n      password: 'test_password',\n    });\n\n    repository = new UserRepository(pool);\n\n    // Create tables\n    await pool.query(`\n      CREATE TABLE IF NOT EXISTS users (\n        id SERIAL PRIMARY KEY,\n        name VARCHAR(255) NOT NULL,\n        email VARCHAR(255) UNIQUE NOT NULL,\n        password VARCHAR(255) NOT NULL,\n        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n      )\n    `);\n  });\n\n  afterAll(async () => {\n    await pool.query('DROP TABLE IF EXISTS users');\n    await pool.end();\n  });\n\n  beforeEach(async () => {\n    await pool.query('TRUNCATE TABLE users CASCADE');\n  });\n\n  it('should create a user', async () => {\n    const user = await repository.create({\n      name: 'John Doe',\n      email: 'john@example.com',\n      password: 'hashed_password',\n    });\n\n    expect(user).toHaveProperty('id');\n    expect(user.name).toBe('John Doe');\n    expect(user.email).toBe('john@example.com');\n  });\n\n  it('should find user by email', async () => {\n    await repository.create({\n      name: 'John Doe',\n      email: 'john@example.com',\n      password: 'hashed_password',\n    });\n\n    const user = await repository.findByEmail('john@example.com');\n\n    expect(user).toBeTruthy();\n    expect(user?.name).toBe('John Doe');\n  });\n\n  it('should return null if user not found', async () => {\n    const user = await repository.findByEmail('nonexistent@example.com');\n    expect(user).toBeNull();\n  });\n});\n```\n\n## Frontend Testing with Testing Library\n\n### Pattern 1: React Component Testing\n\n```typescript\n// components/UserForm.tsx\nimport { useState } from 'react';\n\ninterface Props {\n  onSubmit: (user: { name: string; email: string }) => void;\n}\n\nexport function UserForm({ onSubmit }: Props) {\n  const [name, setName] = useState('');\n  const [email, setEmail] = useState('');\n\n  const handleSubmit = (e: React.FormEvent) => {\n    e.preventDefault();\n    onSubmit({ name, email });\n  };\n\n  return (\n    <form onSubmit={handleSubmit}>\n      <input\n        type=\"text\"\n        placeholder=\"Name\"\n        value={name}\n        onChange={(e) => setName(e.target.value)}\n        data-testid=\"name-input\"\n      />\n      <input\n        type=\"email\"\n        placeholder=\"Email\"\n        value={email}\n        onChange={(e) => setEmail(e.target.value)}\n        data-testid=\"email-input\"\n      />\n      <button type=\"submit\">Submit</button>\n    </form>\n  );\n}\n\n// components/UserForm.test.tsx\nimport { render, screen, fireEvent } from '@testing-library/react';\nimport { describe, it, expect, vi } from 'vitest';\nimport { UserForm } from './UserForm';\n\ndescribe('UserForm', () => {\n  it('should render form inputs', () => {\n    render(<UserForm onSubmit={vi.fn()} />);\n\n    expect(screen.getByPlaceholderText('Name')).toBeInTheDocument();\n    expect(screen.getByPlaceholderText('Email')).toBeInTheDocument();\n    expect(screen.getByRole('button', { name: 'Submit' })).toBeInTheDocument();\n  });\n\n  it('should update input values', () => {\n    render(<UserForm onSubmit={vi.fn()} />);\n\n    const nameInput = screen.getByTestId('name-input') as HTMLInputElement;\n    const emailInput = screen.getByTestId('email-input') as HTMLInputElement;\n\n    fireEvent.change(nameInput, { target: { value: 'John Doe' } });\n    fireEvent.change(emailInput, { target: { value: 'john@example.com' } });\n\n    expect(nameInput.value).toBe('John Doe');\n    expect(emailInput.value).toBe('john@example.com');\n  });\n\n  it('should call onSubmit with form data', () => {\n    const onSubmit = vi.fn();\n    render(<UserForm onSubmit={onSubmit} />);\n\n    fireEvent.change(screen.getByTestId('name-input'), {\n      target: { value: 'John Doe' },\n    });\n    fireEvent.change(screen.getByTestId('email-input'), {\n      target: { value: 'john@example.com' },\n    });\n    fireEvent.click(screen.getByRole('button', { name: 'Submit' }));\n\n    expect(onSubmit).toHaveBeenCalledWith({\n      name: 'John Doe',\n      email: 'john@example.com',\n    });\n  });\n});\n```\n\n### Pattern 2: Testing Hooks\n\n```typescript\n// hooks/useCounter.ts\nimport { useState, useCallback } from 'react';\n\nexport function useCounter(initialValue = 0) {\n  const [count, setCount] = useState(initialValue);\n\n  const increment = useCallback(() => setCount((c) => c + 1), []);\n  const decrement = useCallback(() => setCount((c) => c - 1), []);\n  const reset = useCallback(() => setCount(initialValue), [initialValue]);\n\n  return { count, increment, decrement, reset };\n}\n\n// hooks/useCounter.test.ts\nimport { renderHook, act } from '@testing-library/react';\nimport { describe, it, expect } from 'vitest';\nimport { useCounter } from './useCounter';\n\ndescribe('useCounter', () => {\n  it('should initialize with default value', () => {\n    const { result } = renderHook(() => useCounter());\n    expect(result.current.count).toBe(0);\n  });\n\n  it('should initialize with custom value', () => {\n    const { result } = renderHook(() => useCounter(10));\n    expect(result.current.count).toBe(10);\n  });\n\n  it('should increment count', () => {\n    const { result } = renderHook(() => useCounter());\n\n    act(() => {\n      result.current.increment();\n    });\n\n    expect(result.current.count).toBe(1);\n  });\n\n  it('should decrement count', () => {\n    const { result } = renderHook(() => useCounter(5));\n\n    act(() => {\n      result.current.decrement();\n    });\n\n    expect(result.current.count).toBe(4);\n  });\n\n  it('should reset to initial value', () => {\n    const { result } = renderHook(() => useCounter(10));\n\n    act(() => {\n      result.current.increment();\n      result.current.increment();\n    });\n\n    expect(result.current.count).toBe(12);\n\n    act(() => {\n      result.current.reset();\n    });\n\n    expect(result.current.count).toBe(10);\n  });\n});\n```\n\n## Test Fixtures and Factories\n\n```typescript\n// tests/fixtures/user.fixture.ts\nimport { faker } from '@faker-js/faker';\n\nexport function createUserFixture(overrides?: Partial<User>): User {\n  return {\n    id: faker.string.uuid(),\n    name: faker.person.fullName(),\n    email: faker.internet.email(),\n    createdAt: faker.date.past(),\n    ...overrides,\n  };\n}\n\nexport function createUsersFixture(count: number): User[] {\n  return Array.from({ length: count }, () => createUserFixture());\n}\n\n// Usage in tests\nimport { createUserFixture, createUsersFixture } from '../fixtures/user.fixture';\n\ndescribe('UserService', () => {\n  it('should process user', () => {\n    const user = createUserFixture({ name: 'John Doe' });\n    // Use user in test\n  });\n\n  it('should handle multiple users', () => {\n    const users = createUsersFixture(10);\n    // Use users in test\n  });\n});\n```\n\n## Snapshot Testing\n\n```typescript\n// components/UserCard.test.tsx\nimport { render } from '@testing-library/react';\nimport { describe, it, expect } from 'vitest';\nimport { UserCard } from './UserCard';\n\ndescribe('UserCard', () => {\n  it('should match snapshot', () => {\n    const user = {\n      id: '1',\n      name: 'John Doe',\n      email: 'john@example.com',\n      avatar: 'https://example.com/avatar.jpg',\n    };\n\n    const { container } = render(<UserCard user={user} />);\n\n    expect(container.firstChild).toMatchSnapshot();\n  });\n\n  it('should match snapshot with loading state', () => {\n    const { container } = render(<UserCard loading />);\n    expect(container.firstChild).toMatchSnapshot();\n  });\n});\n```\n\n## Coverage Reports\n\n```typescript\n// package.json\n{\n  \"scripts\": {\n    \"test\": \"vitest\",\n    \"test:coverage\": \"vitest --coverage\",\n    \"test:ui\": \"vitest --ui\"\n  }\n}\n```\n\n## Best Practices\n\n1. **Follow AAA Pattern**: Arrange, Act, Assert\n2. **One assertion per test**: Or logically related assertions\n3. **Descriptive test names**: Should describe what is being tested\n4. **Use beforeEach/afterEach**: For setup and teardown\n5. **Mock external dependencies**: Keep tests isolated\n6. **Test edge cases**: Not just happy paths\n7. **Avoid implementation details**: Test behavior, not implementation\n8. **Use test factories**: For consistent test data\n9. **Keep tests fast**: Mock slow operations\n10. **Write tests first (TDD)**: When possible\n11. **Maintain test coverage**: Aim for 80%+ coverage\n12. **Use TypeScript**: For type-safe tests\n13. **Test error handling**: Not just success cases\n14. **Use data-testid sparingly**: Prefer semantic queries\n15. **Clean up after tests**: Prevent test pollution\n\n## Common Patterns\n\n### Test Organization\n\n```typescript\ndescribe('UserService', () => {\n  describe('createUser', () => {\n    it('should create user successfully', () => {});\n    it('should throw error if email exists', () => {});\n    it('should hash password', () => {});\n  });\n\n  describe('updateUser', () => {\n    it('should update user', () => {});\n    it('should throw error if not found', () => {});\n  });\n});\n```\n\n### Testing Promises\n\n```typescript\n// Using async/await\nit('should fetch user', async () => {\n  const user = await service.fetchUser('1');\n  expect(user).toBeDefined();\n});\n\n// Testing rejections\nit('should throw error', async () => {\n  await expect(service.fetchUser('invalid')).rejects.toThrow('Not found');\n});\n```\n\n### Testing Timers\n\n```typescript\nimport { vi } from 'vitest';\n\nit('should call function after delay', () => {\n  vi.useFakeTimers();\n\n  const callback = vi.fn();\n  setTimeout(callback, 1000);\n\n  expect(callback).not.toHaveBeenCalled();\n\n  vi.advanceTimersByTime(1000);\n\n  expect(callback).toHaveBeenCalled();\n\n  vi.useRealTimers();\n});\n```\n\n## Resources\n\n- **Jest Documentation**: https://jestjs.io/\n- **Vitest Documentation**: https://vitest.dev/\n- **Testing Library**: https://testing-library.com/\n- **Kent C. Dodds Testing Blog**: https://kentcdodds.com/blog/\n"
}