{
  "id": "cicd_automation_gitlab_ci_patterns",
  "name": "gitlab-ci-patterns",
  "source": "cicd-automation",
  "originalPath": "plugins/cicd-automation/skills/gitlab-ci-patterns/SKILL.md",
  "activationCriteria": "Build GitLab CI/CD pipelines with multi-stage workflows, caching, and distributed runners for scalable automation. Use when implementing GitLab CI/CD, optimizing pipeline performance, or setting up au",
  "tier1_metadata": "gitlab-ci-patterns: Build GitLab CI/CD pipelines with multi-stage workflows, caching, and distributed runners for scalab",
  "tier2_instructions": "# GitLab CI Patterns\n\nComprehensive GitLab CI/CD pipeline patterns for automated testing, building, and deployment.\n\n## Purpose\n\nCreate efficient GitLab CI pipelines with proper stage organization, caching, and deployment strategies.\n\n## When to Use\n\n- Automate GitLab-based CI/CD\n- Implement multi-stage pipelines\n- Configure GitLab Runners\n- Deploy to Kubernetes from GitLab\n- Implement GitOps workflows\n\n## Basic Pipeline Structure\n\n```yaml\nstages:\n  - build\n  - test\n  - deploy\n\nvariables:\n  DOCKER_DRIVER: overlay2\n  DOCKER_TLS_CERTDIR: \"/certs\"\n\nbuild:\n  stage: build\n  image: node:20\n  script:\n    - npm ci\n    - npm run build\n  artifacts:\n    paths:\n      - dist/\n    expire_in: 1 hour\n  cache:\n    key: ${CI_COMMIT_REF_SLUG}\n    paths:\n      - node_modules/\n\ntest:\n  stage: test\n  image: node:20\n  script:\n    - npm ci\n    - npm run lint\n    - npm test\n  coverage: '/Lines\\s*:\\s*(\\d+\\.\\d+)%/'\n  artifacts:\n    reports:\n      coverage_report:\n        coverage_format: cobertura\n        path: coverage/cobertura-coverage.xml\n\ndeploy:\n  stage: deploy\n  image: bitnami/kubectl:latest\n  script:\n    - kubectl apply -f k8s/\n    - kubectl rollout status deployment/my-app\n  only:\n    - main\n  environment:\n    name: production\n    url: https://app.example.com\n```\n\n## Docker Build and Push\n\n```yaml\nbuild-docker:\n  stage: build\n  image: docker:24\n  services:\n    - docker:24-dind\n  before_script:\n    - docker login -u $CI_REGISTRY_USER -p $CI_REGISTRY_PASSWORD $CI_REGISTRY\n  script:\n    - docker build -t $CI_REGISTRY_IMAGE:$CI_COMMIT_SHA .\n    - docker build -t $CI_REGISTRY_IMAGE:latest .\n    - docker push $CI_REGISTRY_IMAGE:$CI_COMMIT_SHA\n    - docker push $CI_REGISTRY_IMAGE:latest\n  only:\n    - main\n    - tags\n```\n\n## Multi-Environment Deployment\n\n```yaml\n.deploy_template: &deploy_template\n  image: bitnami/kubectl:latest\n  before_script:\n    - kubectl config set-cluster k8s --server=\"$KUBE_URL\" --insecure-skip-tls-verify=true\n    - kubectl config set-credentials admin --token=\"$KUBE_T",
  "tier3_resources": "OKEN\"\n    - kubectl config set-context default --cluster=k8s --user=admin\n    - kubectl config use-context default\n\ndeploy:staging:\n  <<: *deploy_template\n  stage: deploy\n  script:\n    - kubectl apply -f k8s/ -n staging\n    - kubectl rollout status deployment/my-app -n staging\n  environment:\n    name: staging\n    url: https://staging.example.com\n  only:\n    - develop\n\ndeploy:production:\n  <<: *deploy_template\n  stage: deploy\n  script:\n    - kubectl apply -f k8s/ -n production\n    - kubectl rollout status deployment/my-app -n production\n  environment:\n    name: production\n    url: https://app.example.com\n  when: manual\n  only:\n    - main\n```\n\n## Terraform Pipeline\n\n```yaml\nstages:\n  - validate\n  - plan\n  - apply\n\nvariables:\n  TF_ROOT: ${CI_PROJECT_DIR}/terraform\n  TF_VERSION: \"1.6.0\"\n\nbefore_script:\n  - cd ${TF_ROOT}\n  - terraform --version\n\nvalidate:\n  stage: validate\n  image: hashicorp/terraform:${TF_VERSION}\n  script:\n    - terraform init -backend=false\n    - terraform validate\n    - terraform fmt -check\n\nplan:\n  stage: plan\n  image: hashicorp/terraform:${TF_VERSION}\n  script:\n    - terraform init\n    - terraform plan -out=tfplan\n  artifacts:\n    paths:\n      - ${TF_ROOT}/tfplan\n    expire_in: 1 day\n\napply:\n  stage: apply\n  image: hashicorp/terraform:${TF_VERSION}\n  script:\n    - terraform init\n    - terraform apply -auto-approve tfplan\n  dependencies:\n    - plan\n  when: manual\n  only:\n    - main\n```\n\n## Security Scanning\n\n```yaml\ninclude:\n  - template: Security/SAST.gitlab-ci.yml\n  - template: Security/Dependency-Scanning.gitlab-ci.yml\n  - template: Security/Container-Scanning.gitlab-ci.yml\n\ntrivy-scan:\n  stage: test\n  image: aquasec/trivy:latest\n  script:\n    - trivy image --exit-code 1 --severity HIGH,CRITICAL $CI_REGISTRY_IMAGE:$CI_COMMIT_SHA\n  allow_failure: true\n```\n\n## Caching Strategies\n\n```yaml\n# Cache node_modules\nbuild:\n  cache:\n    key: ${CI_COMMIT_REF_SLUG}\n    paths:\n      - node_modules/\n    policy: pull-push\n\n# Global cache\ncache:\n  key: ${CI_COMMIT_REF_SLUG}\n  paths:\n    - .cache/\n    - vendor/\n\n# Separate cache per job\njob1:\n  cache:\n    key: job1-cache\n    paths:\n      - build/\n\njob2:\n  cache:\n    key: job2-cache\n    paths:\n      - dist/\n```\n\n## Dynamic Child Pipelines\n\n```yaml\ngenerate-pipeline:\n  stage: build\n  script:\n    - python generate_pipeline.py > child-pipeline.yml\n  artifacts:\n    paths:\n      - child-pipeline.yml\n\ntrigger-child:\n  stage: deploy\n  trigger:\n    include:\n      - artifact: child-pipeline.yml\n        job: generate-pipeline\n    strategy: depend\n```\n\n## Reference Files\n\n- `assets/gitlab-ci.yml.template` - Complete pipeline template\n- `references/pipeline-stages.md` - Stage organization patterns\n\n## Best Practices\n\n1. **Use specific image tags** (node:20, not node:latest)\n2. **Cache dependencies** appropriately\n3. **Use artifacts** for build outputs\n4. **Implement manual gates** for production\n5. **Use environments** for deployment tracking\n6. **Enable merge request pipelines**\n7. **Use pipeline schedules",
  "tokenEstimate": {
    "tier1": 18.2,
    "tier2": 287.3,
    "tier3": 465.40000000000003
  },
  "fullDefinition": "---\nname: gitlab-ci-patterns\ndescription: Build GitLab CI/CD pipelines with multi-stage workflows, caching, and distributed runners for scalable automation. Use when implementing GitLab CI/CD, optimizing pipeline performance, or setting up automated testing and deployment.\n---\n\n# GitLab CI Patterns\n\nComprehensive GitLab CI/CD pipeline patterns for automated testing, building, and deployment.\n\n## Purpose\n\nCreate efficient GitLab CI pipelines with proper stage organization, caching, and deployment strategies.\n\n## When to Use\n\n- Automate GitLab-based CI/CD\n- Implement multi-stage pipelines\n- Configure GitLab Runners\n- Deploy to Kubernetes from GitLab\n- Implement GitOps workflows\n\n## Basic Pipeline Structure\n\n```yaml\nstages:\n  - build\n  - test\n  - deploy\n\nvariables:\n  DOCKER_DRIVER: overlay2\n  DOCKER_TLS_CERTDIR: \"/certs\"\n\nbuild:\n  stage: build\n  image: node:20\n  script:\n    - npm ci\n    - npm run build\n  artifacts:\n    paths:\n      - dist/\n    expire_in: 1 hour\n  cache:\n    key: ${CI_COMMIT_REF_SLUG}\n    paths:\n      - node_modules/\n\ntest:\n  stage: test\n  image: node:20\n  script:\n    - npm ci\n    - npm run lint\n    - npm test\n  coverage: '/Lines\\s*:\\s*(\\d+\\.\\d+)%/'\n  artifacts:\n    reports:\n      coverage_report:\n        coverage_format: cobertura\n        path: coverage/cobertura-coverage.xml\n\ndeploy:\n  stage: deploy\n  image: bitnami/kubectl:latest\n  script:\n    - kubectl apply -f k8s/\n    - kubectl rollout status deployment/my-app\n  only:\n    - main\n  environment:\n    name: production\n    url: https://app.example.com\n```\n\n## Docker Build and Push\n\n```yaml\nbuild-docker:\n  stage: build\n  image: docker:24\n  services:\n    - docker:24-dind\n  before_script:\n    - docker login -u $CI_REGISTRY_USER -p $CI_REGISTRY_PASSWORD $CI_REGISTRY\n  script:\n    - docker build -t $CI_REGISTRY_IMAGE:$CI_COMMIT_SHA .\n    - docker build -t $CI_REGISTRY_IMAGE:latest .\n    - docker push $CI_REGISTRY_IMAGE:$CI_COMMIT_SHA\n    - docker push $CI_REGISTRY_IMAGE:latest\n  only:\n    - main\n    - tags\n```\n\n## Multi-Environment Deployment\n\n```yaml\n.deploy_template: &deploy_template\n  image: bitnami/kubectl:latest\n  before_script:\n    - kubectl config set-cluster k8s --server=\"$KUBE_URL\" --insecure-skip-tls-verify=true\n    - kubectl config set-credentials admin --token=\"$KUBE_TOKEN\"\n    - kubectl config set-context default --cluster=k8s --user=admin\n    - kubectl config use-context default\n\ndeploy:staging:\n  <<: *deploy_template\n  stage: deploy\n  script:\n    - kubectl apply -f k8s/ -n staging\n    - kubectl rollout status deployment/my-app -n staging\n  environment:\n    name: staging\n    url: https://staging.example.com\n  only:\n    - develop\n\ndeploy:production:\n  <<: *deploy_template\n  stage: deploy\n  script:\n    - kubectl apply -f k8s/ -n production\n    - kubectl rollout status deployment/my-app -n production\n  environment:\n    name: production\n    url: https://app.example.com\n  when: manual\n  only:\n    - main\n```\n\n## Terraform Pipeline\n\n```yaml\nstages:\n  - validate\n  - plan\n  - apply\n\nvariables:\n  TF_ROOT: ${CI_PROJECT_DIR}/terraform\n  TF_VERSION: \"1.6.0\"\n\nbefore_script:\n  - cd ${TF_ROOT}\n  - terraform --version\n\nvalidate:\n  stage: validate\n  image: hashicorp/terraform:${TF_VERSION}\n  script:\n    - terraform init -backend=false\n    - terraform validate\n    - terraform fmt -check\n\nplan:\n  stage: plan\n  image: hashicorp/terraform:${TF_VERSION}\n  script:\n    - terraform init\n    - terraform plan -out=tfplan\n  artifacts:\n    paths:\n      - ${TF_ROOT}/tfplan\n    expire_in: 1 day\n\napply:\n  stage: apply\n  image: hashicorp/terraform:${TF_VERSION}\n  script:\n    - terraform init\n    - terraform apply -auto-approve tfplan\n  dependencies:\n    - plan\n  when: manual\n  only:\n    - main\n```\n\n## Security Scanning\n\n```yaml\ninclude:\n  - template: Security/SAST.gitlab-ci.yml\n  - template: Security/Dependency-Scanning.gitlab-ci.yml\n  - template: Security/Container-Scanning.gitlab-ci.yml\n\ntrivy-scan:\n  stage: test\n  image: aquasec/trivy:latest\n  script:\n    - trivy image --exit-code 1 --severity HIGH,CRITICAL $CI_REGISTRY_IMAGE:$CI_COMMIT_SHA\n  allow_failure: true\n```\n\n## Caching Strategies\n\n```yaml\n# Cache node_modules\nbuild:\n  cache:\n    key: ${CI_COMMIT_REF_SLUG}\n    paths:\n      - node_modules/\n    policy: pull-push\n\n# Global cache\ncache:\n  key: ${CI_COMMIT_REF_SLUG}\n  paths:\n    - .cache/\n    - vendor/\n\n# Separate cache per job\njob1:\n  cache:\n    key: job1-cache\n    paths:\n      - build/\n\njob2:\n  cache:\n    key: job2-cache\n    paths:\n      - dist/\n```\n\n## Dynamic Child Pipelines\n\n```yaml\ngenerate-pipeline:\n  stage: build\n  script:\n    - python generate_pipeline.py > child-pipeline.yml\n  artifacts:\n    paths:\n      - child-pipeline.yml\n\ntrigger-child:\n  stage: deploy\n  trigger:\n    include:\n      - artifact: child-pipeline.yml\n        job: generate-pipeline\n    strategy: depend\n```\n\n## Reference Files\n\n- `assets/gitlab-ci.yml.template` - Complete pipeline template\n- `references/pipeline-stages.md` - Stage organization patterns\n\n## Best Practices\n\n1. **Use specific image tags** (node:20, not node:latest)\n2. **Cache dependencies** appropriately\n3. **Use artifacts** for build outputs\n4. **Implement manual gates** for production\n5. **Use environments** for deployment tracking\n6. **Enable merge request pipelines**\n7. **Use pipeline schedules** for recurring jobs\n8. **Implement security scanning**\n9. **Use CI/CD variables** for secrets\n10. **Monitor pipeline performance**\n\n## Related Skills\n\n- `github-actions-templates` - For GitHub Actions\n- `deployment-pipeline-design` - For architecture\n- `secrets-management` - For secrets handling\n"
}