{
  "id": "kubernetes_operations_k8s_manifest_generator",
  "name": "k8s-manifest-generator",
  "source": "kubernetes-operations",
  "originalPath": "plugins/kubernetes-operations/skills/k8s-manifest-generator/SKILL.md",
  "activationCriteria": "Create production-ready Kubernetes manifests for Deployments, Services, ConfigMaps, and Secrets following best practices and security standards. Use when generating Kubernetes YAML manifests, creating",
  "tier1_metadata": "k8s-manifest-generator: Create production-ready Kubernetes manifests for Deployments, Services, ConfigMaps, and Secrets foll",
  "tier2_instructions": "# Kubernetes Manifest Generator\n\nStep-by-step guidance for creating production-ready Kubernetes manifests including Deployments, Services, ConfigMaps, Secrets, and PersistentVolumeClaims.\n\n## Purpose\n\nThis skill provides comprehensive guidance for generating well-structured, secure, and production-ready Kubernetes manifests following cloud-native best practices and Kubernetes conventions.\n\n## When to Use This Skill\n\nUse this skill when you need to:\n- Create new Kubernetes Deployment manifests\n- Define Service resources for network connectivity\n- Generate ConfigMap and Secret resources for configuration management\n- Create PersistentVolumeClaim manifests for stateful workloads\n- Follow Kubernetes best practices and naming conventions\n- Implement resource limits, health checks, and security contexts\n- Design manifests for multi-environment deployments\n\n## Step-by-Step Workflow\n\n### 1. Gather Requirements\n\n**Understand the workload:**\n- Application type (stateless/stateful)\n- Container image and version\n- Environment variables and configuration needs\n- Storage requirements\n- Network exposure requirements (internal/external)\n- Resource requirements (CPU, memory)\n- Scaling requirements\n- Health check endpoints\n\n**Questions to ask:**\n- What is the application name and purpose?\n- What container image and tag will be used?\n- Does the application need persistent storage?\n- What ports does the application expose?\n- Are there any secrets or configuration files needed?\n- What are the CPU and memory requirements?\n- Does the application need to be exposed externally?\n\n### 2. Create Deployment Manifest\n\n**Follow this structure:**\n\n```yaml\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: <app-name>\n  namespace: <namespace>\n  labels:\n    app: <app-name>\n    version: <version>\nspec:\n  replicas: 3\n  selector:\n    matchLabels:\n      app: <app-name>\n  template:\n    metadata:\n      labels:\n        app: <app-name>\n        version: <version>\n    spec:\n      containers:\n      - name: ",
  "tier3_resources": "<container-name>\n        image: <image>:<tag>\n        ports:\n        - containerPort: <port>\n          name: http\n        resources:\n          requests:\n            memory: \"256Mi\"\n            cpu: \"250m\"\n          limits:\n            memory: \"512Mi\"\n            cpu: \"500m\"\n        livenessProbe:\n          httpGet:\n            path: /health\n            port: http\n          initialDelaySeconds: 30\n          periodSeconds: 10\n        readinessProbe:\n          httpGet:\n            path: /ready\n            port: http\n          initialDelaySeconds: 5\n          periodSeconds: 5\n        env:\n        - name: ENV_VAR\n          value: \"value\"\n        envFrom:\n        - configMapRef:\n            name: <app-name>-config\n        - secretRef:\n            name: <app-name>-secret\n```\n\n**Best practices to apply:**\n- Always set resource requests and limits\n- Implement both liveness and readiness probes\n- Use specific image tags (never `:latest`)\n- Apply security context for non-root users\n- Use labels for organization and selection\n- Set appropriate replica count based on availability needs\n\n**Reference:** See `references/deployment-spec.md` for detailed deployment options\n\n### 3. Create Service Manifest\n\n**Choose the appropriate Service type:**\n\n**ClusterIP (internal only):**\n```yaml\napiVersion: v1\nkind: Service\nmetadata:\n  name: <app-name>\n  namespace: <namespace>\n  labels:\n    app: <app-name>\nspec:\n  type: ClusterIP\n  selector:\n    app: <app-name>\n  ports:\n  - name: http\n    port: 80\n    targetPort: 8080\n    protocol: TCP\n```\n\n**LoadBalancer (external access):**\n```yaml\napiVersion: v1\nkind: Service\nmetadata:\n  name: <app-name>\n  namespace: <namespace>\n  labels:\n    app: <app-name>\n  annotations:\n    service.beta.kubernetes.io/aws-load-balancer-type: nlb\nspec:\n  type: LoadBalancer\n  selector:\n    app: <app-name>\n  ports:\n  - name: http\n    port: 80\n    targetPort: 8080\n    protocol: TCP\n```\n\n**Reference:** See `references/service-spec.md` for service types and networking\n\n### 4. Create ConfigMap\n\n**For application configuration:**\n\n```yaml\napiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: <app-name>-config\n  namespace: <namespace>\ndata:\n  APP_MODE: production\n  LOG_LEVEL: info\n  DATABASE_HOST: db.example.com\n  # For config files\n  app.properties: |\n    server.port=8080\n    server.host=0.0.0.0\n    logging.level=INFO\n```\n\n**Best practices:**\n- Use ConfigMaps for non-sensitive data only\n- Organize related configuration together\n- Use meaningful names for keys\n- Consider using one ConfigMap per component\n- Version ConfigMaps when making changes\n\n**Reference:** See `assets/configmap-template.yaml` for examples\n\n### 5. Create Secret\n\n**For sensitive data:**\n\n```yaml\napiVersion: v1\nkind: Secret\nmetadata:\n  name: <app-name>-secret\n  namespace: <namespace>\ntype: Opaque\nstringData:\n  DATABASE_PASSWORD: \"changeme\"\n  API_KEY: \"secret-api-key\"\n  # For certificate files\n  tls.crt: |\n    -----BEGIN CERTIFICATE-----\n    ...\n    -----END CERTIFICATE-----\n  tls.key: |\n    -----BEG",
  "tokenEstimate": {
    "tier1": 15.600000000000001,
    "tier2": 326.3,
    "tier3": 1558.7
  },
  "fullDefinition": "---\nname: k8s-manifest-generator\ndescription: Create production-ready Kubernetes manifests for Deployments, Services, ConfigMaps, and Secrets following best practices and security standards. Use when generating Kubernetes YAML manifests, creating K8s resources, or implementing production-grade Kubernetes configurations.\n---\n\n# Kubernetes Manifest Generator\n\nStep-by-step guidance for creating production-ready Kubernetes manifests including Deployments, Services, ConfigMaps, Secrets, and PersistentVolumeClaims.\n\n## Purpose\n\nThis skill provides comprehensive guidance for generating well-structured, secure, and production-ready Kubernetes manifests following cloud-native best practices and Kubernetes conventions.\n\n## When to Use This Skill\n\nUse this skill when you need to:\n- Create new Kubernetes Deployment manifests\n- Define Service resources for network connectivity\n- Generate ConfigMap and Secret resources for configuration management\n- Create PersistentVolumeClaim manifests for stateful workloads\n- Follow Kubernetes best practices and naming conventions\n- Implement resource limits, health checks, and security contexts\n- Design manifests for multi-environment deployments\n\n## Step-by-Step Workflow\n\n### 1. Gather Requirements\n\n**Understand the workload:**\n- Application type (stateless/stateful)\n- Container image and version\n- Environment variables and configuration needs\n- Storage requirements\n- Network exposure requirements (internal/external)\n- Resource requirements (CPU, memory)\n- Scaling requirements\n- Health check endpoints\n\n**Questions to ask:**\n- What is the application name and purpose?\n- What container image and tag will be used?\n- Does the application need persistent storage?\n- What ports does the application expose?\n- Are there any secrets or configuration files needed?\n- What are the CPU and memory requirements?\n- Does the application need to be exposed externally?\n\n### 2. Create Deployment Manifest\n\n**Follow this structure:**\n\n```yaml\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: <app-name>\n  namespace: <namespace>\n  labels:\n    app: <app-name>\n    version: <version>\nspec:\n  replicas: 3\n  selector:\n    matchLabels:\n      app: <app-name>\n  template:\n    metadata:\n      labels:\n        app: <app-name>\n        version: <version>\n    spec:\n      containers:\n      - name: <container-name>\n        image: <image>:<tag>\n        ports:\n        - containerPort: <port>\n          name: http\n        resources:\n          requests:\n            memory: \"256Mi\"\n            cpu: \"250m\"\n          limits:\n            memory: \"512Mi\"\n            cpu: \"500m\"\n        livenessProbe:\n          httpGet:\n            path: /health\n            port: http\n          initialDelaySeconds: 30\n          periodSeconds: 10\n        readinessProbe:\n          httpGet:\n            path: /ready\n            port: http\n          initialDelaySeconds: 5\n          periodSeconds: 5\n        env:\n        - name: ENV_VAR\n          value: \"value\"\n        envFrom:\n        - configMapRef:\n            name: <app-name>-config\n        - secretRef:\n            name: <app-name>-secret\n```\n\n**Best practices to apply:**\n- Always set resource requests and limits\n- Implement both liveness and readiness probes\n- Use specific image tags (never `:latest`)\n- Apply security context for non-root users\n- Use labels for organization and selection\n- Set appropriate replica count based on availability needs\n\n**Reference:** See `references/deployment-spec.md` for detailed deployment options\n\n### 3. Create Service Manifest\n\n**Choose the appropriate Service type:**\n\n**ClusterIP (internal only):**\n```yaml\napiVersion: v1\nkind: Service\nmetadata:\n  name: <app-name>\n  namespace: <namespace>\n  labels:\n    app: <app-name>\nspec:\n  type: ClusterIP\n  selector:\n    app: <app-name>\n  ports:\n  - name: http\n    port: 80\n    targetPort: 8080\n    protocol: TCP\n```\n\n**LoadBalancer (external access):**\n```yaml\napiVersion: v1\nkind: Service\nmetadata:\n  name: <app-name>\n  namespace: <namespace>\n  labels:\n    app: <app-name>\n  annotations:\n    service.beta.kubernetes.io/aws-load-balancer-type: nlb\nspec:\n  type: LoadBalancer\n  selector:\n    app: <app-name>\n  ports:\n  - name: http\n    port: 80\n    targetPort: 8080\n    protocol: TCP\n```\n\n**Reference:** See `references/service-spec.md` for service types and networking\n\n### 4. Create ConfigMap\n\n**For application configuration:**\n\n```yaml\napiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: <app-name>-config\n  namespace: <namespace>\ndata:\n  APP_MODE: production\n  LOG_LEVEL: info\n  DATABASE_HOST: db.example.com\n  # For config files\n  app.properties: |\n    server.port=8080\n    server.host=0.0.0.0\n    logging.level=INFO\n```\n\n**Best practices:**\n- Use ConfigMaps for non-sensitive data only\n- Organize related configuration together\n- Use meaningful names for keys\n- Consider using one ConfigMap per component\n- Version ConfigMaps when making changes\n\n**Reference:** See `assets/configmap-template.yaml` for examples\n\n### 5. Create Secret\n\n**For sensitive data:**\n\n```yaml\napiVersion: v1\nkind: Secret\nmetadata:\n  name: <app-name>-secret\n  namespace: <namespace>\ntype: Opaque\nstringData:\n  DATABASE_PASSWORD: \"changeme\"\n  API_KEY: \"secret-api-key\"\n  # For certificate files\n  tls.crt: |\n    -----BEGIN CERTIFICATE-----\n    ...\n    -----END CERTIFICATE-----\n  tls.key: |\n    -----BEGIN PRIVATE KEY-----\n    ...\n    -----END PRIVATE KEY-----\n```\n\n**Security considerations:**\n- Never commit secrets to Git in plain text\n- Use Sealed Secrets, External Secrets Operator, or Vault\n- Rotate secrets regularly\n- Use RBAC to limit secret access\n- Consider using Secret type: `kubernetes.io/tls` for TLS secrets\n\n### 6. Create PersistentVolumeClaim (if needed)\n\n**For stateful applications:**\n\n```yaml\napiVersion: v1\nkind: PersistentVolumeClaim\nmetadata:\n  name: <app-name>-data\n  namespace: <namespace>\nspec:\n  accessModes:\n  - ReadWriteOnce\n  storageClassName: gp3\n  resources:\n    requests:\n      storage: 10Gi\n```\n\n**Mount in Deployment:**\n```yaml\nspec:\n  template:\n    spec:\n      containers:\n      - name: app\n        volumeMounts:\n        - name: data\n          mountPath: /var/lib/app\n      volumes:\n      - name: data\n        persistentVolumeClaim:\n          claimName: <app-name>-data\n```\n\n**Storage considerations:**\n- Choose appropriate StorageClass for performance needs\n- Use ReadWriteOnce for single-pod access\n- Use ReadWriteMany for multi-pod shared storage\n- Consider backup strategies\n- Set appropriate retention policies\n\n### 7. Apply Security Best Practices\n\n**Add security context to Deployment:**\n\n```yaml\nspec:\n  template:\n    spec:\n      securityContext:\n        runAsNonRoot: true\n        runAsUser: 1000\n        fsGroup: 1000\n        seccompProfile:\n          type: RuntimeDefault\n      containers:\n      - name: app\n        securityContext:\n          allowPrivilegeEscalation: false\n          readOnlyRootFilesystem: true\n          capabilities:\n            drop:\n            - ALL\n```\n\n**Security checklist:**\n- [ ] Run as non-root user\n- [ ] Drop all capabilities\n- [ ] Use read-only root filesystem\n- [ ] Disable privilege escalation\n- [ ] Set seccomp profile\n- [ ] Use Pod Security Standards\n\n### 8. Add Labels and Annotations\n\n**Standard labels (recommended):**\n\n```yaml\nmetadata:\n  labels:\n    app.kubernetes.io/name: <app-name>\n    app.kubernetes.io/instance: <instance-name>\n    app.kubernetes.io/version: \"1.0.0\"\n    app.kubernetes.io/component: backend\n    app.kubernetes.io/part-of: <system-name>\n    app.kubernetes.io/managed-by: kubectl\n```\n\n**Useful annotations:**\n\n```yaml\nmetadata:\n  annotations:\n    description: \"Application description\"\n    contact: \"team@example.com\"\n    prometheus.io/scrape: \"true\"\n    prometheus.io/port: \"9090\"\n    prometheus.io/path: \"/metrics\"\n```\n\n### 9. Organize Multi-Resource Manifests\n\n**File organization options:**\n\n**Option 1: Single file with `---` separator**\n```yaml\n# app-name.yaml\n---\napiVersion: v1\nkind: ConfigMap\n...\n---\napiVersion: v1\nkind: Secret\n...\n---\napiVersion: apps/v1\nkind: Deployment\n...\n---\napiVersion: v1\nkind: Service\n...\n```\n\n**Option 2: Separate files**\n```\nmanifests/\n\u251c\u2500\u2500 configmap.yaml\n\u251c\u2500\u2500 secret.yaml\n\u251c\u2500\u2500 deployment.yaml\n\u251c\u2500\u2500 service.yaml\n\u2514\u2500\u2500 pvc.yaml\n```\n\n**Option 3: Kustomize structure**\n```\nbase/\n\u251c\u2500\u2500 kustomization.yaml\n\u251c\u2500\u2500 deployment.yaml\n\u251c\u2500\u2500 service.yaml\n\u2514\u2500\u2500 configmap.yaml\noverlays/\n\u251c\u2500\u2500 dev/\n\u2502   \u2514\u2500\u2500 kustomization.yaml\n\u2514\u2500\u2500 prod/\n    \u2514\u2500\u2500 kustomization.yaml\n```\n\n### 10. Validate and Test\n\n**Validation steps:**\n\n```bash\n# Dry-run validation\nkubectl apply -f manifest.yaml --dry-run=client\n\n# Server-side validation\nkubectl apply -f manifest.yaml --dry-run=server\n\n# Validate with kubeval\nkubeval manifest.yaml\n\n# Validate with kube-score\nkube-score score manifest.yaml\n\n# Check with kube-linter\nkube-linter lint manifest.yaml\n```\n\n**Testing checklist:**\n- [ ] Manifest passes dry-run validation\n- [ ] All required fields are present\n- [ ] Resource limits are reasonable\n- [ ] Health checks are configured\n- [ ] Security context is set\n- [ ] Labels follow conventions\n- [ ] Namespace exists or is created\n\n## Common Patterns\n\n### Pattern 1: Simple Stateless Web Application\n\n**Use case:** Standard web API or microservice\n\n**Components needed:**\n- Deployment (3 replicas for HA)\n- ClusterIP Service\n- ConfigMap for configuration\n- Secret for API keys\n- HorizontalPodAutoscaler (optional)\n\n**Reference:** See `assets/deployment-template.yaml`\n\n### Pattern 2: Stateful Database Application\n\n**Use case:** Database or persistent storage application\n\n**Components needed:**\n- StatefulSet (not Deployment)\n- Headless Service\n- PersistentVolumeClaim template\n- ConfigMap for DB configuration\n- Secret for credentials\n\n### Pattern 3: Background Job or Cron\n\n**Use case:** Scheduled tasks or batch processing\n\n**Components needed:**\n- CronJob or Job\n- ConfigMap for job parameters\n- Secret for credentials\n- ServiceAccount with RBAC\n\n### Pattern 4: Multi-Container Pod\n\n**Use case:** Application with sidecar containers\n\n**Components needed:**\n- Deployment with multiple containers\n- Shared volumes between containers\n- Init containers for setup\n- Service (if needed)\n\n## Templates\n\nThe following templates are available in the `assets/` directory:\n\n- `deployment-template.yaml` - Standard deployment with best practices\n- `service-template.yaml` - Service configurations (ClusterIP, LoadBalancer, NodePort)\n- `configmap-template.yaml` - ConfigMap examples with different data types\n- `secret-template.yaml` - Secret examples (to be generated, not committed)\n- `pvc-template.yaml` - PersistentVolumeClaim templates\n\n## Reference Documentation\n\n- `references/deployment-spec.md` - Detailed Deployment specification\n- `references/service-spec.md` - Service types and networking details\n\n## Best Practices Summary\n\n1. **Always set resource requests and limits** - Prevents resource starvation\n2. **Implement health checks** - Ensures Kubernetes can manage your application\n3. **Use specific image tags** - Avoid unpredictable deployments\n4. **Apply security contexts** - Run as non-root, drop capabilities\n5. **Use ConfigMaps and Secrets** - Separate config from code\n6. **Label everything** - Enables filtering and organization\n7. **Follow naming conventions** - Use standard Kubernetes labels\n8. **Validate before applying** - Use dry-run and validation tools\n9. **Version your manifests** - Keep in Git with version control\n10. **Document with annotations** - Add context for other developers\n\n## Troubleshooting\n\n**Pods not starting:**\n- Check image pull errors: `kubectl describe pod <pod-name>`\n- Verify resource availability: `kubectl get nodes`\n- Check events: `kubectl get events --sort-by='.lastTimestamp'`\n\n**Service not accessible:**\n- Verify selector matches pod labels: `kubectl get endpoints <service-name>`\n- Check service type and port configuration\n- Test from within cluster: `kubectl run debug --rm -it --image=busybox -- sh`\n\n**ConfigMap/Secret not loading:**\n- Verify names match in Deployment\n- Check namespace\n- Ensure resources exist: `kubectl get configmap,secret`\n\n## Next Steps\n\nAfter creating manifests:\n1. Store in Git repository\n2. Set up CI/CD pipeline for deployment\n3. Consider using Helm or Kustomize for templating\n4. Implement GitOps with ArgoCD or Flux\n5. Add monitoring and observability\n\n## Related Skills\n\n- `helm-chart-scaffolding` - For templating and packaging\n- `gitops-workflow` - For automated deployments\n- `k8s-security-policies` - For advanced security configurations\n"
}