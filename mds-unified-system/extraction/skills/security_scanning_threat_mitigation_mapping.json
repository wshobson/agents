{
  "id": "security_scanning_threat_mitigation_mapping",
  "name": "threat-mitigation-mapping",
  "source": "security-scanning",
  "originalPath": "plugins/security-scanning/skills/threat-mitigation-mapping/SKILL.md",
  "activationCriteria": "Map identified threats to appropriate security controls and mitigations. Use when prioritizing security investments, creating remediation plans, or validating control effectiveness.",
  "tier1_metadata": "threat-mitigation-mapping: Map identified threats to appropriate security controls and mitigations. Use when prioritizing secur",
  "tier2_instructions": "# Threat Mitigation Mapping\n\nConnect threats to controls for effective security planning.\n\n## When to Use This Skill\n\n- Prioritizing security investments\n- Creating remediation roadmaps\n- Validating control coverage\n- Designing defense-in-depth\n- Security architecture review\n- Risk treatment planning\n\n## Core Concepts\n\n### 1. Control Categories\n\n```\nPreventive \u2500\u2500\u2500\u2500\u25ba Stop attacks before they occur\n   \u2502              (Firewall, Input validation)\n   \u2502\nDetective \u2500\u2500\u2500\u2500\u2500\u25ba Identify attacks in progress\n   \u2502              (IDS, Log monitoring)\n   \u2502\nCorrective \u2500\u2500\u2500\u2500\u25ba Respond and recover from attacks\n                  (Incident response, Backup restore)\n```\n\n### 2. Control Layers\n\n| Layer | Examples |\n|-------|----------|\n| **Network** | Firewall, WAF, DDoS protection |\n| **Application** | Input validation, authentication |\n| **Data** | Encryption, access controls |\n| **Endpoint** | EDR, patch management |\n| **Process** | Security training, incident response |\n\n### 3. Defense in Depth\n\n```\n                    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                    \u2502      Perimeter       \u2502 \u2190 Firewall, WAF\n                    \u2502   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u2502\n                    \u2502   \u2502   Network    \u2502   \u2502 \u2190 Segmentation, IDS\n                    \u2502   \u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502   \u2502\n                    \u2502   \u2502  \u2502  Host  \u2502  \u2502   \u2502 \u2190 EDR, Hardening\n                    \u2502   \u2502  \u2502 \u250c\u2500\u2500\u2500\u2500\u2510 \u2502  \u2502   \u2502\n                    \u2502   \u2502  \u2502 \u2502App \u2502 \u2502  \u2502   \u2502 \u2190 Auth, Validation\n                    \u2502   \u2502  \u2502 \u2502Data\u2502 \u2502  \u2502   \u2502 \u2190 Encryption\n                    \u2502   \u2502  \u2502 \u2514\u2500\u2500\u2500\u2500\u2518 \u2502  \u2502   \u2502\n                    \u2502   \u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2502   \u2502\n                    \u2502   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518   \u2502\n                    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n```\n\n## Templates\n\n### Template 1: Mitigation Model\n\n```python\nfrom dataclasses import dataclass, field\nfrom enum import Enum\nfrom typing import List, Dict, Optional, Set\nfrom datetime import datetime\n\nclass ControlType(Enum):\n    PREVENTIVE = \"preventive\"\n    DETECTIVE = \"detective\"\n    CORRECTIVE = \"corrective\"\n\n\nclass ControlLayer(Enum",
  "tier3_resources": "):\n    NETWORK = \"network\"\n    APPLICATION = \"application\"\n    DATA = \"data\"\n    ENDPOINT = \"endpoint\"\n    PROCESS = \"process\"\n    PHYSICAL = \"physical\"\n\n\nclass ImplementationStatus(Enum):\n    NOT_IMPLEMENTED = \"not_implemented\"\n    PARTIAL = \"partial\"\n    IMPLEMENTED = \"implemented\"\n    VERIFIED = \"verified\"\n\n\nclass Effectiveness(Enum):\n    NONE = 0\n    LOW = 1\n    MEDIUM = 2\n    HIGH = 3\n    VERY_HIGH = 4\n\n\n@dataclass\nclass SecurityControl:\n    id: str\n    name: str\n    description: str\n    control_type: ControlType\n    layer: ControlLayer\n    effectiveness: Effectiveness\n    implementation_cost: str  # Low, Medium, High\n    maintenance_cost: str\n    status: ImplementationStatus = ImplementationStatus.NOT_IMPLEMENTED\n    mitigates_threats: List[str] = field(default_factory=list)\n    dependencies: List[str] = field(default_factory=list)\n    technologies: List[str] = field(default_factory=list)\n    compliance_refs: List[str] = field(default_factory=list)\n\n    def coverage_score(self) -> float:\n        \"\"\"Calculate coverage score based on status and effectiveness.\"\"\"\n        status_multiplier = {\n            ImplementationStatus.NOT_IMPLEMENTED: 0.0,\n            ImplementationStatus.PARTIAL: 0.5,\n            ImplementationStatus.IMPLEMENTED: 0.8,\n            ImplementationStatus.VERIFIED: 1.0,\n        }\n        return self.effectiveness.value * status_multiplier[self.status]\n\n\n@dataclass\nclass Threat:\n    id: str\n    name: str\n    category: str  # STRIDE category\n    description: str\n    impact: str  # Critical, High, Medium, Low\n    likelihood: str\n    risk_score: float\n\n\n@dataclass\nclass MitigationMapping:\n    threat: Threat\n    controls: List[SecurityControl]\n    residual_risk: str = \"Unknown\"\n    notes: str = \"\"\n\n    def calculate_coverage(self) -> float:\n        \"\"\"Calculate how well controls cover the threat.\"\"\"\n        if not self.controls:\n            return 0.0\n\n        total_score = sum(c.coverage_score() for c in self.controls)\n        max_possible = len(self.controls) * Effectiveness.VERY_HIGH.value\n\n        return (total_score / max_possible) * 100 if max_possible > 0 else 0\n\n    def has_defense_in_depth(self) -> bool:\n        \"\"\"Check if multiple layers are covered.\"\"\"\n        layers = set(c.layer for c in self.controls if c.status != ImplementationStatus.NOT_IMPLEMENTED)\n        return len(layers) >= 2\n\n    def has_control_diversity(self) -> bool:\n        \"\"\"Check if multiple control types are present.\"\"\"\n        types = set(c.control_type for c in self.controls if c.status != ImplementationStatus.NOT_IMPLEMENTED)\n        return len(types) >= 2\n\n\n@dataclass\nclass MitigationPlan:\n    name: str\n    threats: List[Threat] = field(default_factory=list)\n    controls: List[SecurityControl] = field(default_factory=list)\n    mappings: List[MitigationMapping] = field(default_factory=list)\n\n    def get_unmapped_threats(self) -> List[Threat]:\n        \"\"\"Find threats without mitigations.\"\"\"\n        mapped_ids = {m.threat.id for m in self.mapping",
  "tokenEstimate": {
    "tier1": 18.2,
    "tier2": 331.5,
    "tier3": 2416.7000000000003
  },
  "fullDefinition": "---\nname: threat-mitigation-mapping\ndescription: Map identified threats to appropriate security controls and mitigations. Use when prioritizing security investments, creating remediation plans, or validating control effectiveness.\n---\n\n# Threat Mitigation Mapping\n\nConnect threats to controls for effective security planning.\n\n## When to Use This Skill\n\n- Prioritizing security investments\n- Creating remediation roadmaps\n- Validating control coverage\n- Designing defense-in-depth\n- Security architecture review\n- Risk treatment planning\n\n## Core Concepts\n\n### 1. Control Categories\n\n```\nPreventive \u2500\u2500\u2500\u2500\u25ba Stop attacks before they occur\n   \u2502              (Firewall, Input validation)\n   \u2502\nDetective \u2500\u2500\u2500\u2500\u2500\u25ba Identify attacks in progress\n   \u2502              (IDS, Log monitoring)\n   \u2502\nCorrective \u2500\u2500\u2500\u2500\u25ba Respond and recover from attacks\n                  (Incident response, Backup restore)\n```\n\n### 2. Control Layers\n\n| Layer | Examples |\n|-------|----------|\n| **Network** | Firewall, WAF, DDoS protection |\n| **Application** | Input validation, authentication |\n| **Data** | Encryption, access controls |\n| **Endpoint** | EDR, patch management |\n| **Process** | Security training, incident response |\n\n### 3. Defense in Depth\n\n```\n                    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                    \u2502      Perimeter       \u2502 \u2190 Firewall, WAF\n                    \u2502   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u2502\n                    \u2502   \u2502   Network    \u2502   \u2502 \u2190 Segmentation, IDS\n                    \u2502   \u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502   \u2502\n                    \u2502   \u2502  \u2502  Host  \u2502  \u2502   \u2502 \u2190 EDR, Hardening\n                    \u2502   \u2502  \u2502 \u250c\u2500\u2500\u2500\u2500\u2510 \u2502  \u2502   \u2502\n                    \u2502   \u2502  \u2502 \u2502App \u2502 \u2502  \u2502   \u2502 \u2190 Auth, Validation\n                    \u2502   \u2502  \u2502 \u2502Data\u2502 \u2502  \u2502   \u2502 \u2190 Encryption\n                    \u2502   \u2502  \u2502 \u2514\u2500\u2500\u2500\u2500\u2518 \u2502  \u2502   \u2502\n                    \u2502   \u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2502   \u2502\n                    \u2502   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518   \u2502\n                    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n```\n\n## Templates\n\n### Template 1: Mitigation Model\n\n```python\nfrom dataclasses import dataclass, field\nfrom enum import Enum\nfrom typing import List, Dict, Optional, Set\nfrom datetime import datetime\n\nclass ControlType(Enum):\n    PREVENTIVE = \"preventive\"\n    DETECTIVE = \"detective\"\n    CORRECTIVE = \"corrective\"\n\n\nclass ControlLayer(Enum):\n    NETWORK = \"network\"\n    APPLICATION = \"application\"\n    DATA = \"data\"\n    ENDPOINT = \"endpoint\"\n    PROCESS = \"process\"\n    PHYSICAL = \"physical\"\n\n\nclass ImplementationStatus(Enum):\n    NOT_IMPLEMENTED = \"not_implemented\"\n    PARTIAL = \"partial\"\n    IMPLEMENTED = \"implemented\"\n    VERIFIED = \"verified\"\n\n\nclass Effectiveness(Enum):\n    NONE = 0\n    LOW = 1\n    MEDIUM = 2\n    HIGH = 3\n    VERY_HIGH = 4\n\n\n@dataclass\nclass SecurityControl:\n    id: str\n    name: str\n    description: str\n    control_type: ControlType\n    layer: ControlLayer\n    effectiveness: Effectiveness\n    implementation_cost: str  # Low, Medium, High\n    maintenance_cost: str\n    status: ImplementationStatus = ImplementationStatus.NOT_IMPLEMENTED\n    mitigates_threats: List[str] = field(default_factory=list)\n    dependencies: List[str] = field(default_factory=list)\n    technologies: List[str] = field(default_factory=list)\n    compliance_refs: List[str] = field(default_factory=list)\n\n    def coverage_score(self) -> float:\n        \"\"\"Calculate coverage score based on status and effectiveness.\"\"\"\n        status_multiplier = {\n            ImplementationStatus.NOT_IMPLEMENTED: 0.0,\n            ImplementationStatus.PARTIAL: 0.5,\n            ImplementationStatus.IMPLEMENTED: 0.8,\n            ImplementationStatus.VERIFIED: 1.0,\n        }\n        return self.effectiveness.value * status_multiplier[self.status]\n\n\n@dataclass\nclass Threat:\n    id: str\n    name: str\n    category: str  # STRIDE category\n    description: str\n    impact: str  # Critical, High, Medium, Low\n    likelihood: str\n    risk_score: float\n\n\n@dataclass\nclass MitigationMapping:\n    threat: Threat\n    controls: List[SecurityControl]\n    residual_risk: str = \"Unknown\"\n    notes: str = \"\"\n\n    def calculate_coverage(self) -> float:\n        \"\"\"Calculate how well controls cover the threat.\"\"\"\n        if not self.controls:\n            return 0.0\n\n        total_score = sum(c.coverage_score() for c in self.controls)\n        max_possible = len(self.controls) * Effectiveness.VERY_HIGH.value\n\n        return (total_score / max_possible) * 100 if max_possible > 0 else 0\n\n    def has_defense_in_depth(self) -> bool:\n        \"\"\"Check if multiple layers are covered.\"\"\"\n        layers = set(c.layer for c in self.controls if c.status != ImplementationStatus.NOT_IMPLEMENTED)\n        return len(layers) >= 2\n\n    def has_control_diversity(self) -> bool:\n        \"\"\"Check if multiple control types are present.\"\"\"\n        types = set(c.control_type for c in self.controls if c.status != ImplementationStatus.NOT_IMPLEMENTED)\n        return len(types) >= 2\n\n\n@dataclass\nclass MitigationPlan:\n    name: str\n    threats: List[Threat] = field(default_factory=list)\n    controls: List[SecurityControl] = field(default_factory=list)\n    mappings: List[MitigationMapping] = field(default_factory=list)\n\n    def get_unmapped_threats(self) -> List[Threat]:\n        \"\"\"Find threats without mitigations.\"\"\"\n        mapped_ids = {m.threat.id for m in self.mappings}\n        return [t for t in self.threats if t.id not in mapped_ids]\n\n    def get_control_coverage(self) -> Dict[str, float]:\n        \"\"\"Get coverage percentage for each threat.\"\"\"\n        return {\n            m.threat.id: m.calculate_coverage()\n            for m in self.mappings\n        }\n\n    def get_gaps(self) -> List[Dict]:\n        \"\"\"Identify mitigation gaps.\"\"\"\n        gaps = []\n        for mapping in self.mappings:\n            coverage = mapping.calculate_coverage()\n            if coverage < 50:\n                gaps.append({\n                    \"threat\": mapping.threat.id,\n                    \"threat_name\": mapping.threat.name,\n                    \"coverage\": coverage,\n                    \"issue\": \"Insufficient control coverage\",\n                    \"recommendation\": \"Add more controls or improve existing ones\"\n                })\n            if not mapping.has_defense_in_depth():\n                gaps.append({\n                    \"threat\": mapping.threat.id,\n                    \"threat_name\": mapping.threat.name,\n                    \"coverage\": coverage,\n                    \"issue\": \"No defense in depth\",\n                    \"recommendation\": \"Add controls at different layers\"\n                })\n            if not mapping.has_control_diversity():\n                gaps.append({\n                    \"threat\": mapping.threat.id,\n                    \"threat_name\": mapping.threat.name,\n                    \"coverage\": coverage,\n                    \"issue\": \"No control diversity\",\n                    \"recommendation\": \"Add detective/corrective controls\"\n                })\n        return gaps\n```\n\n### Template 2: Control Library\n\n```python\nclass ControlLibrary:\n    \"\"\"Library of standard security controls.\"\"\"\n\n    STANDARD_CONTROLS = {\n        # Authentication Controls\n        \"AUTH-001\": SecurityControl(\n            id=\"AUTH-001\",\n            name=\"Multi-Factor Authentication\",\n            description=\"Require MFA for all user authentication\",\n            control_type=ControlType.PREVENTIVE,\n            layer=ControlLayer.APPLICATION,\n            effectiveness=Effectiveness.HIGH,\n            implementation_cost=\"Medium\",\n            maintenance_cost=\"Low\",\n            mitigates_threats=[\"SPOOFING\"],\n            technologies=[\"TOTP\", \"WebAuthn\", \"SMS OTP\"],\n            compliance_refs=[\"PCI-DSS 8.3\", \"NIST 800-63B\"]\n        ),\n        \"AUTH-002\": SecurityControl(\n            id=\"AUTH-002\",\n            name=\"Account Lockout Policy\",\n            description=\"Lock accounts after failed authentication attempts\",\n            control_type=ControlType.PREVENTIVE,\n            layer=ControlLayer.APPLICATION,\n            effectiveness=Effectiveness.MEDIUM,\n            implementation_cost=\"Low\",\n            maintenance_cost=\"Low\",\n            mitigates_threats=[\"SPOOFING\"],\n            technologies=[\"Custom implementation\"],\n            compliance_refs=[\"PCI-DSS 8.1.6\"]\n        ),\n\n        # Input Validation Controls\n        \"VAL-001\": SecurityControl(\n            id=\"VAL-001\",\n            name=\"Input Validation Framework\",\n            description=\"Validate and sanitize all user input\",\n            control_type=ControlType.PREVENTIVE,\n            layer=ControlLayer.APPLICATION,\n            effectiveness=Effectiveness.HIGH,\n            implementation_cost=\"Medium\",\n            maintenance_cost=\"Medium\",\n            mitigates_threats=[\"TAMPERING\", \"INJECTION\"],\n            technologies=[\"Joi\", \"Yup\", \"Pydantic\"],\n            compliance_refs=[\"OWASP ASVS V5\"]\n        ),\n        \"VAL-002\": SecurityControl(\n            id=\"VAL-002\",\n            name=\"Web Application Firewall\",\n            description=\"Deploy WAF to filter malicious requests\",\n            control_type=ControlType.PREVENTIVE,\n            layer=ControlLayer.NETWORK,\n            effectiveness=Effectiveness.MEDIUM,\n            implementation_cost=\"Medium\",\n            maintenance_cost=\"Medium\",\n            mitigates_threats=[\"TAMPERING\", \"INJECTION\", \"DOS\"],\n            technologies=[\"AWS WAF\", \"Cloudflare\", \"ModSecurity\"],\n            compliance_refs=[\"PCI-DSS 6.6\"]\n        ),\n\n        # Encryption Controls\n        \"ENC-001\": SecurityControl(\n            id=\"ENC-001\",\n            name=\"Data Encryption at Rest\",\n            description=\"Encrypt sensitive data in storage\",\n            control_type=ControlType.PREVENTIVE,\n            layer=ControlLayer.DATA,\n            effectiveness=Effectiveness.HIGH,\n            implementation_cost=\"Medium\",\n            maintenance_cost=\"Low\",\n            mitigates_threats=[\"INFORMATION_DISCLOSURE\"],\n            technologies=[\"AES-256\", \"KMS\", \"HSM\"],\n            compliance_refs=[\"PCI-DSS 3.4\", \"GDPR Art. 32\"]\n        ),\n        \"ENC-002\": SecurityControl(\n            id=\"ENC-002\",\n            name=\"TLS Encryption\",\n            description=\"Encrypt data in transit using TLS 1.3\",\n            control_type=ControlType.PREVENTIVE,\n            layer=ControlLayer.NETWORK,\n            effectiveness=Effectiveness.HIGH,\n            implementation_cost=\"Low\",\n            maintenance_cost=\"Low\",\n            mitigates_threats=[\"INFORMATION_DISCLOSURE\", \"TAMPERING\"],\n            technologies=[\"TLS 1.3\", \"Certificate management\"],\n            compliance_refs=[\"PCI-DSS 4.1\", \"HIPAA\"]\n        ),\n\n        # Logging Controls\n        \"LOG-001\": SecurityControl(\n            id=\"LOG-001\",\n            name=\"Security Event Logging\",\n            description=\"Log all security-relevant events\",\n            control_type=ControlType.DETECTIVE,\n            layer=ControlLayer.APPLICATION,\n            effectiveness=Effectiveness.MEDIUM,\n            implementation_cost=\"Low\",\n            maintenance_cost=\"Medium\",\n            mitigates_threats=[\"REPUDIATION\"],\n            technologies=[\"ELK Stack\", \"Splunk\", \"CloudWatch\"],\n            compliance_refs=[\"PCI-DSS 10.2\", \"SOC2\"]\n        ),\n        \"LOG-002\": SecurityControl(\n            id=\"LOG-002\",\n            name=\"Log Integrity Protection\",\n            description=\"Protect logs from tampering\",\n            control_type=ControlType.PREVENTIVE,\n            layer=ControlLayer.DATA,\n            effectiveness=Effectiveness.MEDIUM,\n            implementation_cost=\"Medium\",\n            maintenance_cost=\"Low\",\n            mitigates_threats=[\"REPUDIATION\", \"TAMPERING\"],\n            technologies=[\"Immutable storage\", \"Log signing\"],\n            compliance_refs=[\"PCI-DSS 10.5\"]\n        ),\n\n        # Access Control\n        \"ACC-001\": SecurityControl(\n            id=\"ACC-001\",\n            name=\"Role-Based Access Control\",\n            description=\"Implement RBAC for authorization\",\n            control_type=ControlType.PREVENTIVE,\n            layer=ControlLayer.APPLICATION,\n            effectiveness=Effectiveness.HIGH,\n            implementation_cost=\"Medium\",\n            maintenance_cost=\"Medium\",\n            mitigates_threats=[\"ELEVATION_OF_PRIVILEGE\", \"INFORMATION_DISCLOSURE\"],\n            technologies=[\"RBAC\", \"ABAC\", \"Policy engines\"],\n            compliance_refs=[\"PCI-DSS 7.1\", \"SOC2\"]\n        ),\n\n        # Availability Controls\n        \"AVL-001\": SecurityControl(\n            id=\"AVL-001\",\n            name=\"Rate Limiting\",\n            description=\"Limit request rates to prevent abuse\",\n            control_type=ControlType.PREVENTIVE,\n            layer=ControlLayer.APPLICATION,\n            effectiveness=Effectiveness.MEDIUM,\n            implementation_cost=\"Low\",\n            maintenance_cost=\"Low\",\n            mitigates_threats=[\"DENIAL_OF_SERVICE\"],\n            technologies=[\"API Gateway\", \"Redis\", \"Token bucket\"],\n            compliance_refs=[\"OWASP API Security\"]\n        ),\n        \"AVL-002\": SecurityControl(\n            id=\"AVL-002\",\n            name=\"DDoS Protection\",\n            description=\"Deploy DDoS mitigation services\",\n            control_type=ControlType.PREVENTIVE,\n            layer=ControlLayer.NETWORK,\n            effectiveness=Effectiveness.HIGH,\n            implementation_cost=\"High\",\n            maintenance_cost=\"Medium\",\n            mitigates_threats=[\"DENIAL_OF_SERVICE\"],\n            technologies=[\"Cloudflare\", \"AWS Shield\", \"Akamai\"],\n            compliance_refs=[\"NIST CSF\"]\n        ),\n    }\n\n    def get_controls_for_threat(self, threat_category: str) -> List[SecurityControl]:\n        \"\"\"Get all controls that mitigate a threat category.\"\"\"\n        return [\n            c for c in self.STANDARD_CONTROLS.values()\n            if threat_category in c.mitigates_threats\n        ]\n\n    def get_controls_by_layer(self, layer: ControlLayer) -> List[SecurityControl]:\n        \"\"\"Get controls for a specific layer.\"\"\"\n        return [c for c in self.STANDARD_CONTROLS.values() if c.layer == layer]\n\n    def get_control(self, control_id: str) -> Optional[SecurityControl]:\n        \"\"\"Get a specific control by ID.\"\"\"\n        return self.STANDARD_CONTROLS.get(control_id)\n\n    def recommend_controls(\n        self,\n        threat: Threat,\n        existing_controls: List[str]\n    ) -> List[SecurityControl]:\n        \"\"\"Recommend additional controls for a threat.\"\"\"\n        available = self.get_controls_for_threat(threat.category)\n        return [c for c in available if c.id not in existing_controls]\n```\n\n### Template 3: Mitigation Analysis\n\n```python\nclass MitigationAnalyzer:\n    \"\"\"Analyze and optimize mitigation strategies.\"\"\"\n\n    def __init__(self, plan: MitigationPlan, library: ControlLibrary):\n        self.plan = plan\n        self.library = library\n\n    def calculate_overall_risk_reduction(self) -> float:\n        \"\"\"Calculate overall risk reduction percentage.\"\"\"\n        if not self.plan.mappings:\n            return 0.0\n\n        weighted_coverage = 0\n        total_weight = 0\n\n        for mapping in self.plan.mappings:\n            # Weight by threat risk score\n            weight = mapping.threat.risk_score\n            coverage = mapping.calculate_coverage()\n            weighted_coverage += weight * coverage\n            total_weight += weight\n\n        return weighted_coverage / total_weight if total_weight > 0 else 0\n\n    def get_critical_gaps(self) -> List[Dict]:\n        \"\"\"Find critical gaps that need immediate attention.\"\"\"\n        gaps = self.plan.get_gaps()\n        critical_threats = {t.id for t in self.plan.threats if t.impact == \"Critical\"}\n\n        return [g for g in gaps if g[\"threat\"] in critical_threats]\n\n    def optimize_budget(\n        self,\n        budget: float,\n        cost_map: Dict[str, float]\n    ) -> List[SecurityControl]:\n        \"\"\"Select controls that maximize risk reduction within budget.\"\"\"\n        # Simple greedy approach - can be replaced with optimization algorithm\n        recommended = []\n        remaining_budget = budget\n        unmapped = self.plan.get_unmapped_threats()\n\n        # Sort controls by effectiveness/cost ratio\n        all_controls = list(self.library.STANDARD_CONTROLS.values())\n        controls_with_value = []\n\n        for control in all_controls:\n            if control.status == ImplementationStatus.NOT_IMPLEMENTED:\n                cost = cost_map.get(control.id, float('inf'))\n                if cost <= remaining_budget:\n                    # Calculate value as threats covered * effectiveness / cost\n                    threats_covered = len([\n                        t for t in unmapped\n                        if t.category in control.mitigates_threats\n                    ])\n                    if threats_covered > 0:\n                        value = (threats_covered * control.effectiveness.value) / cost\n                        controls_with_value.append((control, value, cost))\n\n        # Sort by value (higher is better)\n        controls_with_value.sort(key=lambda x: x[1], reverse=True)\n\n        for control, value, cost in controls_with_value:\n            if cost <= remaining_budget:\n                recommended.append(control)\n                remaining_budget -= cost\n\n        return recommended\n\n    def generate_roadmap(self) -> List[Dict]:\n        \"\"\"Generate implementation roadmap by priority.\"\"\"\n        roadmap = []\n        gaps = self.plan.get_gaps()\n\n        # Phase 1: Critical threats with low coverage\n        phase1 = []\n        for gap in gaps:\n            mapping = next(\n                (m for m in self.plan.mappings if m.threat.id == gap[\"threat\"]),\n                None\n            )\n            if mapping and mapping.threat.impact == \"Critical\":\n                controls = self.library.get_controls_for_threat(mapping.threat.category)\n                phase1.extend([\n                    {\n                        \"threat\": gap[\"threat\"],\n                        \"control\": c.id,\n                        \"control_name\": c.name,\n                        \"phase\": 1,\n                        \"priority\": \"Critical\"\n                    }\n                    for c in controls\n                    if c.status == ImplementationStatus.NOT_IMPLEMENTED\n                ])\n\n        roadmap.extend(phase1[:5])  # Top 5 for phase 1\n\n        # Phase 2: High impact threats\n        phase2 = []\n        for gap in gaps:\n            mapping = next(\n                (m for m in self.plan.mappings if m.threat.id == gap[\"threat\"]),\n                None\n            )\n            if mapping and mapping.threat.impact == \"High\":\n                controls = self.library.get_controls_for_threat(mapping.threat.category)\n                phase2.extend([\n                    {\n                        \"threat\": gap[\"threat\"],\n                        \"control\": c.id,\n                        \"control_name\": c.name,\n                        \"phase\": 2,\n                        \"priority\": \"High\"\n                    }\n                    for c in controls\n                    if c.status == ImplementationStatus.NOT_IMPLEMENTED\n                ])\n\n        roadmap.extend(phase2[:5])  # Top 5 for phase 2\n\n        return roadmap\n\n    def defense_in_depth_analysis(self) -> Dict[str, List[str]]:\n        \"\"\"Analyze defense in depth coverage.\"\"\"\n        layer_coverage = {layer.value: [] for layer in ControlLayer}\n\n        for mapping in self.plan.mappings:\n            for control in mapping.controls:\n                if control.status in [ImplementationStatus.IMPLEMENTED, ImplementationStatus.VERIFIED]:\n                    layer_coverage[control.layer.value].append(control.id)\n\n        return layer_coverage\n\n    def generate_report(self) -> str:\n        \"\"\"Generate comprehensive mitigation report.\"\"\"\n        risk_reduction = self.calculate_overall_risk_reduction()\n        gaps = self.plan.get_gaps()\n        critical_gaps = self.get_critical_gaps()\n        layer_coverage = self.defense_in_depth_analysis()\n\n        report = f\"\"\"\n# Threat Mitigation Report\n\n## Executive Summary\n- **Overall Risk Reduction:** {risk_reduction:.1f}%\n- **Total Threats:** {len(self.plan.threats)}\n- **Total Controls:** {len(self.plan.controls)}\n- **Identified Gaps:** {len(gaps)}\n- **Critical Gaps:** {len(critical_gaps)}\n\n## Defense in Depth Coverage\n{self._format_layer_coverage(layer_coverage)}\n\n## Critical Gaps Requiring Immediate Action\n{self._format_gaps(critical_gaps)}\n\n## Recommendations\n{self._format_recommendations()}\n\n## Implementation Roadmap\n{self._format_roadmap()}\n\"\"\"\n        return report\n\n    def _format_layer_coverage(self, coverage: Dict[str, List[str]]) -> str:\n        lines = []\n        for layer, controls in coverage.items():\n            status = \"\u2713\" if controls else \"\u2717\"\n            lines.append(f\"- {layer}: {status} ({len(controls)} controls)\")\n        return \"\\n\".join(lines)\n\n    def _format_gaps(self, gaps: List[Dict]) -> str:\n        if not gaps:\n            return \"No critical gaps identified.\"\n        lines = []\n        for gap in gaps:\n            lines.append(f\"- **{gap['threat_name']}**: {gap['issue']}\")\n            lines.append(f\"  - Coverage: {gap['coverage']:.1f}%\")\n            lines.append(f\"  - Recommendation: {gap['recommendation']}\")\n        return \"\\n\".join(lines)\n\n    def _format_recommendations(self) -> str:\n        recommendations = []\n        layer_coverage = self.defense_in_depth_analysis()\n\n        for layer, controls in layer_coverage.items():\n            if not controls:\n                recommendations.append(f\"- Add {layer} layer controls\")\n\n        gaps = self.plan.get_gaps()\n        if any(g[\"issue\"] == \"No control diversity\" for g in gaps):\n            recommendations.append(\"- Add more detective and corrective controls\")\n\n        return \"\\n\".join(recommendations) if recommendations else \"Current coverage is adequate.\"\n\n    def _format_roadmap(self) -> str:\n        roadmap = self.generate_roadmap()\n        if not roadmap:\n            return \"No additional controls recommended at this time.\"\n\n        lines = []\n        current_phase = 0\n        for item in roadmap:\n            if item[\"phase\"] != current_phase:\n                current_phase = item[\"phase\"]\n                lines.append(f\"\\n### Phase {current_phase}\")\n            lines.append(f\"- [{item['priority']}] {item['control_name']} (for {item['threat']})\")\n\n        return \"\\n\".join(lines)\n```\n\n### Template 4: Control Effectiveness Testing\n\n```python\nfrom dataclasses import dataclass\nfrom typing import List, Callable, Any\nimport asyncio\n\n@dataclass\nclass ControlTest:\n    control_id: str\n    test_name: str\n    test_function: Callable[[], bool]\n    expected_result: bool\n    description: str\n\n\nclass ControlTester:\n    \"\"\"Test control effectiveness.\"\"\"\n\n    def __init__(self):\n        self.tests: List[ControlTest] = []\n        self.results: List[Dict] = []\n\n    def add_test(self, test: ControlTest) -> None:\n        self.tests.append(test)\n\n    async def run_tests(self) -> List[Dict]:\n        \"\"\"Run all control tests.\"\"\"\n        self.results = []\n\n        for test in self.tests:\n            try:\n                result = test.test_function()\n                passed = result == test.expected_result\n                self.results.append({\n                    \"control_id\": test.control_id,\n                    \"test_name\": test.test_name,\n                    \"passed\": passed,\n                    \"actual_result\": result,\n                    \"expected_result\": test.expected_result,\n                    \"description\": test.description,\n                    \"error\": None\n                })\n            except Exception as e:\n                self.results.append({\n                    \"control_id\": test.control_id,\n                    \"test_name\": test.test_name,\n                    \"passed\": False,\n                    \"actual_result\": None,\n                    \"expected_result\": test.expected_result,\n                    \"description\": test.description,\n                    \"error\": str(e)\n                })\n\n        return self.results\n\n    def get_effectiveness_score(self, control_id: str) -> float:\n        \"\"\"Calculate effectiveness score for a control.\"\"\"\n        control_results = [r for r in self.results if r[\"control_id\"] == control_id]\n        if not control_results:\n            return 0.0\n\n        passed = sum(1 for r in control_results if r[\"passed\"])\n        return (passed / len(control_results)) * 100\n\n    def generate_test_report(self) -> str:\n        \"\"\"Generate test results report.\"\"\"\n        if not self.results:\n            return \"No tests have been run.\"\n\n        total = len(self.results)\n        passed = sum(1 for r in self.results if r[\"passed\"])\n\n        report = f\"\"\"\n# Control Effectiveness Test Report\n\n## Summary\n- **Total Tests:** {total}\n- **Passed:** {passed}\n- **Failed:** {total - passed}\n- **Pass Rate:** {(passed/total)*100:.1f}%\n\n## Results by Control\n\"\"\"\n        # Group by control\n        controls = {}\n        for result in self.results:\n            cid = result[\"control_id\"]\n            if cid not in controls:\n                controls[cid] = []\n            controls[cid].append(result)\n\n        for control_id, results in controls.items():\n            score = self.get_effectiveness_score(control_id)\n            report += f\"\\n### {control_id} (Effectiveness: {score:.1f}%)\\n\"\n            for r in results:\n                status = \"\u2713\" if r[\"passed\"] else \"\u2717\"\n                report += f\"- {status} {r['test_name']}\\n\"\n                if r[\"error\"]:\n                    report += f\"  - Error: {r['error']}\\n\"\n\n        return report\n```\n\n## Best Practices\n\n### Do's\n- **Map all threats** - No threat should be unmapped\n- **Layer controls** - Defense in depth is essential\n- **Mix control types** - Preventive, detective, corrective\n- **Track effectiveness** - Measure and improve\n- **Review regularly** - Controls degrade over time\n\n### Don'ts\n- **Don't rely on single controls** - Single points of failure\n- **Don't ignore cost** - ROI matters\n- **Don't skip testing** - Untested controls may fail\n- **Don't set and forget** - Continuous improvement\n- **Don't ignore people/process** - Technology alone isn't enough\n\n## Resources\n\n- [NIST Cybersecurity Framework](https://www.nist.gov/cyberframework)\n- [CIS Controls](https://www.cisecurity.org/controls)\n- [MITRE D3FEND](https://d3fend.mitre.org/)\n"
}