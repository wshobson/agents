{
  "id": "frontend_mobile_development_nextjs_app_router_patterns",
  "name": "nextjs-app-router-patterns",
  "source": "frontend-mobile-development",
  "originalPath": "plugins/frontend-mobile-development/skills/nextjs-app-router-patterns/SKILL.md",
  "activationCriteria": "Master Next.js 14+ App Router with Server Components, streaming, parallel routes, and advanced data fetching. Use when building Next.js applications, implementing SSR/SSG, or optimizing React Server C",
  "tier1_metadata": "nextjs-app-router-patterns: Master Next.js 14+ App Router with Server Components, streaming, parallel routes, and advanced data ",
  "tier2_instructions": "# Next.js App Router Patterns\n\nComprehensive patterns for Next.js 14+ App Router architecture, Server Components, and modern full-stack React development.\n\n## When to Use This Skill\n\n- Building new Next.js applications with App Router\n- Migrating from Pages Router to App Router\n- Implementing Server Components and streaming\n- Setting up parallel and intercepting routes\n- Optimizing data fetching and caching\n- Building full-stack features with Server Actions\n\n## Core Concepts\n\n### 1. Rendering Modes\n\n| Mode | Where | When to Use |\n|------|-------|-------------|\n| **Server Components** | Server only | Data fetching, heavy computation, secrets |\n| **Client Components** | Browser | Interactivity, hooks, browser APIs |\n| **Static** | Build time | Content that rarely changes |\n| **Dynamic** | Request time | Personalized or real-time data |\n| **Streaming** | Progressive | Large pages, slow data sources |\n\n### 2. File Conventions\n\n```\napp/\n\u251c\u2500\u2500 layout.tsx       # Shared UI wrapper\n\u251c\u2500\u2500 page.tsx         # Route UI\n\u251c\u2500\u2500 loading.tsx      # Loading UI (Suspense)\n\u251c\u2500\u2500 error.tsx        # Error boundary\n\u251c\u2500\u2500 not-found.tsx    # 404 UI\n\u251c\u2500\u2500 route.ts         # API endpoint\n\u251c\u2500\u2500 template.tsx     # Re-mounted layout\n\u251c\u2500\u2500 default.tsx      # Parallel route fallback\n\u2514\u2500\u2500 opengraph-image.tsx  # OG image generation\n```\n\n## Quick Start\n\n```typescript\n// app/layout.tsx\nimport { Inter } from 'next/font/google'\nimport { Providers } from './providers'\n\nconst inter = Inter({ subsets: ['latin'] })\n\nexport const metadata = {\n  title: { default: 'My App', template: '%s | My App' },\n  description: 'Built with Next.js App Router',\n}\n\nexport default function RootLayout({\n  children,\n}: {\n  children: React.ReactNode\n}) {\n  return (\n    <html lang=\"en\" suppressHydrationWarning>\n      <body className={inter.className}>\n        <Providers>{children}</Providers>\n      </body>\n    </html>\n  )\n}\n\n// app/page.tsx - Server Component by default\nasync function getProducts() {\n  const res = await fetch('https://api.example",
  "tier3_resources": ".com/products', {\n    next: { revalidate: 3600 }, // ISR: revalidate every hour\n  })\n  return res.json()\n}\n\nexport default async function HomePage() {\n  const products = await getProducts()\n\n  return (\n    <main>\n      <h1>Products</h1>\n      <ProductGrid products={products} />\n    </main>\n  )\n}\n```\n\n## Patterns\n\n### Pattern 1: Server Components with Data Fetching\n\n```typescript\n// app/products/page.tsx\nimport { Suspense } from 'react'\nimport { ProductList, ProductListSkeleton } from '@/components/products'\nimport { FilterSidebar } from '@/components/filters'\n\ninterface SearchParams {\n  category?: string\n  sort?: 'price' | 'name' | 'date'\n  page?: string\n}\n\nexport default async function ProductsPage({\n  searchParams,\n}: {\n  searchParams: Promise<SearchParams>\n}) {\n  const params = await searchParams\n\n  return (\n    <div className=\"flex gap-8\">\n      <FilterSidebar />\n      <Suspense\n        key={JSON.stringify(params)}\n        fallback={<ProductListSkeleton />}\n      >\n        <ProductList\n          category={params.category}\n          sort={params.sort}\n          page={Number(params.page) || 1}\n        />\n      </Suspense>\n    </div>\n  )\n}\n\n// components/products/ProductList.tsx - Server Component\nasync function getProducts(filters: ProductFilters) {\n  const res = await fetch(\n    `${process.env.API_URL}/products?${new URLSearchParams(filters)}`,\n    { next: { tags: ['products'] } }\n  )\n  if (!res.ok) throw new Error('Failed to fetch products')\n  return res.json()\n}\n\nexport async function ProductList({ category, sort, page }: ProductFilters) {\n  const { products, totalPages } = await getProducts({ category, sort, page })\n\n  return (\n    <div>\n      <div className=\"grid grid-cols-3 gap-4\">\n        {products.map((product) => (\n          <ProductCard key={product.id} product={product} />\n        ))}\n      </div>\n      <Pagination currentPage={page} totalPages={totalPages} />\n    </div>\n  )\n}\n```\n\n### Pattern 2: Client Components with 'use client'\n\n```typescript\n// components/products/AddToCartButton.tsx\n'use client'\n\nimport { useState, useTransition } from 'react'\nimport { addToCart } from '@/app/actions/cart'\n\nexport function AddToCartButton({ productId }: { productId: string }) {\n  const [isPending, startTransition] = useTransition()\n  const [error, setError] = useState<string | null>(null)\n\n  const handleClick = () => {\n    setError(null)\n    startTransition(async () => {\n      const result = await addToCart(productId)\n      if (result.error) {\n        setError(result.error)\n      }\n    })\n  }\n\n  return (\n    <div>\n      <button\n        onClick={handleClick}\n        disabled={isPending}\n        className=\"btn-primary\"\n      >\n        {isPending ? 'Adding...' : 'Add to Cart'}\n      </button>\n      {error && <p className=\"text-red-500 text-sm\">{error}</p>}\n    </div>\n  )\n}\n```\n\n### Pattern 3: Server Actions\n\n```typescript\n// app/actions/cart.ts\n'use server'\n\nimport { revalidateTag } from 'next/cache'\nimport { cookies } from 'next/headers'\nimport {",
  "tokenEstimate": {
    "tier1": 19.5,
    "tier2": 370.5,
    "tier3": 1734.2
  },
  "fullDefinition": "---\nname: nextjs-app-router-patterns\ndescription: Master Next.js 14+ App Router with Server Components, streaming, parallel routes, and advanced data fetching. Use when building Next.js applications, implementing SSR/SSG, or optimizing React Server Components.\n---\n\n# Next.js App Router Patterns\n\nComprehensive patterns for Next.js 14+ App Router architecture, Server Components, and modern full-stack React development.\n\n## When to Use This Skill\n\n- Building new Next.js applications with App Router\n- Migrating from Pages Router to App Router\n- Implementing Server Components and streaming\n- Setting up parallel and intercepting routes\n- Optimizing data fetching and caching\n- Building full-stack features with Server Actions\n\n## Core Concepts\n\n### 1. Rendering Modes\n\n| Mode | Where | When to Use |\n|------|-------|-------------|\n| **Server Components** | Server only | Data fetching, heavy computation, secrets |\n| **Client Components** | Browser | Interactivity, hooks, browser APIs |\n| **Static** | Build time | Content that rarely changes |\n| **Dynamic** | Request time | Personalized or real-time data |\n| **Streaming** | Progressive | Large pages, slow data sources |\n\n### 2. File Conventions\n\n```\napp/\n\u251c\u2500\u2500 layout.tsx       # Shared UI wrapper\n\u251c\u2500\u2500 page.tsx         # Route UI\n\u251c\u2500\u2500 loading.tsx      # Loading UI (Suspense)\n\u251c\u2500\u2500 error.tsx        # Error boundary\n\u251c\u2500\u2500 not-found.tsx    # 404 UI\n\u251c\u2500\u2500 route.ts         # API endpoint\n\u251c\u2500\u2500 template.tsx     # Re-mounted layout\n\u251c\u2500\u2500 default.tsx      # Parallel route fallback\n\u2514\u2500\u2500 opengraph-image.tsx  # OG image generation\n```\n\n## Quick Start\n\n```typescript\n// app/layout.tsx\nimport { Inter } from 'next/font/google'\nimport { Providers } from './providers'\n\nconst inter = Inter({ subsets: ['latin'] })\n\nexport const metadata = {\n  title: { default: 'My App', template: '%s | My App' },\n  description: 'Built with Next.js App Router',\n}\n\nexport default function RootLayout({\n  children,\n}: {\n  children: React.ReactNode\n}) {\n  return (\n    <html lang=\"en\" suppressHydrationWarning>\n      <body className={inter.className}>\n        <Providers>{children}</Providers>\n      </body>\n    </html>\n  )\n}\n\n// app/page.tsx - Server Component by default\nasync function getProducts() {\n  const res = await fetch('https://api.example.com/products', {\n    next: { revalidate: 3600 }, // ISR: revalidate every hour\n  })\n  return res.json()\n}\n\nexport default async function HomePage() {\n  const products = await getProducts()\n\n  return (\n    <main>\n      <h1>Products</h1>\n      <ProductGrid products={products} />\n    </main>\n  )\n}\n```\n\n## Patterns\n\n### Pattern 1: Server Components with Data Fetching\n\n```typescript\n// app/products/page.tsx\nimport { Suspense } from 'react'\nimport { ProductList, ProductListSkeleton } from '@/components/products'\nimport { FilterSidebar } from '@/components/filters'\n\ninterface SearchParams {\n  category?: string\n  sort?: 'price' | 'name' | 'date'\n  page?: string\n}\n\nexport default async function ProductsPage({\n  searchParams,\n}: {\n  searchParams: Promise<SearchParams>\n}) {\n  const params = await searchParams\n\n  return (\n    <div className=\"flex gap-8\">\n      <FilterSidebar />\n      <Suspense\n        key={JSON.stringify(params)}\n        fallback={<ProductListSkeleton />}\n      >\n        <ProductList\n          category={params.category}\n          sort={params.sort}\n          page={Number(params.page) || 1}\n        />\n      </Suspense>\n    </div>\n  )\n}\n\n// components/products/ProductList.tsx - Server Component\nasync function getProducts(filters: ProductFilters) {\n  const res = await fetch(\n    `${process.env.API_URL}/products?${new URLSearchParams(filters)}`,\n    { next: { tags: ['products'] } }\n  )\n  if (!res.ok) throw new Error('Failed to fetch products')\n  return res.json()\n}\n\nexport async function ProductList({ category, sort, page }: ProductFilters) {\n  const { products, totalPages } = await getProducts({ category, sort, page })\n\n  return (\n    <div>\n      <div className=\"grid grid-cols-3 gap-4\">\n        {products.map((product) => (\n          <ProductCard key={product.id} product={product} />\n        ))}\n      </div>\n      <Pagination currentPage={page} totalPages={totalPages} />\n    </div>\n  )\n}\n```\n\n### Pattern 2: Client Components with 'use client'\n\n```typescript\n// components/products/AddToCartButton.tsx\n'use client'\n\nimport { useState, useTransition } from 'react'\nimport { addToCart } from '@/app/actions/cart'\n\nexport function AddToCartButton({ productId }: { productId: string }) {\n  const [isPending, startTransition] = useTransition()\n  const [error, setError] = useState<string | null>(null)\n\n  const handleClick = () => {\n    setError(null)\n    startTransition(async () => {\n      const result = await addToCart(productId)\n      if (result.error) {\n        setError(result.error)\n      }\n    })\n  }\n\n  return (\n    <div>\n      <button\n        onClick={handleClick}\n        disabled={isPending}\n        className=\"btn-primary\"\n      >\n        {isPending ? 'Adding...' : 'Add to Cart'}\n      </button>\n      {error && <p className=\"text-red-500 text-sm\">{error}</p>}\n    </div>\n  )\n}\n```\n\n### Pattern 3: Server Actions\n\n```typescript\n// app/actions/cart.ts\n'use server'\n\nimport { revalidateTag } from 'next/cache'\nimport { cookies } from 'next/headers'\nimport { redirect } from 'next/navigation'\n\nexport async function addToCart(productId: string) {\n  const cookieStore = await cookies()\n  const sessionId = cookieStore.get('session')?.value\n\n  if (!sessionId) {\n    redirect('/login')\n  }\n\n  try {\n    await db.cart.upsert({\n      where: { sessionId_productId: { sessionId, productId } },\n      update: { quantity: { increment: 1 } },\n      create: { sessionId, productId, quantity: 1 },\n    })\n\n    revalidateTag('cart')\n    return { success: true }\n  } catch (error) {\n    return { error: 'Failed to add item to cart' }\n  }\n}\n\nexport async function checkout(formData: FormData) {\n  const address = formData.get('address') as string\n  const payment = formData.get('payment') as string\n\n  // Validate\n  if (!address || !payment) {\n    return { error: 'Missing required fields' }\n  }\n\n  // Process order\n  const order = await processOrder({ address, payment })\n\n  // Redirect to confirmation\n  redirect(`/orders/${order.id}/confirmation`)\n}\n```\n\n### Pattern 4: Parallel Routes\n\n```typescript\n// app/dashboard/layout.tsx\nexport default function DashboardLayout({\n  children,\n  analytics,\n  team,\n}: {\n  children: React.ReactNode\n  analytics: React.ReactNode\n  team: React.ReactNode\n}) {\n  return (\n    <div className=\"dashboard-grid\">\n      <main>{children}</main>\n      <aside className=\"analytics-panel\">{analytics}</aside>\n      <aside className=\"team-panel\">{team}</aside>\n    </div>\n  )\n}\n\n// app/dashboard/@analytics/page.tsx\nexport default async function AnalyticsSlot() {\n  const stats = await getAnalytics()\n  return <AnalyticsChart data={stats} />\n}\n\n// app/dashboard/@analytics/loading.tsx\nexport default function AnalyticsLoading() {\n  return <ChartSkeleton />\n}\n\n// app/dashboard/@team/page.tsx\nexport default async function TeamSlot() {\n  const members = await getTeamMembers()\n  return <TeamList members={members} />\n}\n```\n\n### Pattern 5: Intercepting Routes (Modal Pattern)\n\n```typescript\n// File structure for photo modal\n// app/\n// \u251c\u2500\u2500 @modal/\n// \u2502   \u251c\u2500\u2500 (.)photos/[id]/page.tsx  # Intercept\n// \u2502   \u2514\u2500\u2500 default.tsx\n// \u251c\u2500\u2500 photos/\n// \u2502   \u2514\u2500\u2500 [id]/page.tsx            # Full page\n// \u2514\u2500\u2500 layout.tsx\n\n// app/@modal/(.)photos/[id]/page.tsx\nimport { Modal } from '@/components/Modal'\nimport { PhotoDetail } from '@/components/PhotoDetail'\n\nexport default async function PhotoModal({\n  params,\n}: {\n  params: Promise<{ id: string }>\n}) {\n  const { id } = await params\n  const photo = await getPhoto(id)\n\n  return (\n    <Modal>\n      <PhotoDetail photo={photo} />\n    </Modal>\n  )\n}\n\n// app/photos/[id]/page.tsx - Full page version\nexport default async function PhotoPage({\n  params,\n}: {\n  params: Promise<{ id: string }>\n}) {\n  const { id } = await params\n  const photo = await getPhoto(id)\n\n  return (\n    <div className=\"photo-page\">\n      <PhotoDetail photo={photo} />\n      <RelatedPhotos photoId={id} />\n    </div>\n  )\n}\n\n// app/layout.tsx\nexport default function RootLayout({\n  children,\n  modal,\n}: {\n  children: React.ReactNode\n  modal: React.ReactNode\n}) {\n  return (\n    <html>\n      <body>\n        {children}\n        {modal}\n      </body>\n    </html>\n  )\n}\n```\n\n### Pattern 6: Streaming with Suspense\n\n```typescript\n// app/product/[id]/page.tsx\nimport { Suspense } from 'react'\n\nexport default async function ProductPage({\n  params,\n}: {\n  params: Promise<{ id: string }>\n}) {\n  const { id } = await params\n\n  // This data loads first (blocking)\n  const product = await getProduct(id)\n\n  return (\n    <div>\n      {/* Immediate render */}\n      <ProductHeader product={product} />\n\n      {/* Stream in reviews */}\n      <Suspense fallback={<ReviewsSkeleton />}>\n        <Reviews productId={id} />\n      </Suspense>\n\n      {/* Stream in recommendations */}\n      <Suspense fallback={<RecommendationsSkeleton />}>\n        <Recommendations productId={id} />\n      </Suspense>\n    </div>\n  )\n}\n\n// These components fetch their own data\nasync function Reviews({ productId }: { productId: string }) {\n  const reviews = await getReviews(productId) // Slow API\n  return <ReviewList reviews={reviews} />\n}\n\nasync function Recommendations({ productId }: { productId: string }) {\n  const products = await getRecommendations(productId) // ML-based, slow\n  return <ProductCarousel products={products} />\n}\n```\n\n### Pattern 7: Route Handlers (API Routes)\n\n```typescript\n// app/api/products/route.ts\nimport { NextRequest, NextResponse } from 'next/server'\n\nexport async function GET(request: NextRequest) {\n  const searchParams = request.nextUrl.searchParams\n  const category = searchParams.get('category')\n\n  const products = await db.product.findMany({\n    where: category ? { category } : undefined,\n    take: 20,\n  })\n\n  return NextResponse.json(products)\n}\n\nexport async function POST(request: NextRequest) {\n  const body = await request.json()\n\n  const product = await db.product.create({\n    data: body,\n  })\n\n  return NextResponse.json(product, { status: 201 })\n}\n\n// app/api/products/[id]/route.ts\nexport async function GET(\n  request: NextRequest,\n  { params }: { params: Promise<{ id: string }> }\n) {\n  const { id } = await params\n  const product = await db.product.findUnique({ where: { id } })\n\n  if (!product) {\n    return NextResponse.json(\n      { error: 'Product not found' },\n      { status: 404 }\n    )\n  }\n\n  return NextResponse.json(product)\n}\n```\n\n### Pattern 8: Metadata and SEO\n\n```typescript\n// app/products/[slug]/page.tsx\nimport { Metadata } from 'next'\nimport { notFound } from 'next/navigation'\n\ntype Props = {\n  params: Promise<{ slug: string }>\n}\n\nexport async function generateMetadata({ params }: Props): Promise<Metadata> {\n  const { slug } = await params\n  const product = await getProduct(slug)\n\n  if (!product) return {}\n\n  return {\n    title: product.name,\n    description: product.description,\n    openGraph: {\n      title: product.name,\n      description: product.description,\n      images: [{ url: product.image, width: 1200, height: 630 }],\n    },\n    twitter: {\n      card: 'summary_large_image',\n      title: product.name,\n      description: product.description,\n      images: [product.image],\n    },\n  }\n}\n\nexport async function generateStaticParams() {\n  const products = await db.product.findMany({ select: { slug: true } })\n  return products.map((p) => ({ slug: p.slug }))\n}\n\nexport default async function ProductPage({ params }: Props) {\n  const { slug } = await params\n  const product = await getProduct(slug)\n\n  if (!product) notFound()\n\n  return <ProductDetail product={product} />\n}\n```\n\n## Caching Strategies\n\n### Data Cache\n\n```typescript\n// No cache (always fresh)\nfetch(url, { cache: 'no-store' })\n\n// Cache forever (static)\nfetch(url, { cache: 'force-cache' })\n\n// ISR - revalidate after 60 seconds\nfetch(url, { next: { revalidate: 60 } })\n\n// Tag-based invalidation\nfetch(url, { next: { tags: ['products'] } })\n\n// Invalidate via Server Action\n'use server'\nimport { revalidateTag, revalidatePath } from 'next/cache'\n\nexport async function updateProduct(id: string, data: ProductData) {\n  await db.product.update({ where: { id }, data })\n  revalidateTag('products')\n  revalidatePath('/products')\n}\n```\n\n## Best Practices\n\n### Do's\n- **Start with Server Components** - Add 'use client' only when needed\n- **Colocate data fetching** - Fetch data where it's used\n- **Use Suspense boundaries** - Enable streaming for slow data\n- **Leverage parallel routes** - Independent loading states\n- **Use Server Actions** - For mutations with progressive enhancement\n\n### Don'ts\n- **Don't pass serializable data** - Server \u2192 Client boundary limitations\n- **Don't use hooks in Server Components** - No useState, useEffect\n- **Don't fetch in Client Components** - Use Server Components or React Query\n- **Don't over-nest layouts** - Each layout adds to the component tree\n- **Don't ignore loading states** - Always provide loading.tsx or Suspense\n\n## Resources\n\n- [Next.js App Router Documentation](https://nextjs.org/docs/app)\n- [Server Components RFC](https://github.com/reactjs/rfcs/blob/main/text/0188-server-components.md)\n- [Vercel Templates](https://vercel.com/templates/next.js)\n"
}