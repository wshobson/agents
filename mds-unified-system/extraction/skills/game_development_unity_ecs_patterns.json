{
  "id": "game_development_unity_ecs_patterns",
  "name": "unity-ecs-patterns",
  "source": "game-development",
  "originalPath": "plugins/game-development/skills/unity-ecs-patterns/SKILL.md",
  "activationCriteria": "Master Unity ECS (Entity Component System) with DOTS, Jobs, and Burst for high-performance game development. Use when building data-oriented games, optimizing performance, or working with large entity",
  "tier1_metadata": "unity-ecs-patterns: Master Unity ECS (Entity Component System) with DOTS, Jobs, and Burst for high-performance game deve",
  "tier2_instructions": "# Unity ECS Patterns\n\nProduction patterns for Unity's Data-Oriented Technology Stack (DOTS) including Entity Component System, Job System, and Burst Compiler.\n\n## When to Use This Skill\n\n- Building high-performance Unity games\n- Managing thousands of entities efficiently\n- Implementing data-oriented game systems\n- Optimizing CPU-bound game logic\n- Converting OOP game code to ECS\n- Using Jobs and Burst for parallelization\n\n## Core Concepts\n\n### 1. ECS vs OOP\n\n| Aspect | Traditional OOP | ECS/DOTS |\n|--------|-----------------|----------|\n| Data layout | Object-oriented | Data-oriented |\n| Memory | Scattered | Contiguous |\n| Processing | Per-object | Batched |\n| Scaling | Poor with count | Linear scaling |\n| Best for | Complex behaviors | Mass simulation |\n\n### 2. DOTS Components\n\n```\nEntity: Lightweight ID (no data)\nComponent: Pure data (no behavior)\nSystem: Logic that processes components\nWorld: Container for entities\nArchetype: Unique combination of components\nChunk: Memory block for same-archetype entities\n```\n\n## Patterns\n\n### Pattern 1: Basic ECS Setup\n\n```csharp\nusing Unity.Entities;\nusing Unity.Mathematics;\nusing Unity.Transforms;\nusing Unity.Burst;\nusing Unity.Collections;\n\n// Component: Pure data, no methods\npublic struct Speed : IComponentData\n{\n    public float Value;\n}\n\npublic struct Health : IComponentData\n{\n    public float Current;\n    public float Max;\n}\n\npublic struct Target : IComponentData\n{\n    public Entity Value;\n}\n\n// Tag component (zero-size marker)\npublic struct EnemyTag : IComponentData { }\npublic struct PlayerTag : IComponentData { }\n\n// Buffer component (variable-size array)\n[InternalBufferCapacity(8)]\npublic struct InventoryItem : IBufferElementData\n{\n    public int ItemId;\n    public int Quantity;\n}\n\n// Shared component (grouped entities)\npublic struct TeamId : ISharedComponentData\n{\n    public int Value;\n}\n```\n\n### Pattern 2: Systems with ISystem (Recommended)\n\n```csharp\nusing Unity.Entities;\nusing Unity.Transforms;\nusing Unity.Mathemat",
  "tier3_resources": "ics;\nusing Unity.Burst;\n\n// ISystem: Unmanaged, Burst-compatible, highest performance\n[BurstCompile]\npublic partial struct MovementSystem : ISystem\n{\n    [BurstCompile]\n    public void OnCreate(ref SystemState state)\n    {\n        // Require components before system runs\n        state.RequireForUpdate<Speed>();\n    }\n\n    [BurstCompile]\n    public void OnUpdate(ref SystemState state)\n    {\n        float deltaTime = SystemAPI.Time.DeltaTime;\n\n        // Simple foreach - auto-generates job\n        foreach (var (transform, speed) in\n            SystemAPI.Query<RefRW<LocalTransform>, RefRO<Speed>>())\n        {\n            transform.ValueRW.Position +=\n                new float3(0, 0, speed.ValueRO.Value * deltaTime);\n        }\n    }\n\n    [BurstCompile]\n    public void OnDestroy(ref SystemState state) { }\n}\n\n// With explicit job for more control\n[BurstCompile]\npublic partial struct MovementJobSystem : ISystem\n{\n    [BurstCompile]\n    public void OnUpdate(ref SystemState state)\n    {\n        var job = new MoveJob\n        {\n            DeltaTime = SystemAPI.Time.DeltaTime\n        };\n\n        state.Dependency = job.ScheduleParallel(state.Dependency);\n    }\n}\n\n[BurstCompile]\npublic partial struct MoveJob : IJobEntity\n{\n    public float DeltaTime;\n\n    void Execute(ref LocalTransform transform, in Speed speed)\n    {\n        transform.Position += new float3(0, 0, speed.Value * DeltaTime);\n    }\n}\n```\n\n### Pattern 3: Entity Queries\n\n```csharp\n[BurstCompile]\npublic partial struct QueryExamplesSystem : ISystem\n{\n    private EntityQuery _enemyQuery;\n\n    public void OnCreate(ref SystemState state)\n    {\n        // Build query manually for complex cases\n        _enemyQuery = new EntityQueryBuilder(Allocator.Temp)\n            .WithAll<EnemyTag, Health, LocalTransform>()\n            .WithNone<Dead>()\n            .WithOptions(EntityQueryOptions.FilterWriteGroup)\n            .Build(ref state);\n    }\n\n    [BurstCompile]\n    public void OnUpdate(ref SystemState state)\n    {\n        // SystemAPI.Query - simplest approach\n        foreach (var (health, entity) in\n            SystemAPI.Query<RefRW<Health>>()\n                .WithAll<EnemyTag>()\n                .WithEntityAccess())\n        {\n            if (health.ValueRO.Current <= 0)\n            {\n                // Mark for destruction\n                SystemAPI.GetSingleton<EndSimulationEntityCommandBufferSystem.Singleton>()\n                    .CreateCommandBuffer(state.WorldUnmanaged)\n                    .DestroyEntity(entity);\n            }\n        }\n\n        // Get count\n        int enemyCount = _enemyQuery.CalculateEntityCount();\n\n        // Get all entities\n        var enemies = _enemyQuery.ToEntityArray(Allocator.Temp);\n\n        // Get component arrays\n        var healths = _enemyQuery.ToComponentDataArray<Health>(Allocator.Temp);\n    }\n}\n```\n\n### Pattern 4: Entity Command Buffers (Structural Changes)\n\n```csharp\n// Structural changes (create/destroy/add/remove) require command buffers\n[BurstCompile]\n[UpdateInGrou",
  "tokenEstimate": {
    "tier1": 20.8,
    "tier2": 367.90000000000003,
    "tier3": 1773.2
  },
  "fullDefinition": "---\nname: unity-ecs-patterns\ndescription: Master Unity ECS (Entity Component System) with DOTS, Jobs, and Burst for high-performance game development. Use when building data-oriented games, optimizing performance, or working with large entity counts.\n---\n\n# Unity ECS Patterns\n\nProduction patterns for Unity's Data-Oriented Technology Stack (DOTS) including Entity Component System, Job System, and Burst Compiler.\n\n## When to Use This Skill\n\n- Building high-performance Unity games\n- Managing thousands of entities efficiently\n- Implementing data-oriented game systems\n- Optimizing CPU-bound game logic\n- Converting OOP game code to ECS\n- Using Jobs and Burst for parallelization\n\n## Core Concepts\n\n### 1. ECS vs OOP\n\n| Aspect | Traditional OOP | ECS/DOTS |\n|--------|-----------------|----------|\n| Data layout | Object-oriented | Data-oriented |\n| Memory | Scattered | Contiguous |\n| Processing | Per-object | Batched |\n| Scaling | Poor with count | Linear scaling |\n| Best for | Complex behaviors | Mass simulation |\n\n### 2. DOTS Components\n\n```\nEntity: Lightweight ID (no data)\nComponent: Pure data (no behavior)\nSystem: Logic that processes components\nWorld: Container for entities\nArchetype: Unique combination of components\nChunk: Memory block for same-archetype entities\n```\n\n## Patterns\n\n### Pattern 1: Basic ECS Setup\n\n```csharp\nusing Unity.Entities;\nusing Unity.Mathematics;\nusing Unity.Transforms;\nusing Unity.Burst;\nusing Unity.Collections;\n\n// Component: Pure data, no methods\npublic struct Speed : IComponentData\n{\n    public float Value;\n}\n\npublic struct Health : IComponentData\n{\n    public float Current;\n    public float Max;\n}\n\npublic struct Target : IComponentData\n{\n    public Entity Value;\n}\n\n// Tag component (zero-size marker)\npublic struct EnemyTag : IComponentData { }\npublic struct PlayerTag : IComponentData { }\n\n// Buffer component (variable-size array)\n[InternalBufferCapacity(8)]\npublic struct InventoryItem : IBufferElementData\n{\n    public int ItemId;\n    public int Quantity;\n}\n\n// Shared component (grouped entities)\npublic struct TeamId : ISharedComponentData\n{\n    public int Value;\n}\n```\n\n### Pattern 2: Systems with ISystem (Recommended)\n\n```csharp\nusing Unity.Entities;\nusing Unity.Transforms;\nusing Unity.Mathematics;\nusing Unity.Burst;\n\n// ISystem: Unmanaged, Burst-compatible, highest performance\n[BurstCompile]\npublic partial struct MovementSystem : ISystem\n{\n    [BurstCompile]\n    public void OnCreate(ref SystemState state)\n    {\n        // Require components before system runs\n        state.RequireForUpdate<Speed>();\n    }\n\n    [BurstCompile]\n    public void OnUpdate(ref SystemState state)\n    {\n        float deltaTime = SystemAPI.Time.DeltaTime;\n\n        // Simple foreach - auto-generates job\n        foreach (var (transform, speed) in\n            SystemAPI.Query<RefRW<LocalTransform>, RefRO<Speed>>())\n        {\n            transform.ValueRW.Position +=\n                new float3(0, 0, speed.ValueRO.Value * deltaTime);\n        }\n    }\n\n    [BurstCompile]\n    public void OnDestroy(ref SystemState state) { }\n}\n\n// With explicit job for more control\n[BurstCompile]\npublic partial struct MovementJobSystem : ISystem\n{\n    [BurstCompile]\n    public void OnUpdate(ref SystemState state)\n    {\n        var job = new MoveJob\n        {\n            DeltaTime = SystemAPI.Time.DeltaTime\n        };\n\n        state.Dependency = job.ScheduleParallel(state.Dependency);\n    }\n}\n\n[BurstCompile]\npublic partial struct MoveJob : IJobEntity\n{\n    public float DeltaTime;\n\n    void Execute(ref LocalTransform transform, in Speed speed)\n    {\n        transform.Position += new float3(0, 0, speed.Value * DeltaTime);\n    }\n}\n```\n\n### Pattern 3: Entity Queries\n\n```csharp\n[BurstCompile]\npublic partial struct QueryExamplesSystem : ISystem\n{\n    private EntityQuery _enemyQuery;\n\n    public void OnCreate(ref SystemState state)\n    {\n        // Build query manually for complex cases\n        _enemyQuery = new EntityQueryBuilder(Allocator.Temp)\n            .WithAll<EnemyTag, Health, LocalTransform>()\n            .WithNone<Dead>()\n            .WithOptions(EntityQueryOptions.FilterWriteGroup)\n            .Build(ref state);\n    }\n\n    [BurstCompile]\n    public void OnUpdate(ref SystemState state)\n    {\n        // SystemAPI.Query - simplest approach\n        foreach (var (health, entity) in\n            SystemAPI.Query<RefRW<Health>>()\n                .WithAll<EnemyTag>()\n                .WithEntityAccess())\n        {\n            if (health.ValueRO.Current <= 0)\n            {\n                // Mark for destruction\n                SystemAPI.GetSingleton<EndSimulationEntityCommandBufferSystem.Singleton>()\n                    .CreateCommandBuffer(state.WorldUnmanaged)\n                    .DestroyEntity(entity);\n            }\n        }\n\n        // Get count\n        int enemyCount = _enemyQuery.CalculateEntityCount();\n\n        // Get all entities\n        var enemies = _enemyQuery.ToEntityArray(Allocator.Temp);\n\n        // Get component arrays\n        var healths = _enemyQuery.ToComponentDataArray<Health>(Allocator.Temp);\n    }\n}\n```\n\n### Pattern 4: Entity Command Buffers (Structural Changes)\n\n```csharp\n// Structural changes (create/destroy/add/remove) require command buffers\n[BurstCompile]\n[UpdateInGroup(typeof(SimulationSystemGroup))]\npublic partial struct SpawnSystem : ISystem\n{\n    [BurstCompile]\n    public void OnUpdate(ref SystemState state)\n    {\n        var ecbSingleton = SystemAPI.GetSingleton<BeginSimulationEntityCommandBufferSystem.Singleton>();\n        var ecb = ecbSingleton.CreateCommandBuffer(state.WorldUnmanaged);\n\n        foreach (var (spawner, transform) in\n            SystemAPI.Query<RefRW<Spawner>, RefRO<LocalTransform>>())\n        {\n            spawner.ValueRW.Timer -= SystemAPI.Time.DeltaTime;\n\n            if (spawner.ValueRO.Timer <= 0)\n            {\n                spawner.ValueRW.Timer = spawner.ValueRO.Interval;\n\n                // Create entity (deferred until sync point)\n                Entity newEntity = ecb.Instantiate(spawner.ValueRO.Prefab);\n\n                // Set component values\n                ecb.SetComponent(newEntity, new LocalTransform\n                {\n                    Position = transform.ValueRO.Position,\n                    Rotation = quaternion.identity,\n                    Scale = 1f\n                });\n\n                // Add component\n                ecb.AddComponent(newEntity, new Speed { Value = 5f });\n            }\n        }\n    }\n}\n\n// Parallel ECB usage\n[BurstCompile]\npublic partial struct ParallelSpawnJob : IJobEntity\n{\n    public EntityCommandBuffer.ParallelWriter ECB;\n\n    void Execute([EntityIndexInQuery] int index, in Spawner spawner)\n    {\n        Entity e = ECB.Instantiate(index, spawner.Prefab);\n        ECB.AddComponent(index, e, new Speed { Value = 5f });\n    }\n}\n```\n\n### Pattern 5: Aspect (Grouping Components)\n\n```csharp\nusing Unity.Entities;\nusing Unity.Transforms;\nusing Unity.Mathematics;\n\n// Aspect: Groups related components for cleaner code\npublic readonly partial struct CharacterAspect : IAspect\n{\n    public readonly Entity Entity;\n\n    private readonly RefRW<LocalTransform> _transform;\n    private readonly RefRO<Speed> _speed;\n    private readonly RefRW<Health> _health;\n\n    // Optional component\n    [Optional]\n    private readonly RefRO<Shield> _shield;\n\n    // Buffer\n    private readonly DynamicBuffer<InventoryItem> _inventory;\n\n    public float3 Position\n    {\n        get => _transform.ValueRO.Position;\n        set => _transform.ValueRW.Position = value;\n    }\n\n    public float CurrentHealth => _health.ValueRO.Current;\n    public float MaxHealth => _health.ValueRO.Max;\n    public float MoveSpeed => _speed.ValueRO.Value;\n\n    public bool HasShield => _shield.IsValid;\n    public float ShieldAmount => HasShield ? _shield.ValueRO.Amount : 0f;\n\n    public void TakeDamage(float amount)\n    {\n        float remaining = amount;\n\n        if (HasShield && _shield.ValueRO.Amount > 0)\n        {\n            // Shield absorbs damage first\n            remaining = math.max(0, amount - _shield.ValueRO.Amount);\n        }\n\n        _health.ValueRW.Current = math.max(0, _health.ValueRO.Current - remaining);\n    }\n\n    public void Move(float3 direction, float deltaTime)\n    {\n        _transform.ValueRW.Position += direction * _speed.ValueRO.Value * deltaTime;\n    }\n\n    public void AddItem(int itemId, int quantity)\n    {\n        _inventory.Add(new InventoryItem { ItemId = itemId, Quantity = quantity });\n    }\n}\n\n// Using aspect in system\n[BurstCompile]\npublic partial struct CharacterSystem : ISystem\n{\n    [BurstCompile]\n    public void OnUpdate(ref SystemState state)\n    {\n        float dt = SystemAPI.Time.DeltaTime;\n\n        foreach (var character in SystemAPI.Query<CharacterAspect>())\n        {\n            character.Move(new float3(1, 0, 0), dt);\n\n            if (character.CurrentHealth < character.MaxHealth * 0.5f)\n            {\n                // Low health logic\n            }\n        }\n    }\n}\n```\n\n### Pattern 6: Singleton Components\n\n```csharp\n// Singleton: Exactly one entity with this component\npublic struct GameConfig : IComponentData\n{\n    public float DifficultyMultiplier;\n    public int MaxEnemies;\n    public float SpawnRate;\n}\n\npublic struct GameState : IComponentData\n{\n    public int Score;\n    public int Wave;\n    public float TimeRemaining;\n}\n\n// Create singleton on world creation\npublic partial struct GameInitSystem : ISystem\n{\n    public void OnCreate(ref SystemState state)\n    {\n        var entity = state.EntityManager.CreateEntity();\n        state.EntityManager.AddComponentData(entity, new GameConfig\n        {\n            DifficultyMultiplier = 1.0f,\n            MaxEnemies = 100,\n            SpawnRate = 2.0f\n        });\n        state.EntityManager.AddComponentData(entity, new GameState\n        {\n            Score = 0,\n            Wave = 1,\n            TimeRemaining = 120f\n        });\n    }\n}\n\n// Access singleton in system\n[BurstCompile]\npublic partial struct ScoreSystem : ISystem\n{\n    [BurstCompile]\n    public void OnUpdate(ref SystemState state)\n    {\n        // Read singleton\n        var config = SystemAPI.GetSingleton<GameConfig>();\n\n        // Write singleton\n        ref var gameState = ref SystemAPI.GetSingletonRW<GameState>().ValueRW;\n        gameState.TimeRemaining -= SystemAPI.Time.DeltaTime;\n\n        // Check exists\n        if (SystemAPI.HasSingleton<GameConfig>())\n        {\n            // ...\n        }\n    }\n}\n```\n\n### Pattern 7: Baking (Converting GameObjects)\n\n```csharp\nusing Unity.Entities;\nusing UnityEngine;\n\n// Authoring component (MonoBehaviour in Editor)\npublic class EnemyAuthoring : MonoBehaviour\n{\n    public float Speed = 5f;\n    public float Health = 100f;\n    public GameObject ProjectilePrefab;\n\n    class Baker : Baker<EnemyAuthoring>\n    {\n        public override void Bake(EnemyAuthoring authoring)\n        {\n            var entity = GetEntity(TransformUsageFlags.Dynamic);\n\n            AddComponent(entity, new Speed { Value = authoring.Speed });\n            AddComponent(entity, new Health\n            {\n                Current = authoring.Health,\n                Max = authoring.Health\n            });\n            AddComponent(entity, new EnemyTag());\n\n            if (authoring.ProjectilePrefab != null)\n            {\n                AddComponent(entity, new ProjectilePrefab\n                {\n                    Value = GetEntity(authoring.ProjectilePrefab, TransformUsageFlags.Dynamic)\n                });\n            }\n        }\n    }\n}\n\n// Complex baking with dependencies\npublic class SpawnerAuthoring : MonoBehaviour\n{\n    public GameObject[] Prefabs;\n    public float Interval = 1f;\n\n    class Baker : Baker<SpawnerAuthoring>\n    {\n        public override void Bake(SpawnerAuthoring authoring)\n        {\n            var entity = GetEntity(TransformUsageFlags.Dynamic);\n\n            AddComponent(entity, new Spawner\n            {\n                Interval = authoring.Interval,\n                Timer = 0f\n            });\n\n            // Bake buffer of prefabs\n            var buffer = AddBuffer<SpawnPrefabElement>(entity);\n            foreach (var prefab in authoring.Prefabs)\n            {\n                buffer.Add(new SpawnPrefabElement\n                {\n                    Prefab = GetEntity(prefab, TransformUsageFlags.Dynamic)\n                });\n            }\n\n            // Declare dependencies\n            DependsOn(authoring.Prefabs);\n        }\n    }\n}\n```\n\n### Pattern 8: Jobs with Native Collections\n\n```csharp\nusing Unity.Jobs;\nusing Unity.Collections;\nusing Unity.Burst;\nusing Unity.Mathematics;\n\n[BurstCompile]\npublic struct SpatialHashJob : IJobParallelFor\n{\n    [ReadOnly]\n    public NativeArray<float3> Positions;\n\n    // Thread-safe write to hash map\n    public NativeParallelMultiHashMap<int, int>.ParallelWriter HashMap;\n\n    public float CellSize;\n\n    public void Execute(int index)\n    {\n        float3 pos = Positions[index];\n        int hash = GetHash(pos);\n        HashMap.Add(hash, index);\n    }\n\n    int GetHash(float3 pos)\n    {\n        int x = (int)math.floor(pos.x / CellSize);\n        int y = (int)math.floor(pos.y / CellSize);\n        int z = (int)math.floor(pos.z / CellSize);\n        return x * 73856093 ^ y * 19349663 ^ z * 83492791;\n    }\n}\n\n[BurstCompile]\npublic partial struct SpatialHashSystem : ISystem\n{\n    private NativeParallelMultiHashMap<int, int> _hashMap;\n\n    public void OnCreate(ref SystemState state)\n    {\n        _hashMap = new NativeParallelMultiHashMap<int, int>(10000, Allocator.Persistent);\n    }\n\n    public void OnDestroy(ref SystemState state)\n    {\n        _hashMap.Dispose();\n    }\n\n    [BurstCompile]\n    public void OnUpdate(ref SystemState state)\n    {\n        var query = SystemAPI.QueryBuilder()\n            .WithAll<LocalTransform>()\n            .Build();\n\n        int count = query.CalculateEntityCount();\n\n        // Resize if needed\n        if (_hashMap.Capacity < count)\n        {\n            _hashMap.Capacity = count * 2;\n        }\n\n        _hashMap.Clear();\n\n        // Get positions\n        var positions = query.ToComponentDataArray<LocalTransform>(Allocator.TempJob);\n        var posFloat3 = new NativeArray<float3>(count, Allocator.TempJob);\n\n        for (int i = 0; i < count; i++)\n        {\n            posFloat3[i] = positions[i].Position;\n        }\n\n        // Build hash map\n        var hashJob = new SpatialHashJob\n        {\n            Positions = posFloat3,\n            HashMap = _hashMap.AsParallelWriter(),\n            CellSize = 10f\n        };\n\n        state.Dependency = hashJob.Schedule(count, 64, state.Dependency);\n\n        // Cleanup\n        positions.Dispose(state.Dependency);\n        posFloat3.Dispose(state.Dependency);\n    }\n}\n```\n\n## Performance Tips\n\n```csharp\n// 1. Use Burst everywhere\n[BurstCompile]\npublic partial struct MySystem : ISystem { }\n\n// 2. Prefer IJobEntity over manual iteration\n[BurstCompile]\npartial struct OptimizedJob : IJobEntity\n{\n    void Execute(ref LocalTransform transform) { }\n}\n\n// 3. Schedule parallel when possible\nstate.Dependency = job.ScheduleParallel(state.Dependency);\n\n// 4. Use ScheduleParallel with chunk iteration\n[BurstCompile]\npartial struct ChunkJob : IJobChunk\n{\n    public ComponentTypeHandle<Health> HealthHandle;\n\n    public void Execute(in ArchetypeChunk chunk, int unfilteredChunkIndex,\n        bool useEnabledMask, in v128 chunkEnabledMask)\n    {\n        var healths = chunk.GetNativeArray(ref HealthHandle);\n        for (int i = 0; i < chunk.Count; i++)\n        {\n            // Process\n        }\n    }\n}\n\n// 5. Avoid structural changes in hot paths\n// Use enableable components instead of add/remove\npublic struct Disabled : IComponentData, IEnableableComponent { }\n```\n\n## Best Practices\n\n### Do's\n- **Use ISystem over SystemBase** - Better performance\n- **Burst compile everything** - Massive speedup\n- **Batch structural changes** - Use ECB\n- **Profile with Profiler** - Identify bottlenecks\n- **Use Aspects** - Clean component grouping\n\n### Don'ts\n- **Don't use managed types** - Breaks Burst\n- **Don't structural change in jobs** - Use ECB\n- **Don't over-architect** - Start simple\n- **Don't ignore chunk utilization** - Group similar entities\n- **Don't forget disposal** - Native collections leak\n\n## Resources\n\n- [Unity DOTS Documentation](https://docs.unity3d.com/Packages/com.unity.entities@latest)\n- [Unity DOTS Samples](https://github.com/Unity-Technologies/EntityComponentSystemSamples)\n- [Burst User Guide](https://docs.unity3d.com/Packages/com.unity.burst@latest)\n"
}