{
  "id": "security_scanning_attack_tree_construction",
  "name": "attack-tree-construction",
  "source": "security-scanning",
  "originalPath": "plugins/security-scanning/skills/attack-tree-construction/SKILL.md",
  "activationCriteria": "Build comprehensive attack trees to visualize threat paths. Use when mapping attack scenarios, identifying defense gaps, or communicating security risks to stakeholders.",
  "tier1_metadata": "attack-tree-construction: Build comprehensive attack trees to visualize threat paths. Use when mapping attack scenarios, ident",
  "tier2_instructions": "# Attack Tree Construction\n\nSystematic attack path visualization and analysis.\n\n## When to Use This Skill\n\n- Visualizing complex attack scenarios\n- Identifying defense gaps and priorities\n- Communicating risks to stakeholders\n- Planning defensive investments\n- Penetration test planning\n- Security architecture review\n\n## Core Concepts\n\n### 1. Attack Tree Structure\n\n```\n                    [Root Goal]\n                         |\n            \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n            \u2502                         \u2502\n       [Sub-goal 1]              [Sub-goal 2]\n       (OR node)                 (AND node)\n            \u2502                         \u2502\n      \u250c\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2510             \u250c\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2510\n      \u2502           \u2502             \u2502           \u2502\n   [Attack]   [Attack]      [Attack]   [Attack]\n    (leaf)     (leaf)        (leaf)     (leaf)\n```\n\n### 2. Node Types\n\n| Type | Symbol | Description |\n|------|--------|-------------|\n| **OR** | Oval | Any child achieves goal |\n| **AND** | Rectangle | All children required |\n| **Leaf** | Box | Atomic attack step |\n\n### 3. Attack Attributes\n\n| Attribute | Description | Values |\n|-----------|-------------|--------|\n| **Cost** | Resources needed | $, $$, $$$ |\n| **Time** | Duration to execute | Hours, Days, Weeks |\n| **Skill** | Expertise required | Low, Medium, High |\n| **Detection** | Likelihood of detection | Low, Medium, High |\n\n## Templates\n\n### Template 1: Attack Tree Data Model\n\n```python\nfrom dataclasses import dataclass, field\nfrom enum import Enum\nfrom typing import List, Dict, Optional, Union\nimport json\n\nclass NodeType(Enum):\n    OR = \"or\"\n    AND = \"and\"\n    LEAF = \"leaf\"\n\n\nclass Difficulty(Enum):\n    TRIVIAL = 1\n    LOW = 2\n    MEDIUM = 3\n    HIGH = 4\n    EXPERT = 5\n\n\nclass Cost(Enum):\n    FREE = 0\n    LOW = 1\n    MEDIUM = 2\n    HIGH = 3\n    VERY_HIGH = 4\n\n\nclass DetectionRisk(Enum):\n    NONE = 0\n    LOW = 1\n    MEDIUM = 2\n    HIGH = 3\n    CERTAIN = 4\n\n\n@dataclass\nclass AttackAttributes:\n    difficulty: Difficulty = Difficulty.MEDIUM\n    ",
  "tier3_resources": "cost: Cost = Cost.MEDIUM\n    detection_risk: DetectionRisk = DetectionRisk.MEDIUM\n    time_hours: float = 8.0\n    requires_insider: bool = False\n    requires_physical: bool = False\n\n\n@dataclass\nclass AttackNode:\n    id: str\n    name: str\n    description: str\n    node_type: NodeType\n    attributes: AttackAttributes = field(default_factory=AttackAttributes)\n    children: List['AttackNode'] = field(default_factory=list)\n    mitigations: List[str] = field(default_factory=list)\n    cve_refs: List[str] = field(default_factory=list)\n\n    def add_child(self, child: 'AttackNode') -> None:\n        self.children.append(child)\n\n    def calculate_path_difficulty(self) -> float:\n        \"\"\"Calculate aggregate difficulty for this path.\"\"\"\n        if self.node_type == NodeType.LEAF:\n            return self.attributes.difficulty.value\n\n        if not self.children:\n            return 0\n\n        child_difficulties = [c.calculate_path_difficulty() for c in self.children]\n\n        if self.node_type == NodeType.OR:\n            return min(child_difficulties)\n        else:  # AND\n            return max(child_difficulties)\n\n    def calculate_path_cost(self) -> float:\n        \"\"\"Calculate aggregate cost for this path.\"\"\"\n        if self.node_type == NodeType.LEAF:\n            return self.attributes.cost.value\n\n        if not self.children:\n            return 0\n\n        child_costs = [c.calculate_path_cost() for c in self.children]\n\n        if self.node_type == NodeType.OR:\n            return min(child_costs)\n        else:  # AND\n            return sum(child_costs)\n\n    def to_dict(self) -> Dict:\n        \"\"\"Convert to dictionary for serialization.\"\"\"\n        return {\n            \"id\": self.id,\n            \"name\": self.name,\n            \"description\": self.description,\n            \"type\": self.node_type.value,\n            \"attributes\": {\n                \"difficulty\": self.attributes.difficulty.name,\n                \"cost\": self.attributes.cost.name,\n                \"detection_risk\": self.attributes.detection_risk.name,\n                \"time_hours\": self.attributes.time_hours,\n            },\n            \"mitigations\": self.mitigations,\n            \"children\": [c.to_dict() for c in self.children]\n        }\n\n\n@dataclass\nclass AttackTree:\n    name: str\n    description: str\n    root: AttackNode\n    version: str = \"1.0\"\n\n    def find_easiest_path(self) -> List[AttackNode]:\n        \"\"\"Find the path with lowest difficulty.\"\"\"\n        return self._find_path(self.root, minimize=\"difficulty\")\n\n    def find_cheapest_path(self) -> List[AttackNode]:\n        \"\"\"Find the path with lowest cost.\"\"\"\n        return self._find_path(self.root, minimize=\"cost\")\n\n    def find_stealthiest_path(self) -> List[AttackNode]:\n        \"\"\"Find the path with lowest detection risk.\"\"\"\n        return self._find_path(self.root, minimize=\"detection\")\n\n    def _find_path(\n        self,\n        node: AttackNode,\n        minimize: str\n    ) -> List[AttackNode]:\n        \"\"\"Recursive path finding.\"\"\"\n        if nod",
  "tokenEstimate": {
    "tier1": 19.5,
    "tier2": 357.5,
    "tier3": 2158.0
  },
  "fullDefinition": "---\nname: attack-tree-construction\ndescription: Build comprehensive attack trees to visualize threat paths. Use when mapping attack scenarios, identifying defense gaps, or communicating security risks to stakeholders.\n---\n\n# Attack Tree Construction\n\nSystematic attack path visualization and analysis.\n\n## When to Use This Skill\n\n- Visualizing complex attack scenarios\n- Identifying defense gaps and priorities\n- Communicating risks to stakeholders\n- Planning defensive investments\n- Penetration test planning\n- Security architecture review\n\n## Core Concepts\n\n### 1. Attack Tree Structure\n\n```\n                    [Root Goal]\n                         |\n            \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n            \u2502                         \u2502\n       [Sub-goal 1]              [Sub-goal 2]\n       (OR node)                 (AND node)\n            \u2502                         \u2502\n      \u250c\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2510             \u250c\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2510\n      \u2502           \u2502             \u2502           \u2502\n   [Attack]   [Attack]      [Attack]   [Attack]\n    (leaf)     (leaf)        (leaf)     (leaf)\n```\n\n### 2. Node Types\n\n| Type | Symbol | Description |\n|------|--------|-------------|\n| **OR** | Oval | Any child achieves goal |\n| **AND** | Rectangle | All children required |\n| **Leaf** | Box | Atomic attack step |\n\n### 3. Attack Attributes\n\n| Attribute | Description | Values |\n|-----------|-------------|--------|\n| **Cost** | Resources needed | $, $$, $$$ |\n| **Time** | Duration to execute | Hours, Days, Weeks |\n| **Skill** | Expertise required | Low, Medium, High |\n| **Detection** | Likelihood of detection | Low, Medium, High |\n\n## Templates\n\n### Template 1: Attack Tree Data Model\n\n```python\nfrom dataclasses import dataclass, field\nfrom enum import Enum\nfrom typing import List, Dict, Optional, Union\nimport json\n\nclass NodeType(Enum):\n    OR = \"or\"\n    AND = \"and\"\n    LEAF = \"leaf\"\n\n\nclass Difficulty(Enum):\n    TRIVIAL = 1\n    LOW = 2\n    MEDIUM = 3\n    HIGH = 4\n    EXPERT = 5\n\n\nclass Cost(Enum):\n    FREE = 0\n    LOW = 1\n    MEDIUM = 2\n    HIGH = 3\n    VERY_HIGH = 4\n\n\nclass DetectionRisk(Enum):\n    NONE = 0\n    LOW = 1\n    MEDIUM = 2\n    HIGH = 3\n    CERTAIN = 4\n\n\n@dataclass\nclass AttackAttributes:\n    difficulty: Difficulty = Difficulty.MEDIUM\n    cost: Cost = Cost.MEDIUM\n    detection_risk: DetectionRisk = DetectionRisk.MEDIUM\n    time_hours: float = 8.0\n    requires_insider: bool = False\n    requires_physical: bool = False\n\n\n@dataclass\nclass AttackNode:\n    id: str\n    name: str\n    description: str\n    node_type: NodeType\n    attributes: AttackAttributes = field(default_factory=AttackAttributes)\n    children: List['AttackNode'] = field(default_factory=list)\n    mitigations: List[str] = field(default_factory=list)\n    cve_refs: List[str] = field(default_factory=list)\n\n    def add_child(self, child: 'AttackNode') -> None:\n        self.children.append(child)\n\n    def calculate_path_difficulty(self) -> float:\n        \"\"\"Calculate aggregate difficulty for this path.\"\"\"\n        if self.node_type == NodeType.LEAF:\n            return self.attributes.difficulty.value\n\n        if not self.children:\n            return 0\n\n        child_difficulties = [c.calculate_path_difficulty() for c in self.children]\n\n        if self.node_type == NodeType.OR:\n            return min(child_difficulties)\n        else:  # AND\n            return max(child_difficulties)\n\n    def calculate_path_cost(self) -> float:\n        \"\"\"Calculate aggregate cost for this path.\"\"\"\n        if self.node_type == NodeType.LEAF:\n            return self.attributes.cost.value\n\n        if not self.children:\n            return 0\n\n        child_costs = [c.calculate_path_cost() for c in self.children]\n\n        if self.node_type == NodeType.OR:\n            return min(child_costs)\n        else:  # AND\n            return sum(child_costs)\n\n    def to_dict(self) -> Dict:\n        \"\"\"Convert to dictionary for serialization.\"\"\"\n        return {\n            \"id\": self.id,\n            \"name\": self.name,\n            \"description\": self.description,\n            \"type\": self.node_type.value,\n            \"attributes\": {\n                \"difficulty\": self.attributes.difficulty.name,\n                \"cost\": self.attributes.cost.name,\n                \"detection_risk\": self.attributes.detection_risk.name,\n                \"time_hours\": self.attributes.time_hours,\n            },\n            \"mitigations\": self.mitigations,\n            \"children\": [c.to_dict() for c in self.children]\n        }\n\n\n@dataclass\nclass AttackTree:\n    name: str\n    description: str\n    root: AttackNode\n    version: str = \"1.0\"\n\n    def find_easiest_path(self) -> List[AttackNode]:\n        \"\"\"Find the path with lowest difficulty.\"\"\"\n        return self._find_path(self.root, minimize=\"difficulty\")\n\n    def find_cheapest_path(self) -> List[AttackNode]:\n        \"\"\"Find the path with lowest cost.\"\"\"\n        return self._find_path(self.root, minimize=\"cost\")\n\n    def find_stealthiest_path(self) -> List[AttackNode]:\n        \"\"\"Find the path with lowest detection risk.\"\"\"\n        return self._find_path(self.root, minimize=\"detection\")\n\n    def _find_path(\n        self,\n        node: AttackNode,\n        minimize: str\n    ) -> List[AttackNode]:\n        \"\"\"Recursive path finding.\"\"\"\n        if node.node_type == NodeType.LEAF:\n            return [node]\n\n        if not node.children:\n            return [node]\n\n        if node.node_type == NodeType.OR:\n            # Pick the best child path\n            best_path = None\n            best_score = float('inf')\n\n            for child in node.children:\n                child_path = self._find_path(child, minimize)\n                score = self._path_score(child_path, minimize)\n                if score < best_score:\n                    best_score = score\n                    best_path = child_path\n\n            return [node] + (best_path or [])\n        else:  # AND\n            # Must traverse all children\n            path = [node]\n            for child in node.children:\n                path.extend(self._find_path(child, minimize))\n            return path\n\n    def _path_score(self, path: List[AttackNode], metric: str) -> float:\n        \"\"\"Calculate score for a path.\"\"\"\n        if metric == \"difficulty\":\n            return sum(n.attributes.difficulty.value for n in path if n.node_type == NodeType.LEAF)\n        elif metric == \"cost\":\n            return sum(n.attributes.cost.value for n in path if n.node_type == NodeType.LEAF)\n        elif metric == \"detection\":\n            return sum(n.attributes.detection_risk.value for n in path if n.node_type == NodeType.LEAF)\n        return 0\n\n    def get_all_leaf_attacks(self) -> List[AttackNode]:\n        \"\"\"Get all leaf attack nodes.\"\"\"\n        leaves = []\n        self._collect_leaves(self.root, leaves)\n        return leaves\n\n    def _collect_leaves(self, node: AttackNode, leaves: List[AttackNode]) -> None:\n        if node.node_type == NodeType.LEAF:\n            leaves.append(node)\n        for child in node.children:\n            self._collect_leaves(child, leaves)\n\n    def get_unmitigated_attacks(self) -> List[AttackNode]:\n        \"\"\"Find attacks without mitigations.\"\"\"\n        return [n for n in self.get_all_leaf_attacks() if not n.mitigations]\n\n    def export_json(self) -> str:\n        \"\"\"Export tree to JSON.\"\"\"\n        return json.dumps({\n            \"name\": self.name,\n            \"description\": self.description,\n            \"version\": self.version,\n            \"root\": self.root.to_dict()\n        }, indent=2)\n```\n\n### Template 2: Attack Tree Builder\n\n```python\nclass AttackTreeBuilder:\n    \"\"\"Fluent builder for attack trees.\"\"\"\n\n    def __init__(self, name: str, description: str):\n        self.name = name\n        self.description = description\n        self._node_stack: List[AttackNode] = []\n        self._root: Optional[AttackNode] = None\n\n    def goal(self, id: str, name: str, description: str = \"\") -> 'AttackTreeBuilder':\n        \"\"\"Set the root goal (OR node by default).\"\"\"\n        self._root = AttackNode(\n            id=id,\n            name=name,\n            description=description,\n            node_type=NodeType.OR\n        )\n        self._node_stack = [self._root]\n        return self\n\n    def or_node(self, id: str, name: str, description: str = \"\") -> 'AttackTreeBuilder':\n        \"\"\"Add an OR sub-goal.\"\"\"\n        node = AttackNode(\n            id=id,\n            name=name,\n            description=description,\n            node_type=NodeType.OR\n        )\n        self._current().add_child(node)\n        self._node_stack.append(node)\n        return self\n\n    def and_node(self, id: str, name: str, description: str = \"\") -> 'AttackTreeBuilder':\n        \"\"\"Add an AND sub-goal (all children required).\"\"\"\n        node = AttackNode(\n            id=id,\n            name=name,\n            description=description,\n            node_type=NodeType.AND\n        )\n        self._current().add_child(node)\n        self._node_stack.append(node)\n        return self\n\n    def attack(\n        self,\n        id: str,\n        name: str,\n        description: str = \"\",\n        difficulty: Difficulty = Difficulty.MEDIUM,\n        cost: Cost = Cost.MEDIUM,\n        detection: DetectionRisk = DetectionRisk.MEDIUM,\n        time_hours: float = 8.0,\n        mitigations: List[str] = None\n    ) -> 'AttackTreeBuilder':\n        \"\"\"Add a leaf attack node.\"\"\"\n        node = AttackNode(\n            id=id,\n            name=name,\n            description=description,\n            node_type=NodeType.LEAF,\n            attributes=AttackAttributes(\n                difficulty=difficulty,\n                cost=cost,\n                detection_risk=detection,\n                time_hours=time_hours\n            ),\n            mitigations=mitigations or []\n        )\n        self._current().add_child(node)\n        return self\n\n    def end(self) -> 'AttackTreeBuilder':\n        \"\"\"Close current node, return to parent.\"\"\"\n        if len(self._node_stack) > 1:\n            self._node_stack.pop()\n        return self\n\n    def build(self) -> AttackTree:\n        \"\"\"Build the attack tree.\"\"\"\n        if not self._root:\n            raise ValueError(\"No root goal defined\")\n        return AttackTree(\n            name=self.name,\n            description=self.description,\n            root=self._root\n        )\n\n    def _current(self) -> AttackNode:\n        if not self._node_stack:\n            raise ValueError(\"No current node\")\n        return self._node_stack[-1]\n\n\n# Example usage\ndef build_account_takeover_tree() -> AttackTree:\n    \"\"\"Build attack tree for account takeover scenario.\"\"\"\n    return (\n        AttackTreeBuilder(\"Account Takeover\", \"Gain unauthorized access to user account\")\n        .goal(\"G1\", \"Take Over User Account\")\n\n        .or_node(\"S1\", \"Steal Credentials\")\n            .attack(\n                \"A1\", \"Phishing Attack\",\n                difficulty=Difficulty.LOW,\n                cost=Cost.LOW,\n                detection=DetectionRisk.MEDIUM,\n                mitigations=[\"Security awareness training\", \"Email filtering\"]\n            )\n            .attack(\n                \"A2\", \"Credential Stuffing\",\n                difficulty=Difficulty.TRIVIAL,\n                cost=Cost.LOW,\n                detection=DetectionRisk.HIGH,\n                mitigations=[\"Rate limiting\", \"MFA\", \"Password breach monitoring\"]\n            )\n            .attack(\n                \"A3\", \"Keylogger Malware\",\n                difficulty=Difficulty.MEDIUM,\n                cost=Cost.MEDIUM,\n                detection=DetectionRisk.MEDIUM,\n                mitigations=[\"Endpoint protection\", \"MFA\"]\n            )\n        .end()\n\n        .or_node(\"S2\", \"Bypass Authentication\")\n            .attack(\n                \"A4\", \"Session Hijacking\",\n                difficulty=Difficulty.MEDIUM,\n                cost=Cost.LOW,\n                detection=DetectionRisk.LOW,\n                mitigations=[\"Secure session management\", \"HTTPS only\"]\n            )\n            .attack(\n                \"A5\", \"Authentication Bypass Vulnerability\",\n                difficulty=Difficulty.HIGH,\n                cost=Cost.LOW,\n                detection=DetectionRisk.LOW,\n                mitigations=[\"Security testing\", \"Code review\", \"WAF\"]\n            )\n        .end()\n\n        .or_node(\"S3\", \"Social Engineering\")\n            .and_node(\"S3.1\", \"Account Recovery Attack\")\n                .attack(\n                    \"A6\", \"Gather Personal Information\",\n                    difficulty=Difficulty.LOW,\n                    cost=Cost.FREE,\n                    detection=DetectionRisk.NONE\n                )\n                .attack(\n                    \"A7\", \"Call Support Desk\",\n                    difficulty=Difficulty.MEDIUM,\n                    cost=Cost.FREE,\n                    detection=DetectionRisk.MEDIUM,\n                    mitigations=[\"Support verification procedures\", \"Security questions\"]\n                )\n            .end()\n        .end()\n\n        .build()\n    )\n```\n\n### Template 3: Mermaid Diagram Generator\n\n```python\nclass MermaidExporter:\n    \"\"\"Export attack trees to Mermaid diagram format.\"\"\"\n\n    def __init__(self, tree: AttackTree):\n        self.tree = tree\n        self._lines: List[str] = []\n        self._node_count = 0\n\n    def export(self) -> str:\n        \"\"\"Export tree to Mermaid flowchart.\"\"\"\n        self._lines = [\"flowchart TD\"]\n        self._export_node(self.tree.root, None)\n        return \"\\n\".join(self._lines)\n\n    def _export_node(self, node: AttackNode, parent_id: Optional[str]) -> str:\n        \"\"\"Recursively export nodes.\"\"\"\n        node_id = f\"N{self._node_count}\"\n        self._node_count += 1\n\n        # Node shape based on type\n        if node.node_type == NodeType.OR:\n            shape = f\"{node_id}(({node.name}))\"\n        elif node.node_type == NodeType.AND:\n            shape = f\"{node_id}[{node.name}]\"\n        else:  # LEAF\n            # Color based on difficulty\n            style = self._get_leaf_style(node)\n            shape = f\"{node_id}[/{node.name}/]\"\n            self._lines.append(f\"    style {node_id} {style}\")\n\n        self._lines.append(f\"    {shape}\")\n\n        if parent_id:\n            connector = \"-->\" if node.node_type != NodeType.AND else \"==>\"\n            self._lines.append(f\"    {parent_id} {connector} {node_id}\")\n\n        for child in node.children:\n            self._export_node(child, node_id)\n\n        return node_id\n\n    def _get_leaf_style(self, node: AttackNode) -> str:\n        \"\"\"Get style based on attack attributes.\"\"\"\n        colors = {\n            Difficulty.TRIVIAL: \"fill:#ff6b6b\",  # Red - easy attack\n            Difficulty.LOW: \"fill:#ffa06b\",\n            Difficulty.MEDIUM: \"fill:#ffd93d\",\n            Difficulty.HIGH: \"fill:#6bcb77\",\n            Difficulty.EXPERT: \"fill:#4d96ff\",  # Blue - hard attack\n        }\n        color = colors.get(node.attributes.difficulty, \"fill:#gray\")\n        return color\n\n\nclass PlantUMLExporter:\n    \"\"\"Export attack trees to PlantUML format.\"\"\"\n\n    def __init__(self, tree: AttackTree):\n        self.tree = tree\n\n    def export(self) -> str:\n        \"\"\"Export tree to PlantUML.\"\"\"\n        lines = [\n            \"@startmindmap\",\n            f\"* {self.tree.name}\",\n        ]\n        self._export_node(self.tree.root, lines, 1)\n        lines.append(\"@endmindmap\")\n        return \"\\n\".join(lines)\n\n    def _export_node(self, node: AttackNode, lines: List[str], depth: int) -> None:\n        \"\"\"Recursively export nodes.\"\"\"\n        prefix = \"*\" * (depth + 1)\n\n        if node.node_type == NodeType.OR:\n            marker = \"[OR]\"\n        elif node.node_type == NodeType.AND:\n            marker = \"[AND]\"\n        else:\n            diff = node.attributes.difficulty.name\n            marker = f\"<<{diff}>>\"\n\n        lines.append(f\"{prefix} {marker} {node.name}\")\n\n        for child in node.children:\n            self._export_node(child, lines, depth + 1)\n```\n\n### Template 4: Attack Path Analysis\n\n```python\nfrom typing import Set, Tuple\n\nclass AttackPathAnalyzer:\n    \"\"\"Analyze attack paths and coverage.\"\"\"\n\n    def __init__(self, tree: AttackTree):\n        self.tree = tree\n\n    def get_all_paths(self) -> List[List[AttackNode]]:\n        \"\"\"Get all possible attack paths.\"\"\"\n        paths = []\n        self._collect_paths(self.tree.root, [], paths)\n        return paths\n\n    def _collect_paths(\n        self,\n        node: AttackNode,\n        current_path: List[AttackNode],\n        all_paths: List[List[AttackNode]]\n    ) -> None:\n        \"\"\"Recursively collect all paths.\"\"\"\n        current_path = current_path + [node]\n\n        if node.node_type == NodeType.LEAF:\n            all_paths.append(current_path)\n            return\n\n        if not node.children:\n            all_paths.append(current_path)\n            return\n\n        if node.node_type == NodeType.OR:\n            # Each child is a separate path\n            for child in node.children:\n                self._collect_paths(child, current_path, all_paths)\n        else:  # AND\n            # Must combine all children\n            child_paths = []\n            for child in node.children:\n                child_sub_paths = []\n                self._collect_paths(child, [], child_sub_paths)\n                child_paths.append(child_sub_paths)\n\n            # Combine paths from all AND children\n            combined = self._combine_and_paths(child_paths)\n            for combo in combined:\n                all_paths.append(current_path + combo)\n\n    def _combine_and_paths(\n        self,\n        child_paths: List[List[List[AttackNode]]]\n    ) -> List[List[AttackNode]]:\n        \"\"\"Combine paths from AND node children.\"\"\"\n        if not child_paths:\n            return [[]]\n\n        if len(child_paths) == 1:\n            return [path for paths in child_paths for path in paths]\n\n        # Cartesian product of all child path combinations\n        result = [[]]\n        for paths in child_paths:\n            new_result = []\n            for existing in result:\n                for path in paths:\n                    new_result.append(existing + path)\n            result = new_result\n        return result\n\n    def calculate_path_metrics(self, path: List[AttackNode]) -> Dict:\n        \"\"\"Calculate metrics for a specific path.\"\"\"\n        leaves = [n for n in path if n.node_type == NodeType.LEAF]\n\n        total_difficulty = sum(n.attributes.difficulty.value for n in leaves)\n        total_cost = sum(n.attributes.cost.value for n in leaves)\n        total_time = sum(n.attributes.time_hours for n in leaves)\n        max_detection = max((n.attributes.detection_risk.value for n in leaves), default=0)\n\n        return {\n            \"steps\": len(leaves),\n            \"total_difficulty\": total_difficulty,\n            \"avg_difficulty\": total_difficulty / len(leaves) if leaves else 0,\n            \"total_cost\": total_cost,\n            \"total_time_hours\": total_time,\n            \"max_detection_risk\": max_detection,\n            \"requires_insider\": any(n.attributes.requires_insider for n in leaves),\n            \"requires_physical\": any(n.attributes.requires_physical for n in leaves),\n        }\n\n    def identify_critical_nodes(self) -> List[Tuple[AttackNode, int]]:\n        \"\"\"Find nodes that appear in the most paths.\"\"\"\n        paths = self.get_all_paths()\n        node_counts: Dict[str, Tuple[AttackNode, int]] = {}\n\n        for path in paths:\n            for node in path:\n                if node.id not in node_counts:\n                    node_counts[node.id] = (node, 0)\n                node_counts[node.id] = (node, node_counts[node.id][1] + 1)\n\n        return sorted(\n            node_counts.values(),\n            key=lambda x: x[1],\n            reverse=True\n        )\n\n    def coverage_analysis(self, mitigated_attacks: Set[str]) -> Dict:\n        \"\"\"Analyze how mitigations affect attack coverage.\"\"\"\n        all_paths = self.get_all_paths()\n        blocked_paths = []\n        open_paths = []\n\n        for path in all_paths:\n            path_attacks = {n.id for n in path if n.node_type == NodeType.LEAF}\n            if path_attacks & mitigated_attacks:\n                blocked_paths.append(path)\n            else:\n                open_paths.append(path)\n\n        return {\n            \"total_paths\": len(all_paths),\n            \"blocked_paths\": len(blocked_paths),\n            \"open_paths\": len(open_paths),\n            \"coverage_percentage\": len(blocked_paths) / len(all_paths) * 100 if all_paths else 0,\n            \"open_path_details\": [\n                {\"path\": [n.name for n in p], \"metrics\": self.calculate_path_metrics(p)}\n                for p in open_paths[:5]  # Top 5 open paths\n            ]\n        }\n\n    def prioritize_mitigations(self) -> List[Dict]:\n        \"\"\"Prioritize mitigations by impact.\"\"\"\n        critical_nodes = self.identify_critical_nodes()\n        paths = self.get_all_paths()\n        total_paths = len(paths)\n\n        recommendations = []\n        for node, count in critical_nodes:\n            if node.node_type == NodeType.LEAF and node.mitigations:\n                recommendations.append({\n                    \"attack\": node.name,\n                    \"attack_id\": node.id,\n                    \"paths_blocked\": count,\n                    \"coverage_impact\": count / total_paths * 100,\n                    \"difficulty\": node.attributes.difficulty.name,\n                    \"mitigations\": node.mitigations,\n                })\n\n        return sorted(recommendations, key=lambda x: x[\"coverage_impact\"], reverse=True)\n```\n\n## Best Practices\n\n### Do's\n- **Start with clear goals** - Define what attacker wants\n- **Be exhaustive** - Consider all attack vectors\n- **Attribute attacks** - Cost, skill, and detection\n- **Update regularly** - New threats emerge\n- **Validate with experts** - Red team review\n\n### Don'ts\n- **Don't oversimplify** - Real attacks are complex\n- **Don't ignore dependencies** - AND nodes matter\n- **Don't forget insider threats** - Not all attackers are external\n- **Don't skip mitigations** - Trees are for defense planning\n- **Don't make it static** - Threat landscape evolves\n\n## Resources\n\n- [Attack Trees by Bruce Schneier](https://www.schneier.com/academic/archives/1999/12/attack_trees.html)\n- [MITRE ATT&CK Framework](https://attack.mitre.org/)\n- [OWASP Attack Surface Analysis](https://owasp.org/www-community/controls/Attack_Surface_Analysis_Cheat_Sheet)\n"
}