{
  "id": "backend_development_projection_patterns",
  "name": "projection-patterns",
  "source": "backend-development",
  "originalPath": "plugins/backend-development/skills/projection-patterns/SKILL.md",
  "activationCriteria": "Build read models and projections from event streams. Use when implementing CQRS read sides, building materialized views, or optimizing query performance in event-sourced systems.",
  "tier1_metadata": "projection-patterns: Build read models and projections from event streams. Use when implementing CQRS read sides, buildin",
  "tier2_instructions": "# Projection Patterns\n\nComprehensive guide to building projections and read models for event-sourced systems.\n\n## When to Use This Skill\n\n- Building CQRS read models\n- Creating materialized views from events\n- Optimizing query performance\n- Implementing real-time dashboards\n- Building search indexes from events\n- Aggregating data across streams\n\n## Core Concepts\n\n### 1. Projection Architecture\n\n```\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Event Store \u2502\u2500\u2500\u2500\u2500\u25ba\u2502 Projector   \u2502\u2500\u2500\u2500\u2500\u25ba\u2502 Read Model  \u2502\n\u2502             \u2502     \u2502             \u2502     \u2502 (Database)  \u2502\n\u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502     \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502     \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502\n\u2502 \u2502 Events  \u2502 \u2502     \u2502 \u2502 Handler \u2502 \u2502     \u2502 \u2502 Tables  \u2502 \u2502\n\u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502     \u2502 \u2502 Logic   \u2502 \u2502     \u2502 \u2502 Views   \u2502 \u2502\n\u2502             \u2502     \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502     \u2502 \u2502 Cache   \u2502 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n```\n\n### 2. Projection Types\n\n| Type | Description | Use Case |\n|------|-------------|----------|\n| **Live** | Real-time from subscription | Current state queries |\n| **Catchup** | Process historical events | Rebuilding read models |\n| **Persistent** | Stores checkpoint | Resume after restart |\n| **Inline** | Same transaction as write | Strong consistency |\n\n## Templates\n\n### Template 1: Basic Projector\n\n```python\nfrom abc import ABC, abstractmethod\nfrom dataclasses import dataclass\nfrom typing import Dict, Any, Callable, List\nimport asyncpg\n\n@dataclass\nclass Event:\n    stream_id: str\n    event_type: str\n    data: dict\n    version: int\n    global_position: int\n\n\nclass Projection(ABC):\n    \"\"\"Base class for projections.\"\"\"\n\n    @property\n    @abstractmethod\n    def name(self) -> str:\n        \"\"\"Unique projection name for checkpointing.\"\"\"\n        pass\n\n    @abstractmethod\n    def handles(self) -> List[str]:\n        \"\"\"List of event types this projection handles.\"\"\"\n        pass\n\n    @abstractmethod\n    async def apply(self, event: Event) -> None:\n        \"\"\"Apply event to the read model.\"\"\"\n        pass\n\n\nclass Projector:\n    \"\"\"Runs",
  "tier3_resources": " projections from event store.\"\"\"\n\n    def __init__(self, event_store, checkpoint_store):\n        self.event_store = event_store\n        self.checkpoint_store = checkpoint_store\n        self.projections: List[Projection] = []\n\n    def register(self, projection: Projection):\n        self.projections.append(projection)\n\n    async def run(self, batch_size: int = 100):\n        \"\"\"Run all projections continuously.\"\"\"\n        while True:\n            for projection in self.projections:\n                await self._run_projection(projection, batch_size)\n            await asyncio.sleep(0.1)\n\n    async def _run_projection(self, projection: Projection, batch_size: int):\n        checkpoint = await self.checkpoint_store.get(projection.name)\n        position = checkpoint or 0\n\n        events = await self.event_store.read_all(position, batch_size)\n\n        for event in events:\n            if event.event_type in projection.handles():\n                await projection.apply(event)\n\n            await self.checkpoint_store.save(\n                projection.name,\n                event.global_position\n            )\n\n    async def rebuild(self, projection: Projection):\n        \"\"\"Rebuild a projection from scratch.\"\"\"\n        await self.checkpoint_store.delete(projection.name)\n        # Optionally clear read model tables\n        await self._run_projection(projection, batch_size=1000)\n```\n\n### Template 2: Order Summary Projection\n\n```python\nclass OrderSummaryProjection(Projection):\n    \"\"\"Projects order events to a summary read model.\"\"\"\n\n    def __init__(self, db_pool: asyncpg.Pool):\n        self.pool = db_pool\n\n    @property\n    def name(self) -> str:\n        return \"order_summary\"\n\n    def handles(self) -> List[str]:\n        return [\n            \"OrderCreated\",\n            \"OrderItemAdded\",\n            \"OrderItemRemoved\",\n            \"OrderShipped\",\n            \"OrderCompleted\",\n            \"OrderCancelled\"\n        ]\n\n    async def apply(self, event: Event) -> None:\n        handlers = {\n            \"OrderCreated\": self._handle_created,\n            \"OrderItemAdded\": self._handle_item_added,\n            \"OrderItemRemoved\": self._handle_item_removed,\n            \"OrderShipped\": self._handle_shipped,\n            \"OrderCompleted\": self._handle_completed,\n            \"OrderCancelled\": self._handle_cancelled,\n        }\n\n        handler = handlers.get(event.event_type)\n        if handler:\n            await handler(event)\n\n    async def _handle_created(self, event: Event):\n        async with self.pool.acquire() as conn:\n            await conn.execute(\n                \"\"\"\n                INSERT INTO order_summaries\n                (order_id, customer_id, status, total_amount, item_count, created_at)\n                VALUES ($1, $2, $3, $4, $5, $6)\n                \"\"\",\n                event.data['order_id'],\n                event.data['customer_id'],\n                'pending',\n                0,\n                0,\n                event.data['created_at']\n            )\n\n    async de",
  "tokenEstimate": {
    "tier1": 20.8,
    "tier2": 353.6,
    "tier3": 1294.8
  },
  "fullDefinition": "---\nname: projection-patterns\ndescription: Build read models and projections from event streams. Use when implementing CQRS read sides, building materialized views, or optimizing query performance in event-sourced systems.\n---\n\n# Projection Patterns\n\nComprehensive guide to building projections and read models for event-sourced systems.\n\n## When to Use This Skill\n\n- Building CQRS read models\n- Creating materialized views from events\n- Optimizing query performance\n- Implementing real-time dashboards\n- Building search indexes from events\n- Aggregating data across streams\n\n## Core Concepts\n\n### 1. Projection Architecture\n\n```\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Event Store \u2502\u2500\u2500\u2500\u2500\u25ba\u2502 Projector   \u2502\u2500\u2500\u2500\u2500\u25ba\u2502 Read Model  \u2502\n\u2502             \u2502     \u2502             \u2502     \u2502 (Database)  \u2502\n\u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502     \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502     \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502\n\u2502 \u2502 Events  \u2502 \u2502     \u2502 \u2502 Handler \u2502 \u2502     \u2502 \u2502 Tables  \u2502 \u2502\n\u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502     \u2502 \u2502 Logic   \u2502 \u2502     \u2502 \u2502 Views   \u2502 \u2502\n\u2502             \u2502     \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502     \u2502 \u2502 Cache   \u2502 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n```\n\n### 2. Projection Types\n\n| Type | Description | Use Case |\n|------|-------------|----------|\n| **Live** | Real-time from subscription | Current state queries |\n| **Catchup** | Process historical events | Rebuilding read models |\n| **Persistent** | Stores checkpoint | Resume after restart |\n| **Inline** | Same transaction as write | Strong consistency |\n\n## Templates\n\n### Template 1: Basic Projector\n\n```python\nfrom abc import ABC, abstractmethod\nfrom dataclasses import dataclass\nfrom typing import Dict, Any, Callable, List\nimport asyncpg\n\n@dataclass\nclass Event:\n    stream_id: str\n    event_type: str\n    data: dict\n    version: int\n    global_position: int\n\n\nclass Projection(ABC):\n    \"\"\"Base class for projections.\"\"\"\n\n    @property\n    @abstractmethod\n    def name(self) -> str:\n        \"\"\"Unique projection name for checkpointing.\"\"\"\n        pass\n\n    @abstractmethod\n    def handles(self) -> List[str]:\n        \"\"\"List of event types this projection handles.\"\"\"\n        pass\n\n    @abstractmethod\n    async def apply(self, event: Event) -> None:\n        \"\"\"Apply event to the read model.\"\"\"\n        pass\n\n\nclass Projector:\n    \"\"\"Runs projections from event store.\"\"\"\n\n    def __init__(self, event_store, checkpoint_store):\n        self.event_store = event_store\n        self.checkpoint_store = checkpoint_store\n        self.projections: List[Projection] = []\n\n    def register(self, projection: Projection):\n        self.projections.append(projection)\n\n    async def run(self, batch_size: int = 100):\n        \"\"\"Run all projections continuously.\"\"\"\n        while True:\n            for projection in self.projections:\n                await self._run_projection(projection, batch_size)\n            await asyncio.sleep(0.1)\n\n    async def _run_projection(self, projection: Projection, batch_size: int):\n        checkpoint = await self.checkpoint_store.get(projection.name)\n        position = checkpoint or 0\n\n        events = await self.event_store.read_all(position, batch_size)\n\n        for event in events:\n            if event.event_type in projection.handles():\n                await projection.apply(event)\n\n            await self.checkpoint_store.save(\n                projection.name,\n                event.global_position\n            )\n\n    async def rebuild(self, projection: Projection):\n        \"\"\"Rebuild a projection from scratch.\"\"\"\n        await self.checkpoint_store.delete(projection.name)\n        # Optionally clear read model tables\n        await self._run_projection(projection, batch_size=1000)\n```\n\n### Template 2: Order Summary Projection\n\n```python\nclass OrderSummaryProjection(Projection):\n    \"\"\"Projects order events to a summary read model.\"\"\"\n\n    def __init__(self, db_pool: asyncpg.Pool):\n        self.pool = db_pool\n\n    @property\n    def name(self) -> str:\n        return \"order_summary\"\n\n    def handles(self) -> List[str]:\n        return [\n            \"OrderCreated\",\n            \"OrderItemAdded\",\n            \"OrderItemRemoved\",\n            \"OrderShipped\",\n            \"OrderCompleted\",\n            \"OrderCancelled\"\n        ]\n\n    async def apply(self, event: Event) -> None:\n        handlers = {\n            \"OrderCreated\": self._handle_created,\n            \"OrderItemAdded\": self._handle_item_added,\n            \"OrderItemRemoved\": self._handle_item_removed,\n            \"OrderShipped\": self._handle_shipped,\n            \"OrderCompleted\": self._handle_completed,\n            \"OrderCancelled\": self._handle_cancelled,\n        }\n\n        handler = handlers.get(event.event_type)\n        if handler:\n            await handler(event)\n\n    async def _handle_created(self, event: Event):\n        async with self.pool.acquire() as conn:\n            await conn.execute(\n                \"\"\"\n                INSERT INTO order_summaries\n                (order_id, customer_id, status, total_amount, item_count, created_at)\n                VALUES ($1, $2, $3, $4, $5, $6)\n                \"\"\",\n                event.data['order_id'],\n                event.data['customer_id'],\n                'pending',\n                0,\n                0,\n                event.data['created_at']\n            )\n\n    async def _handle_item_added(self, event: Event):\n        async with self.pool.acquire() as conn:\n            await conn.execute(\n                \"\"\"\n                UPDATE order_summaries\n                SET total_amount = total_amount + $2,\n                    item_count = item_count + 1,\n                    updated_at = NOW()\n                WHERE order_id = $1\n                \"\"\",\n                event.data['order_id'],\n                event.data['price'] * event.data['quantity']\n            )\n\n    async def _handle_item_removed(self, event: Event):\n        async with self.pool.acquire() as conn:\n            await conn.execute(\n                \"\"\"\n                UPDATE order_summaries\n                SET total_amount = total_amount - $2,\n                    item_count = item_count - 1,\n                    updated_at = NOW()\n                WHERE order_id = $1\n                \"\"\",\n                event.data['order_id'],\n                event.data['price'] * event.data['quantity']\n            )\n\n    async def _handle_shipped(self, event: Event):\n        async with self.pool.acquire() as conn:\n            await conn.execute(\n                \"\"\"\n                UPDATE order_summaries\n                SET status = 'shipped',\n                    shipped_at = $2,\n                    updated_at = NOW()\n                WHERE order_id = $1\n                \"\"\",\n                event.data['order_id'],\n                event.data['shipped_at']\n            )\n\n    async def _handle_completed(self, event: Event):\n        async with self.pool.acquire() as conn:\n            await conn.execute(\n                \"\"\"\n                UPDATE order_summaries\n                SET status = 'completed',\n                    completed_at = $2,\n                    updated_at = NOW()\n                WHERE order_id = $1\n                \"\"\",\n                event.data['order_id'],\n                event.data['completed_at']\n            )\n\n    async def _handle_cancelled(self, event: Event):\n        async with self.pool.acquire() as conn:\n            await conn.execute(\n                \"\"\"\n                UPDATE order_summaries\n                SET status = 'cancelled',\n                    cancelled_at = $2,\n                    cancellation_reason = $3,\n                    updated_at = NOW()\n                WHERE order_id = $1\n                \"\"\",\n                event.data['order_id'],\n                event.data['cancelled_at'],\n                event.data.get('reason')\n            )\n```\n\n### Template 3: Elasticsearch Search Projection\n\n```python\nfrom elasticsearch import AsyncElasticsearch\n\nclass ProductSearchProjection(Projection):\n    \"\"\"Projects product events to Elasticsearch for full-text search.\"\"\"\n\n    def __init__(self, es_client: AsyncElasticsearch):\n        self.es = es_client\n        self.index = \"products\"\n\n    @property\n    def name(self) -> str:\n        return \"product_search\"\n\n    def handles(self) -> List[str]:\n        return [\n            \"ProductCreated\",\n            \"ProductUpdated\",\n            \"ProductPriceChanged\",\n            \"ProductDeleted\"\n        ]\n\n    async def apply(self, event: Event) -> None:\n        if event.event_type == \"ProductCreated\":\n            await self.es.index(\n                index=self.index,\n                id=event.data['product_id'],\n                document={\n                    'name': event.data['name'],\n                    'description': event.data['description'],\n                    'category': event.data['category'],\n                    'price': event.data['price'],\n                    'tags': event.data.get('tags', []),\n                    'created_at': event.data['created_at']\n                }\n            )\n\n        elif event.event_type == \"ProductUpdated\":\n            await self.es.update(\n                index=self.index,\n                id=event.data['product_id'],\n                doc={\n                    'name': event.data['name'],\n                    'description': event.data['description'],\n                    'category': event.data['category'],\n                    'tags': event.data.get('tags', []),\n                    'updated_at': event.data['updated_at']\n                }\n            )\n\n        elif event.event_type == \"ProductPriceChanged\":\n            await self.es.update(\n                index=self.index,\n                id=event.data['product_id'],\n                doc={\n                    'price': event.data['new_price'],\n                    'price_updated_at': event.data['changed_at']\n                }\n            )\n\n        elif event.event_type == \"ProductDeleted\":\n            await self.es.delete(\n                index=self.index,\n                id=event.data['product_id']\n            )\n```\n\n### Template 4: Aggregating Projection\n\n```python\nclass DailySalesProjection(Projection):\n    \"\"\"Aggregates sales data by day for reporting.\"\"\"\n\n    def __init__(self, db_pool: asyncpg.Pool):\n        self.pool = db_pool\n\n    @property\n    def name(self) -> str:\n        return \"daily_sales\"\n\n    def handles(self) -> List[str]:\n        return [\"OrderCompleted\", \"OrderRefunded\"]\n\n    async def apply(self, event: Event) -> None:\n        if event.event_type == \"OrderCompleted\":\n            await self._increment_sales(event)\n        elif event.event_type == \"OrderRefunded\":\n            await self._decrement_sales(event)\n\n    async def _increment_sales(self, event: Event):\n        date = event.data['completed_at'][:10]  # YYYY-MM-DD\n        async with self.pool.acquire() as conn:\n            await conn.execute(\n                \"\"\"\n                INSERT INTO daily_sales (date, total_orders, total_revenue, total_items)\n                VALUES ($1, 1, $2, $3)\n                ON CONFLICT (date) DO UPDATE SET\n                    total_orders = daily_sales.total_orders + 1,\n                    total_revenue = daily_sales.total_revenue + $2,\n                    total_items = daily_sales.total_items + $3,\n                    updated_at = NOW()\n                \"\"\",\n                date,\n                event.data['total_amount'],\n                event.data['item_count']\n            )\n\n    async def _decrement_sales(self, event: Event):\n        date = event.data['original_completed_at'][:10]\n        async with self.pool.acquire() as conn:\n            await conn.execute(\n                \"\"\"\n                UPDATE daily_sales SET\n                    total_orders = total_orders - 1,\n                    total_revenue = total_revenue - $2,\n                    total_refunds = total_refunds + $2,\n                    updated_at = NOW()\n                WHERE date = $1\n                \"\"\",\n                date,\n                event.data['refund_amount']\n            )\n```\n\n### Template 5: Multi-Table Projection\n\n```python\nclass CustomerActivityProjection(Projection):\n    \"\"\"Projects customer activity across multiple tables.\"\"\"\n\n    def __init__(self, db_pool: asyncpg.Pool):\n        self.pool = db_pool\n\n    @property\n    def name(self) -> str:\n        return \"customer_activity\"\n\n    def handles(self) -> List[str]:\n        return [\n            \"CustomerCreated\",\n            \"OrderCompleted\",\n            \"ReviewSubmitted\",\n            \"CustomerTierChanged\"\n        ]\n\n    async def apply(self, event: Event) -> None:\n        async with self.pool.acquire() as conn:\n            async with conn.transaction():\n                if event.event_type == \"CustomerCreated\":\n                    # Insert into customers table\n                    await conn.execute(\n                        \"\"\"\n                        INSERT INTO customers (customer_id, email, name, tier, created_at)\n                        VALUES ($1, $2, $3, 'bronze', $4)\n                        \"\"\",\n                        event.data['customer_id'],\n                        event.data['email'],\n                        event.data['name'],\n                        event.data['created_at']\n                    )\n                    # Initialize activity summary\n                    await conn.execute(\n                        \"\"\"\n                        INSERT INTO customer_activity_summary\n                        (customer_id, total_orders, total_spent, total_reviews)\n                        VALUES ($1, 0, 0, 0)\n                        \"\"\",\n                        event.data['customer_id']\n                    )\n\n                elif event.event_type == \"OrderCompleted\":\n                    # Update activity summary\n                    await conn.execute(\n                        \"\"\"\n                        UPDATE customer_activity_summary SET\n                            total_orders = total_orders + 1,\n                            total_spent = total_spent + $2,\n                            last_order_at = $3\n                        WHERE customer_id = $1\n                        \"\"\",\n                        event.data['customer_id'],\n                        event.data['total_amount'],\n                        event.data['completed_at']\n                    )\n                    # Insert into order history\n                    await conn.execute(\n                        \"\"\"\n                        INSERT INTO customer_order_history\n                        (customer_id, order_id, amount, completed_at)\n                        VALUES ($1, $2, $3, $4)\n                        \"\"\",\n                        event.data['customer_id'],\n                        event.data['order_id'],\n                        event.data['total_amount'],\n                        event.data['completed_at']\n                    )\n\n                elif event.event_type == \"ReviewSubmitted\":\n                    await conn.execute(\n                        \"\"\"\n                        UPDATE customer_activity_summary SET\n                            total_reviews = total_reviews + 1,\n                            last_review_at = $2\n                        WHERE customer_id = $1\n                        \"\"\",\n                        event.data['customer_id'],\n                        event.data['submitted_at']\n                    )\n\n                elif event.event_type == \"CustomerTierChanged\":\n                    await conn.execute(\n                        \"\"\"\n                        UPDATE customers SET tier = $2, updated_at = NOW()\n                        WHERE customer_id = $1\n                        \"\"\",\n                        event.data['customer_id'],\n                        event.data['new_tier']\n                    )\n```\n\n## Best Practices\n\n### Do's\n- **Make projections idempotent** - Safe to replay\n- **Use transactions** - For multi-table updates\n- **Store checkpoints** - Resume after failures\n- **Monitor lag** - Alert on projection delays\n- **Plan for rebuilds** - Design for reconstruction\n\n### Don'ts\n- **Don't couple projections** - Each is independent\n- **Don't skip error handling** - Log and alert on failures\n- **Don't ignore ordering** - Events must be processed in order\n- **Don't over-normalize** - Denormalize for query patterns\n\n## Resources\n\n- [CQRS Pattern](https://docs.microsoft.com/en-us/azure/architecture/patterns/cqrs)\n- [Projection Building Blocks](https://zimarev.com/blog/event-sourcing/projections/)\n"
}