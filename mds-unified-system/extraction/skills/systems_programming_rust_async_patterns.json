{
  "id": "systems_programming_rust_async_patterns",
  "name": "rust-async-patterns",
  "source": "systems-programming",
  "originalPath": "plugins/systems-programming/skills/rust-async-patterns/SKILL.md",
  "activationCriteria": "Master Rust async programming with Tokio, async traits, error handling, and concurrent patterns. Use when building async Rust applications, implementing concurrent systems, or debugging async code.",
  "tier1_metadata": "rust-async-patterns: Master Rust async programming with Tokio, async traits, error handling, and concurrent patterns. Use",
  "tier2_instructions": "# Rust Async Patterns\n\nProduction patterns for async Rust programming with Tokio runtime, including tasks, channels, streams, and error handling.\n\n## When to Use This Skill\n\n- Building async Rust applications\n- Implementing concurrent network services\n- Using Tokio for async I/O\n- Handling async errors properly\n- Debugging async code issues\n- Optimizing async performance\n\n## Core Concepts\n\n### 1. Async Execution Model\n\n```\nFuture (lazy) \u2192 poll() \u2192 Ready(value) | Pending\n                \u2191           \u2193\n              Waker \u2190 Runtime schedules\n```\n\n### 2. Key Abstractions\n\n| Concept | Purpose |\n|---------|---------|\n| `Future` | Lazy computation that may complete later |\n| `async fn` | Function returning impl Future |\n| `await` | Suspend until future completes |\n| `Task` | Spawned future running concurrently |\n| `Runtime` | Executor that polls futures |\n\n## Quick Start\n\n```toml\n# Cargo.toml\n[dependencies]\ntokio = { version = \"1\", features = [\"full\"] }\nfutures = \"0.3\"\nasync-trait = \"0.1\"\nanyhow = \"1.0\"\ntracing = \"0.1\"\ntracing-subscriber = \"0.3\"\n```\n\n```rust\nuse tokio::time::{sleep, Duration};\nuse anyhow::Result;\n\n#[tokio::main]\nasync fn main() -> Result<()> {\n    // Initialize tracing\n    tracing_subscriber::fmt::init();\n\n    // Async operations\n    let result = fetch_data(\"https://api.example.com\").await?;\n    println!(\"Got: {}\", result);\n\n    Ok(())\n}\n\nasync fn fetch_data(url: &str) -> Result<String> {\n    // Simulated async operation\n    sleep(Duration::from_millis(100)).await;\n    Ok(format!(\"Data from {}\", url))\n}\n```\n\n## Patterns\n\n### Pattern 1: Concurrent Task Execution\n\n```rust\nuse tokio::task::JoinSet;\nuse anyhow::Result;\n\n// Spawn multiple concurrent tasks\nasync fn fetch_all_concurrent(urls: Vec<String>) -> Result<Vec<String>> {\n    let mut set = JoinSet::new();\n\n    for url in urls {\n        set.spawn(async move {\n            fetch_data(&url).await\n        });\n    }\n\n    let mut results = Vec::new();\n    while let Some(res) = set.join_next().await {\n        mat",
  "tier3_resources": "ch res {\n            Ok(Ok(data)) => results.push(data),\n            Ok(Err(e)) => tracing::error!(\"Task failed: {}\", e),\n            Err(e) => tracing::error!(\"Join error: {}\", e),\n        }\n    }\n\n    Ok(results)\n}\n\n// With concurrency limit\nuse futures::stream::{self, StreamExt};\n\nasync fn fetch_with_limit(urls: Vec<String>, limit: usize) -> Vec<Result<String>> {\n    stream::iter(urls)\n        .map(|url| async move { fetch_data(&url).await })\n        .buffer_unordered(limit) // Max concurrent tasks\n        .collect()\n        .await\n}\n\n// Select first to complete\nuse tokio::select;\n\nasync fn race_requests(url1: &str, url2: &str) -> Result<String> {\n    select! {\n        result = fetch_data(url1) => result,\n        result = fetch_data(url2) => result,\n    }\n}\n```\n\n### Pattern 2: Channels for Communication\n\n```rust\nuse tokio::sync::{mpsc, broadcast, oneshot, watch};\n\n// Multi-producer, single-consumer\nasync fn mpsc_example() {\n    let (tx, mut rx) = mpsc::channel::<String>(100);\n\n    // Spawn producer\n    let tx2 = tx.clone();\n    tokio::spawn(async move {\n        tx2.send(\"Hello\".to_string()).await.unwrap();\n    });\n\n    // Consume\n    while let Some(msg) = rx.recv().await {\n        println!(\"Got: {}\", msg);\n    }\n}\n\n// Broadcast: multi-producer, multi-consumer\nasync fn broadcast_example() {\n    let (tx, _) = broadcast::channel::<String>(100);\n\n    let mut rx1 = tx.subscribe();\n    let mut rx2 = tx.subscribe();\n\n    tx.send(\"Event\".to_string()).unwrap();\n\n    // Both receivers get the message\n    let _ = rx1.recv().await;\n    let _ = rx2.recv().await;\n}\n\n// Oneshot: single value, single use\nasync fn oneshot_example() -> String {\n    let (tx, rx) = oneshot::channel::<String>();\n\n    tokio::spawn(async move {\n        tx.send(\"Result\".to_string()).unwrap();\n    });\n\n    rx.await.unwrap()\n}\n\n// Watch: single producer, multi-consumer, latest value\nasync fn watch_example() {\n    let (tx, mut rx) = watch::channel(\"initial\".to_string());\n\n    tokio::spawn(async move {\n        loop {\n            // Wait for changes\n            rx.changed().await.unwrap();\n            println!(\"New value: {}\", *rx.borrow());\n        }\n    });\n\n    tx.send(\"updated\".to_string()).unwrap();\n}\n```\n\n### Pattern 3: Async Error Handling\n\n```rust\nuse anyhow::{Context, Result, bail};\nuse thiserror::Error;\n\n#[derive(Error, Debug)]\npub enum ServiceError {\n    #[error(\"Network error: {0}\")]\n    Network(#[from] reqwest::Error),\n\n    #[error(\"Database error: {0}\")]\n    Database(#[from] sqlx::Error),\n\n    #[error(\"Not found: {0}\")]\n    NotFound(String),\n\n    #[error(\"Timeout after {0:?}\")]\n    Timeout(std::time::Duration),\n}\n\n// Using anyhow for application errors\nasync fn process_request(id: &str) -> Result<Response> {\n    let data = fetch_data(id)\n        .await\n        .context(\"Failed to fetch data\")?;\n\n    let parsed = parse_response(&data)\n        .context(\"Failed to parse response\")?;\n\n    Ok(parsed)\n}\n\n// Using custom errors for library code\nasync fn get_user(id: &str) -> Result",
  "tokenEstimate": {
    "tier1": 19.5,
    "tier2": 345.8,
    "tier3": 1439.1000000000001
  },
  "fullDefinition": "---\nname: rust-async-patterns\ndescription: Master Rust async programming with Tokio, async traits, error handling, and concurrent patterns. Use when building async Rust applications, implementing concurrent systems, or debugging async code.\n---\n\n# Rust Async Patterns\n\nProduction patterns for async Rust programming with Tokio runtime, including tasks, channels, streams, and error handling.\n\n## When to Use This Skill\n\n- Building async Rust applications\n- Implementing concurrent network services\n- Using Tokio for async I/O\n- Handling async errors properly\n- Debugging async code issues\n- Optimizing async performance\n\n## Core Concepts\n\n### 1. Async Execution Model\n\n```\nFuture (lazy) \u2192 poll() \u2192 Ready(value) | Pending\n                \u2191           \u2193\n              Waker \u2190 Runtime schedules\n```\n\n### 2. Key Abstractions\n\n| Concept | Purpose |\n|---------|---------|\n| `Future` | Lazy computation that may complete later |\n| `async fn` | Function returning impl Future |\n| `await` | Suspend until future completes |\n| `Task` | Spawned future running concurrently |\n| `Runtime` | Executor that polls futures |\n\n## Quick Start\n\n```toml\n# Cargo.toml\n[dependencies]\ntokio = { version = \"1\", features = [\"full\"] }\nfutures = \"0.3\"\nasync-trait = \"0.1\"\nanyhow = \"1.0\"\ntracing = \"0.1\"\ntracing-subscriber = \"0.3\"\n```\n\n```rust\nuse tokio::time::{sleep, Duration};\nuse anyhow::Result;\n\n#[tokio::main]\nasync fn main() -> Result<()> {\n    // Initialize tracing\n    tracing_subscriber::fmt::init();\n\n    // Async operations\n    let result = fetch_data(\"https://api.example.com\").await?;\n    println!(\"Got: {}\", result);\n\n    Ok(())\n}\n\nasync fn fetch_data(url: &str) -> Result<String> {\n    // Simulated async operation\n    sleep(Duration::from_millis(100)).await;\n    Ok(format!(\"Data from {}\", url))\n}\n```\n\n## Patterns\n\n### Pattern 1: Concurrent Task Execution\n\n```rust\nuse tokio::task::JoinSet;\nuse anyhow::Result;\n\n// Spawn multiple concurrent tasks\nasync fn fetch_all_concurrent(urls: Vec<String>) -> Result<Vec<String>> {\n    let mut set = JoinSet::new();\n\n    for url in urls {\n        set.spawn(async move {\n            fetch_data(&url).await\n        });\n    }\n\n    let mut results = Vec::new();\n    while let Some(res) = set.join_next().await {\n        match res {\n            Ok(Ok(data)) => results.push(data),\n            Ok(Err(e)) => tracing::error!(\"Task failed: {}\", e),\n            Err(e) => tracing::error!(\"Join error: {}\", e),\n        }\n    }\n\n    Ok(results)\n}\n\n// With concurrency limit\nuse futures::stream::{self, StreamExt};\n\nasync fn fetch_with_limit(urls: Vec<String>, limit: usize) -> Vec<Result<String>> {\n    stream::iter(urls)\n        .map(|url| async move { fetch_data(&url).await })\n        .buffer_unordered(limit) // Max concurrent tasks\n        .collect()\n        .await\n}\n\n// Select first to complete\nuse tokio::select;\n\nasync fn race_requests(url1: &str, url2: &str) -> Result<String> {\n    select! {\n        result = fetch_data(url1) => result,\n        result = fetch_data(url2) => result,\n    }\n}\n```\n\n### Pattern 2: Channels for Communication\n\n```rust\nuse tokio::sync::{mpsc, broadcast, oneshot, watch};\n\n// Multi-producer, single-consumer\nasync fn mpsc_example() {\n    let (tx, mut rx) = mpsc::channel::<String>(100);\n\n    // Spawn producer\n    let tx2 = tx.clone();\n    tokio::spawn(async move {\n        tx2.send(\"Hello\".to_string()).await.unwrap();\n    });\n\n    // Consume\n    while let Some(msg) = rx.recv().await {\n        println!(\"Got: {}\", msg);\n    }\n}\n\n// Broadcast: multi-producer, multi-consumer\nasync fn broadcast_example() {\n    let (tx, _) = broadcast::channel::<String>(100);\n\n    let mut rx1 = tx.subscribe();\n    let mut rx2 = tx.subscribe();\n\n    tx.send(\"Event\".to_string()).unwrap();\n\n    // Both receivers get the message\n    let _ = rx1.recv().await;\n    let _ = rx2.recv().await;\n}\n\n// Oneshot: single value, single use\nasync fn oneshot_example() -> String {\n    let (tx, rx) = oneshot::channel::<String>();\n\n    tokio::spawn(async move {\n        tx.send(\"Result\".to_string()).unwrap();\n    });\n\n    rx.await.unwrap()\n}\n\n// Watch: single producer, multi-consumer, latest value\nasync fn watch_example() {\n    let (tx, mut rx) = watch::channel(\"initial\".to_string());\n\n    tokio::spawn(async move {\n        loop {\n            // Wait for changes\n            rx.changed().await.unwrap();\n            println!(\"New value: {}\", *rx.borrow());\n        }\n    });\n\n    tx.send(\"updated\".to_string()).unwrap();\n}\n```\n\n### Pattern 3: Async Error Handling\n\n```rust\nuse anyhow::{Context, Result, bail};\nuse thiserror::Error;\n\n#[derive(Error, Debug)]\npub enum ServiceError {\n    #[error(\"Network error: {0}\")]\n    Network(#[from] reqwest::Error),\n\n    #[error(\"Database error: {0}\")]\n    Database(#[from] sqlx::Error),\n\n    #[error(\"Not found: {0}\")]\n    NotFound(String),\n\n    #[error(\"Timeout after {0:?}\")]\n    Timeout(std::time::Duration),\n}\n\n// Using anyhow for application errors\nasync fn process_request(id: &str) -> Result<Response> {\n    let data = fetch_data(id)\n        .await\n        .context(\"Failed to fetch data\")?;\n\n    let parsed = parse_response(&data)\n        .context(\"Failed to parse response\")?;\n\n    Ok(parsed)\n}\n\n// Using custom errors for library code\nasync fn get_user(id: &str) -> Result<User, ServiceError> {\n    let result = db.query(id).await?;\n\n    match result {\n        Some(user) => Ok(user),\n        None => Err(ServiceError::NotFound(id.to_string())),\n    }\n}\n\n// Timeout wrapper\nuse tokio::time::timeout;\n\nasync fn with_timeout<T, F>(duration: Duration, future: F) -> Result<T, ServiceError>\nwhere\n    F: std::future::Future<Output = Result<T, ServiceError>>,\n{\n    timeout(duration, future)\n        .await\n        .map_err(|_| ServiceError::Timeout(duration))?\n}\n```\n\n### Pattern 4: Graceful Shutdown\n\n```rust\nuse tokio::signal;\nuse tokio::sync::broadcast;\nuse tokio_util::sync::CancellationToken;\n\nasync fn run_server() -> Result<()> {\n    // Method 1: CancellationToken\n    let token = CancellationToken::new();\n    let token_clone = token.clone();\n\n    // Spawn task that respects cancellation\n    tokio::spawn(async move {\n        loop {\n            tokio::select! {\n                _ = token_clone.cancelled() => {\n                    tracing::info!(\"Task shutting down\");\n                    break;\n                }\n                _ = do_work() => {}\n            }\n        }\n    });\n\n    // Wait for shutdown signal\n    signal::ctrl_c().await?;\n    tracing::info!(\"Shutdown signal received\");\n\n    // Cancel all tasks\n    token.cancel();\n\n    // Give tasks time to cleanup\n    tokio::time::sleep(Duration::from_secs(5)).await;\n\n    Ok(())\n}\n\n// Method 2: Broadcast channel for shutdown\nasync fn run_with_broadcast() -> Result<()> {\n    let (shutdown_tx, _) = broadcast::channel::<()>(1);\n\n    let mut rx = shutdown_tx.subscribe();\n    tokio::spawn(async move {\n        tokio::select! {\n            _ = rx.recv() => {\n                tracing::info!(\"Received shutdown\");\n            }\n            _ = async { loop { do_work().await } } => {}\n        }\n    });\n\n    signal::ctrl_c().await?;\n    let _ = shutdown_tx.send(());\n\n    Ok(())\n}\n```\n\n### Pattern 5: Async Traits\n\n```rust\nuse async_trait::async_trait;\n\n#[async_trait]\npub trait Repository {\n    async fn get(&self, id: &str) -> Result<Entity>;\n    async fn save(&self, entity: &Entity) -> Result<()>;\n    async fn delete(&self, id: &str) -> Result<()>;\n}\n\npub struct PostgresRepository {\n    pool: sqlx::PgPool,\n}\n\n#[async_trait]\nimpl Repository for PostgresRepository {\n    async fn get(&self, id: &str) -> Result<Entity> {\n        sqlx::query_as!(Entity, \"SELECT * FROM entities WHERE id = $1\", id)\n            .fetch_one(&self.pool)\n            .await\n            .map_err(Into::into)\n    }\n\n    async fn save(&self, entity: &Entity) -> Result<()> {\n        sqlx::query!(\n            \"INSERT INTO entities (id, data) VALUES ($1, $2)\n             ON CONFLICT (id) DO UPDATE SET data = $2\",\n            entity.id,\n            entity.data\n        )\n        .execute(&self.pool)\n        .await?;\n        Ok(())\n    }\n\n    async fn delete(&self, id: &str) -> Result<()> {\n        sqlx::query!(\"DELETE FROM entities WHERE id = $1\", id)\n            .execute(&self.pool)\n            .await?;\n        Ok(())\n    }\n}\n\n// Trait object usage\nasync fn process(repo: &dyn Repository, id: &str) -> Result<()> {\n    let entity = repo.get(id).await?;\n    // Process...\n    repo.save(&entity).await\n}\n```\n\n### Pattern 6: Streams and Async Iteration\n\n```rust\nuse futures::stream::{self, Stream, StreamExt};\nuse async_stream::stream;\n\n// Create stream from async iterator\nfn numbers_stream() -> impl Stream<Item = i32> {\n    stream! {\n        for i in 0..10 {\n            tokio::time::sleep(Duration::from_millis(100)).await;\n            yield i;\n        }\n    }\n}\n\n// Process stream\nasync fn process_stream() {\n    let stream = numbers_stream();\n\n    // Map and filter\n    let processed: Vec<_> = stream\n        .filter(|n| futures::future::ready(*n % 2 == 0))\n        .map(|n| n * 2)\n        .collect()\n        .await;\n\n    println!(\"{:?}\", processed);\n}\n\n// Chunked processing\nasync fn process_in_chunks() {\n    let stream = numbers_stream();\n\n    let mut chunks = stream.chunks(3);\n\n    while let Some(chunk) = chunks.next().await {\n        println!(\"Processing chunk: {:?}\", chunk);\n    }\n}\n\n// Merge multiple streams\nasync fn merge_streams() {\n    let stream1 = numbers_stream();\n    let stream2 = numbers_stream();\n\n    let merged = stream::select(stream1, stream2);\n\n    merged\n        .for_each(|n| async move {\n            println!(\"Got: {}\", n);\n        })\n        .await;\n}\n```\n\n### Pattern 7: Resource Management\n\n```rust\nuse std::sync::Arc;\nuse tokio::sync::{Mutex, RwLock, Semaphore};\n\n// Shared state with RwLock (prefer for read-heavy)\nstruct Cache {\n    data: RwLock<HashMap<String, String>>,\n}\n\nimpl Cache {\n    async fn get(&self, key: &str) -> Option<String> {\n        self.data.read().await.get(key).cloned()\n    }\n\n    async fn set(&self, key: String, value: String) {\n        self.data.write().await.insert(key, value);\n    }\n}\n\n// Connection pool with semaphore\nstruct Pool {\n    semaphore: Semaphore,\n    connections: Mutex<Vec<Connection>>,\n}\n\nimpl Pool {\n    fn new(size: usize) -> Self {\n        Self {\n            semaphore: Semaphore::new(size),\n            connections: Mutex::new((0..size).map(|_| Connection::new()).collect()),\n        }\n    }\n\n    async fn acquire(&self) -> PooledConnection<'_> {\n        let permit = self.semaphore.acquire().await.unwrap();\n        let conn = self.connections.lock().await.pop().unwrap();\n        PooledConnection { pool: self, conn: Some(conn), _permit: permit }\n    }\n}\n\nstruct PooledConnection<'a> {\n    pool: &'a Pool,\n    conn: Option<Connection>,\n    _permit: tokio::sync::SemaphorePermit<'a>,\n}\n\nimpl Drop for PooledConnection<'_> {\n    fn drop(&mut self) {\n        if let Some(conn) = self.conn.take() {\n            let pool = self.pool;\n            tokio::spawn(async move {\n                pool.connections.lock().await.push(conn);\n            });\n        }\n    }\n}\n```\n\n## Debugging Tips\n\n```rust\n// Enable tokio-console for runtime debugging\n// Cargo.toml: tokio = { features = [\"tracing\"] }\n// Run: RUSTFLAGS=\"--cfg tokio_unstable\" cargo run\n// Then: tokio-console\n\n// Instrument async functions\nuse tracing::instrument;\n\n#[instrument(skip(pool))]\nasync fn fetch_user(pool: &PgPool, id: &str) -> Result<User> {\n    tracing::debug!(\"Fetching user\");\n    // ...\n}\n\n// Track task spawning\nlet span = tracing::info_span!(\"worker\", id = %worker_id);\ntokio::spawn(async move {\n    // Enters span when polled\n}.instrument(span));\n```\n\n## Best Practices\n\n### Do's\n- **Use `tokio::select!`** - For racing futures\n- **Prefer channels** - Over shared state when possible\n- **Use `JoinSet`** - For managing multiple tasks\n- **Instrument with tracing** - For debugging async code\n- **Handle cancellation** - Check `CancellationToken`\n\n### Don'ts\n- **Don't block** - Never use `std::thread::sleep` in async\n- **Don't hold locks across awaits** - Causes deadlocks\n- **Don't spawn unboundedly** - Use semaphores for limits\n- **Don't ignore errors** - Propagate with `?` or log\n- **Don't forget Send bounds** - For spawned futures\n\n## Resources\n\n- [Tokio Tutorial](https://tokio.rs/tokio/tutorial)\n- [Async Book](https://rust-lang.github.io/async-book/)\n- [Tokio Console](https://github.com/tokio-rs/console)\n"
}