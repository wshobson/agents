{
  "id": "developer_essentials_auth_implementation_patterns",
  "name": "auth-implementation-patterns",
  "source": "developer-essentials",
  "originalPath": "plugins/developer-essentials/skills/auth-implementation-patterns/SKILL.md",
  "activationCriteria": "Master authentication and authorization patterns including JWT, OAuth2, session management, and RBAC to build secure, scalable access control systems. Use when implementing auth systems, securing APIs",
  "tier1_metadata": "auth-implementation-patterns: Master authentication and authorization patterns including JWT, OAuth2, session management, and RBAC",
  "tier2_instructions": "# Authentication & Authorization Implementation Patterns\n\nBuild secure, scalable authentication and authorization systems using industry-standard patterns and modern best practices.\n\n## When to Use This Skill\n\n- Implementing user authentication systems\n- Securing REST or GraphQL APIs\n- Adding OAuth2/social login\n- Implementing role-based access control (RBAC)\n- Designing session management\n- Migrating authentication systems\n- Debugging auth issues\n- Implementing SSO or multi-tenancy\n\n## Core Concepts\n\n### 1. Authentication vs Authorization\n\n**Authentication (AuthN)**: Who are you?\n- Verifying identity (username/password, OAuth, biometrics)\n- Issuing credentials (sessions, tokens)\n- Managing login/logout\n\n**Authorization (AuthZ)**: What can you do?\n- Permission checking\n- Role-based access control (RBAC)\n- Resource ownership validation\n- Policy enforcement\n\n### 2. Authentication Strategies\n\n**Session-Based:**\n- Server stores session state\n- Session ID in cookie\n- Traditional, simple, stateful\n\n**Token-Based (JWT):**\n- Stateless, self-contained\n- Scales horizontally\n- Can store claims\n\n**OAuth2/OpenID Connect:**\n- Delegate authentication\n- Social login (Google, GitHub)\n- Enterprise SSO\n\n## JWT Authentication\n\n### Pattern 1: JWT Implementation\n\n```typescript\n// JWT structure: header.payload.signature\nimport jwt from 'jsonwebtoken';\nimport { Request, Response, NextFunction } from 'express';\n\ninterface JWTPayload {\n    userId: string;\n    email: string;\n    role: string;\n    iat: number;\n    exp: number;\n}\n\n// Generate JWT\nfunction generateTokens(userId: string, email: string, role: string) {\n    const accessToken = jwt.sign(\n        { userId, email, role },\n        process.env.JWT_SECRET!,\n        { expiresIn: '15m' }  // Short-lived\n    );\n\n    const refreshToken = jwt.sign(\n        { userId },\n        process.env.JWT_REFRESH_SECRET!,\n        { expiresIn: '7d' }  // Long-lived\n    );\n\n    return { accessToken, refreshToken };\n}\n\n// Verify JWT\nfunction verifyToken(token",
  "tier3_resources": ": string): JWTPayload {\n    try {\n        return jwt.verify(token, process.env.JWT_SECRET!) as JWTPayload;\n    } catch (error) {\n        if (error instanceof jwt.TokenExpiredError) {\n            throw new Error('Token expired');\n        }\n        if (error instanceof jwt.JsonWebTokenError) {\n            throw new Error('Invalid token');\n        }\n        throw error;\n    }\n}\n\n// Middleware\nfunction authenticate(req: Request, res: Response, next: NextFunction) {\n    const authHeader = req.headers.authorization;\n    if (!authHeader?.startsWith('Bearer ')) {\n        return res.status(401).json({ error: 'No token provided' });\n    }\n\n    const token = authHeader.substring(7);\n    try {\n        const payload = verifyToken(token);\n        req.user = payload;  // Attach user to request\n        next();\n    } catch (error) {\n        return res.status(401).json({ error: 'Invalid token' });\n    }\n}\n\n// Usage\napp.get('/api/profile', authenticate, (req, res) => {\n    res.json({ user: req.user });\n});\n```\n\n### Pattern 2: Refresh Token Flow\n\n```typescript\ninterface StoredRefreshToken {\n    token: string;\n    userId: string;\n    expiresAt: Date;\n    createdAt: Date;\n}\n\nclass RefreshTokenService {\n    // Store refresh token in database\n    async storeRefreshToken(userId: string, refreshToken: string) {\n        const expiresAt = new Date(Date.now() + 7 * 24 * 60 * 60 * 1000);\n        await db.refreshTokens.create({\n            token: await hash(refreshToken),  // Hash before storing\n            userId,\n            expiresAt,\n        });\n    }\n\n    // Refresh access token\n    async refreshAccessToken(refreshToken: string) {\n        // Verify refresh token\n        let payload;\n        try {\n            payload = jwt.verify(\n                refreshToken,\n                process.env.JWT_REFRESH_SECRET!\n            ) as { userId: string };\n        } catch {\n            throw new Error('Invalid refresh token');\n        }\n\n        // Check if token exists in database\n        const storedToken = await db.refreshTokens.findOne({\n            where: {\n                token: await hash(refreshToken),\n                userId: payload.userId,\n                expiresAt: { $gt: new Date() },\n            },\n        });\n\n        if (!storedToken) {\n            throw new Error('Refresh token not found or expired');\n        }\n\n        // Get user\n        const user = await db.users.findById(payload.userId);\n        if (!user) {\n            throw new Error('User not found');\n        }\n\n        // Generate new access token\n        const accessToken = jwt.sign(\n            { userId: user.id, email: user.email, role: user.role },\n            process.env.JWT_SECRET!,\n            { expiresIn: '15m' }\n        );\n\n        return { accessToken };\n    }\n\n    // Revoke refresh token (logout)\n    async revokeRefreshToken(refreshToken: string) {\n        await db.refreshTokens.deleteOne({\n            token: await hash(refreshToken),\n        });\n    }\n\n    // Revoke all user tokens (logout all devic",
  "tokenEstimate": {
    "tier1": 16.900000000000002,
    "tier2": 323.7,
    "tier3": 2085.2000000000003
  },
  "fullDefinition": "---\nname: auth-implementation-patterns\ndescription: Master authentication and authorization patterns including JWT, OAuth2, session management, and RBAC to build secure, scalable access control systems. Use when implementing auth systems, securing APIs, or debugging security issues.\n---\n\n# Authentication & Authorization Implementation Patterns\n\nBuild secure, scalable authentication and authorization systems using industry-standard patterns and modern best practices.\n\n## When to Use This Skill\n\n- Implementing user authentication systems\n- Securing REST or GraphQL APIs\n- Adding OAuth2/social login\n- Implementing role-based access control (RBAC)\n- Designing session management\n- Migrating authentication systems\n- Debugging auth issues\n- Implementing SSO or multi-tenancy\n\n## Core Concepts\n\n### 1. Authentication vs Authorization\n\n**Authentication (AuthN)**: Who are you?\n- Verifying identity (username/password, OAuth, biometrics)\n- Issuing credentials (sessions, tokens)\n- Managing login/logout\n\n**Authorization (AuthZ)**: What can you do?\n- Permission checking\n- Role-based access control (RBAC)\n- Resource ownership validation\n- Policy enforcement\n\n### 2. Authentication Strategies\n\n**Session-Based:**\n- Server stores session state\n- Session ID in cookie\n- Traditional, simple, stateful\n\n**Token-Based (JWT):**\n- Stateless, self-contained\n- Scales horizontally\n- Can store claims\n\n**OAuth2/OpenID Connect:**\n- Delegate authentication\n- Social login (Google, GitHub)\n- Enterprise SSO\n\n## JWT Authentication\n\n### Pattern 1: JWT Implementation\n\n```typescript\n// JWT structure: header.payload.signature\nimport jwt from 'jsonwebtoken';\nimport { Request, Response, NextFunction } from 'express';\n\ninterface JWTPayload {\n    userId: string;\n    email: string;\n    role: string;\n    iat: number;\n    exp: number;\n}\n\n// Generate JWT\nfunction generateTokens(userId: string, email: string, role: string) {\n    const accessToken = jwt.sign(\n        { userId, email, role },\n        process.env.JWT_SECRET!,\n        { expiresIn: '15m' }  // Short-lived\n    );\n\n    const refreshToken = jwt.sign(\n        { userId },\n        process.env.JWT_REFRESH_SECRET!,\n        { expiresIn: '7d' }  // Long-lived\n    );\n\n    return { accessToken, refreshToken };\n}\n\n// Verify JWT\nfunction verifyToken(token: string): JWTPayload {\n    try {\n        return jwt.verify(token, process.env.JWT_SECRET!) as JWTPayload;\n    } catch (error) {\n        if (error instanceof jwt.TokenExpiredError) {\n            throw new Error('Token expired');\n        }\n        if (error instanceof jwt.JsonWebTokenError) {\n            throw new Error('Invalid token');\n        }\n        throw error;\n    }\n}\n\n// Middleware\nfunction authenticate(req: Request, res: Response, next: NextFunction) {\n    const authHeader = req.headers.authorization;\n    if (!authHeader?.startsWith('Bearer ')) {\n        return res.status(401).json({ error: 'No token provided' });\n    }\n\n    const token = authHeader.substring(7);\n    try {\n        const payload = verifyToken(token);\n        req.user = payload;  // Attach user to request\n        next();\n    } catch (error) {\n        return res.status(401).json({ error: 'Invalid token' });\n    }\n}\n\n// Usage\napp.get('/api/profile', authenticate, (req, res) => {\n    res.json({ user: req.user });\n});\n```\n\n### Pattern 2: Refresh Token Flow\n\n```typescript\ninterface StoredRefreshToken {\n    token: string;\n    userId: string;\n    expiresAt: Date;\n    createdAt: Date;\n}\n\nclass RefreshTokenService {\n    // Store refresh token in database\n    async storeRefreshToken(userId: string, refreshToken: string) {\n        const expiresAt = new Date(Date.now() + 7 * 24 * 60 * 60 * 1000);\n        await db.refreshTokens.create({\n            token: await hash(refreshToken),  // Hash before storing\n            userId,\n            expiresAt,\n        });\n    }\n\n    // Refresh access token\n    async refreshAccessToken(refreshToken: string) {\n        // Verify refresh token\n        let payload;\n        try {\n            payload = jwt.verify(\n                refreshToken,\n                process.env.JWT_REFRESH_SECRET!\n            ) as { userId: string };\n        } catch {\n            throw new Error('Invalid refresh token');\n        }\n\n        // Check if token exists in database\n        const storedToken = await db.refreshTokens.findOne({\n            where: {\n                token: await hash(refreshToken),\n                userId: payload.userId,\n                expiresAt: { $gt: new Date() },\n            },\n        });\n\n        if (!storedToken) {\n            throw new Error('Refresh token not found or expired');\n        }\n\n        // Get user\n        const user = await db.users.findById(payload.userId);\n        if (!user) {\n            throw new Error('User not found');\n        }\n\n        // Generate new access token\n        const accessToken = jwt.sign(\n            { userId: user.id, email: user.email, role: user.role },\n            process.env.JWT_SECRET!,\n            { expiresIn: '15m' }\n        );\n\n        return { accessToken };\n    }\n\n    // Revoke refresh token (logout)\n    async revokeRefreshToken(refreshToken: string) {\n        await db.refreshTokens.deleteOne({\n            token: await hash(refreshToken),\n        });\n    }\n\n    // Revoke all user tokens (logout all devices)\n    async revokeAllUserTokens(userId: string) {\n        await db.refreshTokens.deleteMany({ userId });\n    }\n}\n\n// API endpoints\napp.post('/api/auth/refresh', async (req, res) => {\n    const { refreshToken } = req.body;\n    try {\n        const { accessToken } = await refreshTokenService\n            .refreshAccessToken(refreshToken);\n        res.json({ accessToken });\n    } catch (error) {\n        res.status(401).json({ error: 'Invalid refresh token' });\n    }\n});\n\napp.post('/api/auth/logout', authenticate, async (req, res) => {\n    const { refreshToken } = req.body;\n    await refreshTokenService.revokeRefreshToken(refreshToken);\n    res.json({ message: 'Logged out successfully' });\n});\n```\n\n## Session-Based Authentication\n\n### Pattern 1: Express Session\n\n```typescript\nimport session from 'express-session';\nimport RedisStore from 'connect-redis';\nimport { createClient } from 'redis';\n\n// Setup Redis for session storage\nconst redisClient = createClient({\n    url: process.env.REDIS_URL,\n});\nawait redisClient.connect();\n\napp.use(\n    session({\n        store: new RedisStore({ client: redisClient }),\n        secret: process.env.SESSION_SECRET!,\n        resave: false,\n        saveUninitialized: false,\n        cookie: {\n            secure: process.env.NODE_ENV === 'production',  // HTTPS only\n            httpOnly: true,  // No JavaScript access\n            maxAge: 24 * 60 * 60 * 1000,  // 24 hours\n            sameSite: 'strict',  // CSRF protection\n        },\n    })\n);\n\n// Login\napp.post('/api/auth/login', async (req, res) => {\n    const { email, password } = req.body;\n\n    const user = await db.users.findOne({ email });\n    if (!user || !(await verifyPassword(password, user.passwordHash))) {\n        return res.status(401).json({ error: 'Invalid credentials' });\n    }\n\n    // Store user in session\n    req.session.userId = user.id;\n    req.session.role = user.role;\n\n    res.json({ user: { id: user.id, email: user.email, role: user.role } });\n});\n\n// Session middleware\nfunction requireAuth(req: Request, res: Response, next: NextFunction) {\n    if (!req.session.userId) {\n        return res.status(401).json({ error: 'Not authenticated' });\n    }\n    next();\n}\n\n// Protected route\napp.get('/api/profile', requireAuth, async (req, res) => {\n    const user = await db.users.findById(req.session.userId);\n    res.json({ user });\n});\n\n// Logout\napp.post('/api/auth/logout', (req, res) => {\n    req.session.destroy((err) => {\n        if (err) {\n            return res.status(500).json({ error: 'Logout failed' });\n        }\n        res.clearCookie('connect.sid');\n        res.json({ message: 'Logged out successfully' });\n    });\n});\n```\n\n## OAuth2 / Social Login\n\n### Pattern 1: OAuth2 with Passport.js\n\n```typescript\nimport passport from 'passport';\nimport { Strategy as GoogleStrategy } from 'passport-google-oauth20';\nimport { Strategy as GitHubStrategy } from 'passport-github2';\n\n// Google OAuth\npassport.use(\n    new GoogleStrategy(\n        {\n            clientID: process.env.GOOGLE_CLIENT_ID!,\n            clientSecret: process.env.GOOGLE_CLIENT_SECRET!,\n            callbackURL: '/api/auth/google/callback',\n        },\n        async (accessToken, refreshToken, profile, done) => {\n            try {\n                // Find or create user\n                let user = await db.users.findOne({\n                    googleId: profile.id,\n                });\n\n                if (!user) {\n                    user = await db.users.create({\n                        googleId: profile.id,\n                        email: profile.emails?.[0]?.value,\n                        name: profile.displayName,\n                        avatar: profile.photos?.[0]?.value,\n                    });\n                }\n\n                return done(null, user);\n            } catch (error) {\n                return done(error, undefined);\n            }\n        }\n    )\n);\n\n// Routes\napp.get('/api/auth/google', passport.authenticate('google', {\n    scope: ['profile', 'email'],\n}));\n\napp.get(\n    '/api/auth/google/callback',\n    passport.authenticate('google', { session: false }),\n    (req, res) => {\n        // Generate JWT\n        const tokens = generateTokens(req.user.id, req.user.email, req.user.role);\n        // Redirect to frontend with token\n        res.redirect(`${process.env.FRONTEND_URL}/auth/callback?token=${tokens.accessToken}`);\n    }\n);\n```\n\n## Authorization Patterns\n\n### Pattern 1: Role-Based Access Control (RBAC)\n\n```typescript\nenum Role {\n    USER = 'user',\n    MODERATOR = 'moderator',\n    ADMIN = 'admin',\n}\n\nconst roleHierarchy: Record<Role, Role[]> = {\n    [Role.ADMIN]: [Role.ADMIN, Role.MODERATOR, Role.USER],\n    [Role.MODERATOR]: [Role.MODERATOR, Role.USER],\n    [Role.USER]: [Role.USER],\n};\n\nfunction hasRole(userRole: Role, requiredRole: Role): boolean {\n    return roleHierarchy[userRole].includes(requiredRole);\n}\n\n// Middleware\nfunction requireRole(...roles: Role[]) {\n    return (req: Request, res: Response, next: NextFunction) => {\n        if (!req.user) {\n            return res.status(401).json({ error: 'Not authenticated' });\n        }\n\n        if (!roles.some(role => hasRole(req.user.role, role))) {\n            return res.status(403).json({ error: 'Insufficient permissions' });\n        }\n\n        next();\n    };\n}\n\n// Usage\napp.delete('/api/users/:id',\n    authenticate,\n    requireRole(Role.ADMIN),\n    async (req, res) => {\n        // Only admins can delete users\n        await db.users.delete(req.params.id);\n        res.json({ message: 'User deleted' });\n    }\n);\n```\n\n### Pattern 2: Permission-Based Access Control\n\n```typescript\nenum Permission {\n    READ_USERS = 'read:users',\n    WRITE_USERS = 'write:users',\n    DELETE_USERS = 'delete:users',\n    READ_POSTS = 'read:posts',\n    WRITE_POSTS = 'write:posts',\n}\n\nconst rolePermissions: Record<Role, Permission[]> = {\n    [Role.USER]: [Permission.READ_POSTS, Permission.WRITE_POSTS],\n    [Role.MODERATOR]: [\n        Permission.READ_POSTS,\n        Permission.WRITE_POSTS,\n        Permission.READ_USERS,\n    ],\n    [Role.ADMIN]: Object.values(Permission),\n};\n\nfunction hasPermission(userRole: Role, permission: Permission): boolean {\n    return rolePermissions[userRole]?.includes(permission) ?? false;\n}\n\nfunction requirePermission(...permissions: Permission[]) {\n    return (req: Request, res: Response, next: NextFunction) => {\n        if (!req.user) {\n            return res.status(401).json({ error: 'Not authenticated' });\n        }\n\n        const hasAllPermissions = permissions.every(permission =>\n            hasPermission(req.user.role, permission)\n        );\n\n        if (!hasAllPermissions) {\n            return res.status(403).json({ error: 'Insufficient permissions' });\n        }\n\n        next();\n    };\n}\n\n// Usage\napp.get('/api/users',\n    authenticate,\n    requirePermission(Permission.READ_USERS),\n    async (req, res) => {\n        const users = await db.users.findAll();\n        res.json({ users });\n    }\n);\n```\n\n### Pattern 3: Resource Ownership\n\n```typescript\n// Check if user owns resource\nasync function requireOwnership(\n    resourceType: 'post' | 'comment',\n    resourceIdParam: string = 'id'\n) {\n    return async (req: Request, res: Response, next: NextFunction) => {\n        if (!req.user) {\n            return res.status(401).json({ error: 'Not authenticated' });\n        }\n\n        const resourceId = req.params[resourceIdParam];\n\n        // Admins can access anything\n        if (req.user.role === Role.ADMIN) {\n            return next();\n        }\n\n        // Check ownership\n        let resource;\n        if (resourceType === 'post') {\n            resource = await db.posts.findById(resourceId);\n        } else if (resourceType === 'comment') {\n            resource = await db.comments.findById(resourceId);\n        }\n\n        if (!resource) {\n            return res.status(404).json({ error: 'Resource not found' });\n        }\n\n        if (resource.userId !== req.user.userId) {\n            return res.status(403).json({ error: 'Not authorized' });\n        }\n\n        next();\n    };\n}\n\n// Usage\napp.put('/api/posts/:id',\n    authenticate,\n    requireOwnership('post'),\n    async (req, res) => {\n        // User can only update their own posts\n        const post = await db.posts.update(req.params.id, req.body);\n        res.json({ post });\n    }\n);\n```\n\n## Security Best Practices\n\n### Pattern 1: Password Security\n\n```typescript\nimport bcrypt from 'bcrypt';\nimport { z } from 'zod';\n\n// Password validation schema\nconst passwordSchema = z.string()\n    .min(12, 'Password must be at least 12 characters')\n    .regex(/[A-Z]/, 'Password must contain uppercase letter')\n    .regex(/[a-z]/, 'Password must contain lowercase letter')\n    .regex(/[0-9]/, 'Password must contain number')\n    .regex(/[^A-Za-z0-9]/, 'Password must contain special character');\n\n// Hash password\nasync function hashPassword(password: string): Promise<string> {\n    const saltRounds = 12;  // 2^12 iterations\n    return bcrypt.hash(password, saltRounds);\n}\n\n// Verify password\nasync function verifyPassword(\n    password: string,\n    hash: string\n): Promise<boolean> {\n    return bcrypt.compare(password, hash);\n}\n\n// Registration with password validation\napp.post('/api/auth/register', async (req, res) => {\n    try {\n        const { email, password } = req.body;\n\n        // Validate password\n        passwordSchema.parse(password);\n\n        // Check if user exists\n        const existingUser = await db.users.findOne({ email });\n        if (existingUser) {\n            return res.status(400).json({ error: 'Email already registered' });\n        }\n\n        // Hash password\n        const passwordHash = await hashPassword(password);\n\n        // Create user\n        const user = await db.users.create({\n            email,\n            passwordHash,\n        });\n\n        // Generate tokens\n        const tokens = generateTokens(user.id, user.email, user.role);\n\n        res.status(201).json({\n            user: { id: user.id, email: user.email },\n            ...tokens,\n        });\n    } catch (error) {\n        if (error instanceof z.ZodError) {\n            return res.status(400).json({ error: error.errors[0].message });\n        }\n        res.status(500).json({ error: 'Registration failed' });\n    }\n});\n```\n\n### Pattern 2: Rate Limiting\n\n```typescript\nimport rateLimit from 'express-rate-limit';\nimport RedisStore from 'rate-limit-redis';\n\n// Login rate limiter\nconst loginLimiter = rateLimit({\n    store: new RedisStore({ client: redisClient }),\n    windowMs: 15 * 60 * 1000,  // 15 minutes\n    max: 5,  // 5 attempts\n    message: 'Too many login attempts, please try again later',\n    standardHeaders: true,\n    legacyHeaders: false,\n});\n\n// API rate limiter\nconst apiLimiter = rateLimit({\n    windowMs: 60 * 1000,  // 1 minute\n    max: 100,  // 100 requests per minute\n    standardHeaders: true,\n});\n\n// Apply to routes\napp.post('/api/auth/login', loginLimiter, async (req, res) => {\n    // Login logic\n});\n\napp.use('/api/', apiLimiter);\n```\n\n## Best Practices\n\n1. **Never Store Plain Passwords**: Always hash with bcrypt/argon2\n2. **Use HTTPS**: Encrypt data in transit\n3. **Short-Lived Access Tokens**: 15-30 minutes max\n4. **Secure Cookies**: httpOnly, secure, sameSite flags\n5. **Validate All Input**: Email format, password strength\n6. **Rate Limit Auth Endpoints**: Prevent brute force attacks\n7. **Implement CSRF Protection**: For session-based auth\n8. **Rotate Secrets Regularly**: JWT secrets, session secrets\n9. **Log Security Events**: Login attempts, failed auth\n10. **Use MFA When Possible**: Extra security layer\n\n## Common Pitfalls\n\n- **Weak Passwords**: Enforce strong password policies\n- **JWT in localStorage**: Vulnerable to XSS, use httpOnly cookies\n- **No Token Expiration**: Tokens should expire\n- **Client-Side Auth Checks Only**: Always validate server-side\n- **Insecure Password Reset**: Use secure tokens with expiration\n- **No Rate Limiting**: Vulnerable to brute force\n- **Trusting Client Data**: Always validate on server\n\n## Resources\n\n- **references/jwt-best-practices.md**: JWT implementation guide\n- **references/oauth2-flows.md**: OAuth2 flow diagrams and examples\n- **references/session-security.md**: Secure session management\n- **assets/auth-security-checklist.md**: Security review checklist\n- **assets/password-policy-template.md**: Password requirements template\n- **scripts/token-validator.ts**: JWT validation utility\n"
}