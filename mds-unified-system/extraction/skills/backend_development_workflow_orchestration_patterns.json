{
  "id": "backend_development_workflow_orchestration_patterns",
  "name": "workflow-orchestration-patterns",
  "source": "backend-development",
  "originalPath": "plugins/backend-development/skills/workflow-orchestration-patterns/SKILL.md",
  "activationCriteria": "Design durable workflows with Temporal for distributed systems. Covers workflow vs activity separation, saga patterns, state management, and determinism constraints. Use when building long-running pro",
  "tier1_metadata": "workflow-orchestration-patterns: Design durable workflows with Temporal for distributed systems. Covers workflow vs activity separati",
  "tier2_instructions": "# Workflow Orchestration Patterns\n\nMaster workflow orchestration architecture with Temporal, covering fundamental design decisions, resilience patterns, and best practices for building reliable distributed systems.\n\n## When to Use Workflow Orchestration\n\n### Ideal Use Cases (Source: docs.temporal.io)\n\n- **Multi-step processes** spanning machines/services/databases\n- **Distributed transactions** requiring all-or-nothing semantics\n- **Long-running workflows** (hours to years) with automatic state persistence\n- **Failure recovery** that must resume from last successful step\n- **Business processes**: bookings, orders, campaigns, approvals\n- **Entity lifecycle management**: inventory tracking, account management, cart workflows\n- **Infrastructure automation**: CI/CD pipelines, provisioning, deployments\n- **Human-in-the-loop** systems requiring timeouts and escalations\n\n### When NOT to Use\n\n- Simple CRUD operations (use direct API calls)\n- Pure data processing pipelines (use Airflow, batch processing)\n- Stateless request/response (use standard APIs)\n- Real-time streaming (use Kafka, event processors)\n\n## Critical Design Decision: Workflows vs Activities\n\n**The Fundamental Rule** (Source: temporal.io/blog/workflow-engine-principles):\n- **Workflows** = Orchestration logic and decision-making\n- **Activities** = External interactions (APIs, databases, network calls)\n\n### Workflows (Orchestration)\n\n**Characteristics:**\n- Contain business logic and coordination\n- **MUST be deterministic** (same inputs \u2192 same outputs)\n- **Cannot** perform direct external calls\n- State automatically preserved across failures\n- Can run for years despite infrastructure failures\n\n**Example workflow tasks:**\n- Decide which steps to execute\n- Handle compensation logic\n- Manage timeouts and retries\n- Coordinate child workflows\n\n### Activities (External Interactions)\n\n**Characteristics:**\n- Handle all external system interactions\n- Can be non-deterministic (API calls, DB writes)\n- Include built-in timeo",
  "tier3_resources": "uts and retry logic\n- **Must be idempotent** (calling N times = calling once)\n- Short-lived (seconds to minutes typically)\n\n**Example activity tasks:**\n- Call payment gateway API\n- Write to database\n- Send emails or notifications\n- Query external services\n\n### Design Decision Framework\n\n```\nDoes it touch external systems? \u2192 Activity\nIs it orchestration/decision logic? \u2192 Workflow\n```\n\n## Core Workflow Patterns\n\n### 1. Saga Pattern with Compensation\n\n**Purpose**: Implement distributed transactions with rollback capability\n\n**Pattern** (Source: temporal.io/blog/compensating-actions-part-of-a-complete-breakfast-with-sagas):\n\n```\nFor each step:\n  1. Register compensation BEFORE executing\n  2. Execute the step (via activity)\n  3. On failure, run all compensations in reverse order (LIFO)\n```\n\n**Example: Payment Workflow**\n1. Reserve inventory (compensation: release inventory)\n2. Charge payment (compensation: refund payment)\n3. Fulfill order (compensation: cancel fulfillment)\n\n**Critical Requirements:**\n- Compensations must be idempotent\n- Register compensation BEFORE executing step\n- Run compensations in reverse order\n- Handle partial failures gracefully\n\n### 2. Entity Workflows (Actor Model)\n\n**Purpose**: Long-lived workflow representing single entity instance\n\n**Pattern** (Source: docs.temporal.io/evaluate/use-cases-design-patterns):\n- One workflow execution = one entity (cart, account, inventory item)\n- Workflow persists for entity lifetime\n- Receives signals for state changes\n- Supports queries for current state\n\n**Example Use Cases:**\n- Shopping cart (add items, checkout, expiration)\n- Bank account (deposits, withdrawals, balance checks)\n- Product inventory (stock updates, reservations)\n\n**Benefits:**\n- Encapsulates entity behavior\n- Guarantees consistency per entity\n- Natural event sourcing\n\n### 3. Fan-Out/Fan-In (Parallel Execution)\n\n**Purpose**: Execute multiple tasks in parallel, aggregate results\n\n**Pattern:**\n- Spawn child workflows or parallel activities\n- Wait for all to complete\n- Aggregate results\n- Handle partial failures\n\n**Scaling Rule** (Source: temporal.io/blog/workflow-engine-principles):\n- Don't scale individual workflows\n- For 1M tasks: spawn 1K child workflows \u00d7 1K tasks each\n- Keep each workflow bounded\n\n### 4. Async Callback Pattern\n\n**Purpose**: Wait for external event or human approval\n\n**Pattern:**\n- Workflow sends request and waits for signal\n- External system processes asynchronously\n- Sends signal to resume workflow\n- Workflow continues with response\n\n**Use Cases:**\n- Human approval workflows\n- Webhook callbacks\n- Long-running external processes\n\n## State Management and Determinism\n\n### Automatic State Preservation\n\n**How Temporal Works** (Source: docs.temporal.io/workflows):\n- Complete program state preserved automatically\n- Event History records every command and event\n- Seamless recovery from crashes\n- Applications restore pre-failure state\n\n### Determinism Constraints\n\n**Workflows Execute as State Machines**:\n- Replay",
  "tokenEstimate": {
    "tier1": 18.2,
    "tier2": 318.5,
    "tier3": 1134.9
  },
  "fullDefinition": "---\nname: workflow-orchestration-patterns\ndescription: Design durable workflows with Temporal for distributed systems. Covers workflow vs activity separation, saga patterns, state management, and determinism constraints. Use when building long-running processes, distributed transactions, or microservice orchestration.\n---\n\n# Workflow Orchestration Patterns\n\nMaster workflow orchestration architecture with Temporal, covering fundamental design decisions, resilience patterns, and best practices for building reliable distributed systems.\n\n## When to Use Workflow Orchestration\n\n### Ideal Use Cases (Source: docs.temporal.io)\n\n- **Multi-step processes** spanning machines/services/databases\n- **Distributed transactions** requiring all-or-nothing semantics\n- **Long-running workflows** (hours to years) with automatic state persistence\n- **Failure recovery** that must resume from last successful step\n- **Business processes**: bookings, orders, campaigns, approvals\n- **Entity lifecycle management**: inventory tracking, account management, cart workflows\n- **Infrastructure automation**: CI/CD pipelines, provisioning, deployments\n- **Human-in-the-loop** systems requiring timeouts and escalations\n\n### When NOT to Use\n\n- Simple CRUD operations (use direct API calls)\n- Pure data processing pipelines (use Airflow, batch processing)\n- Stateless request/response (use standard APIs)\n- Real-time streaming (use Kafka, event processors)\n\n## Critical Design Decision: Workflows vs Activities\n\n**The Fundamental Rule** (Source: temporal.io/blog/workflow-engine-principles):\n- **Workflows** = Orchestration logic and decision-making\n- **Activities** = External interactions (APIs, databases, network calls)\n\n### Workflows (Orchestration)\n\n**Characteristics:**\n- Contain business logic and coordination\n- **MUST be deterministic** (same inputs \u2192 same outputs)\n- **Cannot** perform direct external calls\n- State automatically preserved across failures\n- Can run for years despite infrastructure failures\n\n**Example workflow tasks:**\n- Decide which steps to execute\n- Handle compensation logic\n- Manage timeouts and retries\n- Coordinate child workflows\n\n### Activities (External Interactions)\n\n**Characteristics:**\n- Handle all external system interactions\n- Can be non-deterministic (API calls, DB writes)\n- Include built-in timeouts and retry logic\n- **Must be idempotent** (calling N times = calling once)\n- Short-lived (seconds to minutes typically)\n\n**Example activity tasks:**\n- Call payment gateway API\n- Write to database\n- Send emails or notifications\n- Query external services\n\n### Design Decision Framework\n\n```\nDoes it touch external systems? \u2192 Activity\nIs it orchestration/decision logic? \u2192 Workflow\n```\n\n## Core Workflow Patterns\n\n### 1. Saga Pattern with Compensation\n\n**Purpose**: Implement distributed transactions with rollback capability\n\n**Pattern** (Source: temporal.io/blog/compensating-actions-part-of-a-complete-breakfast-with-sagas):\n\n```\nFor each step:\n  1. Register compensation BEFORE executing\n  2. Execute the step (via activity)\n  3. On failure, run all compensations in reverse order (LIFO)\n```\n\n**Example: Payment Workflow**\n1. Reserve inventory (compensation: release inventory)\n2. Charge payment (compensation: refund payment)\n3. Fulfill order (compensation: cancel fulfillment)\n\n**Critical Requirements:**\n- Compensations must be idempotent\n- Register compensation BEFORE executing step\n- Run compensations in reverse order\n- Handle partial failures gracefully\n\n### 2. Entity Workflows (Actor Model)\n\n**Purpose**: Long-lived workflow representing single entity instance\n\n**Pattern** (Source: docs.temporal.io/evaluate/use-cases-design-patterns):\n- One workflow execution = one entity (cart, account, inventory item)\n- Workflow persists for entity lifetime\n- Receives signals for state changes\n- Supports queries for current state\n\n**Example Use Cases:**\n- Shopping cart (add items, checkout, expiration)\n- Bank account (deposits, withdrawals, balance checks)\n- Product inventory (stock updates, reservations)\n\n**Benefits:**\n- Encapsulates entity behavior\n- Guarantees consistency per entity\n- Natural event sourcing\n\n### 3. Fan-Out/Fan-In (Parallel Execution)\n\n**Purpose**: Execute multiple tasks in parallel, aggregate results\n\n**Pattern:**\n- Spawn child workflows or parallel activities\n- Wait for all to complete\n- Aggregate results\n- Handle partial failures\n\n**Scaling Rule** (Source: temporal.io/blog/workflow-engine-principles):\n- Don't scale individual workflows\n- For 1M tasks: spawn 1K child workflows \u00d7 1K tasks each\n- Keep each workflow bounded\n\n### 4. Async Callback Pattern\n\n**Purpose**: Wait for external event or human approval\n\n**Pattern:**\n- Workflow sends request and waits for signal\n- External system processes asynchronously\n- Sends signal to resume workflow\n- Workflow continues with response\n\n**Use Cases:**\n- Human approval workflows\n- Webhook callbacks\n- Long-running external processes\n\n## State Management and Determinism\n\n### Automatic State Preservation\n\n**How Temporal Works** (Source: docs.temporal.io/workflows):\n- Complete program state preserved automatically\n- Event History records every command and event\n- Seamless recovery from crashes\n- Applications restore pre-failure state\n\n### Determinism Constraints\n\n**Workflows Execute as State Machines**:\n- Replay behavior must be consistent\n- Same inputs \u2192 identical outputs every time\n\n**Prohibited in Workflows** (Source: docs.temporal.io/workflows):\n- \u274c Threading, locks, synchronization primitives\n- \u274c Random number generation (`random()`)\n- \u274c Global state or static variables\n- \u274c System time (`datetime.now()`)\n- \u274c Direct file I/O or network calls\n- \u274c Non-deterministic libraries\n\n**Allowed in Workflows**:\n- \u2705 `workflow.now()` (deterministic time)\n- \u2705 `workflow.random()` (deterministic random)\n- \u2705 Pure functions and calculations\n- \u2705 Calling activities (non-deterministic operations)\n\n### Versioning Strategies\n\n**Challenge**: Changing workflow code while old executions still running\n\n**Solutions**:\n1. **Versioning API**: Use `workflow.get_version()` for safe changes\n2. **New Workflow Type**: Create new workflow, route new executions to it\n3. **Backward Compatibility**: Ensure old events replay correctly\n\n## Resilience and Error Handling\n\n### Retry Policies\n\n**Default Behavior**: Temporal retries activities forever\n\n**Configure Retry**:\n- Initial retry interval\n- Backoff coefficient (exponential backoff)\n- Maximum interval (cap retry delay)\n- Maximum attempts (eventually fail)\n\n**Non-Retryable Errors**:\n- Invalid input (validation failures)\n- Business rule violations\n- Permanent failures (resource not found)\n\n### Idempotency Requirements\n\n**Why Critical** (Source: docs.temporal.io/activities):\n- Activities may execute multiple times\n- Network failures trigger retries\n- Duplicate execution must be safe\n\n**Implementation Strategies**:\n- Idempotency keys (deduplication)\n- Check-then-act with unique constraints\n- Upsert operations instead of insert\n- Track processed request IDs\n\n### Activity Heartbeats\n\n**Purpose**: Detect stalled long-running activities\n\n**Pattern**:\n- Activity sends periodic heartbeat\n- Includes progress information\n- Timeout if no heartbeat received\n- Enables progress-based retry\n\n## Best Practices\n\n### Workflow Design\n\n1. **Keep workflows focused** - Single responsibility per workflow\n2. **Small workflows** - Use child workflows for scalability\n3. **Clear boundaries** - Workflow orchestrates, activities execute\n4. **Test locally** - Use time-skipping test environment\n\n### Activity Design\n\n1. **Idempotent operations** - Safe to retry\n2. **Short-lived** - Seconds to minutes, not hours\n3. **Timeout configuration** - Always set timeouts\n4. **Heartbeat for long tasks** - Report progress\n5. **Error handling** - Distinguish retryable vs non-retryable\n\n### Common Pitfalls\n\n**Workflow Violations**:\n- Using `datetime.now()` instead of `workflow.now()`\n- Threading or async operations in workflow code\n- Calling external APIs directly from workflow\n- Non-deterministic logic in workflows\n\n**Activity Mistakes**:\n- Non-idempotent operations (can't handle retries)\n- Missing timeouts (activities run forever)\n- No error classification (retry validation errors)\n- Ignoring payload limits (2MB per argument)\n\n### Operational Considerations\n\n**Monitoring**:\n- Workflow execution duration\n- Activity failure rates\n- Retry attempts and backoff\n- Pending workflow counts\n\n**Scalability**:\n- Horizontal scaling with workers\n- Task queue partitioning\n- Child workflow decomposition\n- Activity batching when appropriate\n\n## Additional Resources\n\n**Official Documentation**:\n- Temporal Core Concepts: docs.temporal.io/workflows\n- Workflow Patterns: docs.temporal.io/evaluate/use-cases-design-patterns\n- Best Practices: docs.temporal.io/develop/best-practices\n- Saga Pattern: temporal.io/blog/saga-pattern-made-easy\n\n**Key Principles**:\n1. Workflows = orchestration, Activities = external calls\n2. Determinism is non-negotiable for workflows\n3. Idempotency is critical for activities\n4. State preservation is automatic\n5. Design for failure and recovery\n"
}