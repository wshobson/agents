{
  "id": "backend_development_api_design_principles",
  "name": "api-design-principles",
  "source": "backend-development",
  "originalPath": "plugins/backend-development/skills/api-design-principles/SKILL.md",
  "activationCriteria": "Master REST and GraphQL API design principles to build intuitive, scalable, and maintainable APIs that delight developers. Use when designing new APIs, reviewing API specifications, or establishing AP",
  "tier1_metadata": "api-design-principles: Master REST and GraphQL API design principles to build intuitive, scalable, and maintainable APIs th",
  "tier2_instructions": "# API Design Principles\n\nMaster REST and GraphQL API design principles to build intuitive, scalable, and maintainable APIs that delight developers and stand the test of time.\n\n## When to Use This Skill\n\n- Designing new REST or GraphQL APIs\n- Refactoring existing APIs for better usability\n- Establishing API design standards for your team\n- Reviewing API specifications before implementation\n- Migrating between API paradigms (REST to GraphQL, etc.)\n- Creating developer-friendly API documentation\n- Optimizing APIs for specific use cases (mobile, third-party integrations)\n\n## Core Concepts\n\n### 1. RESTful Design Principles\n\n**Resource-Oriented Architecture**\n- Resources are nouns (users, orders, products), not verbs\n- Use HTTP methods for actions (GET, POST, PUT, PATCH, DELETE)\n- URLs represent resource hierarchies\n- Consistent naming conventions\n\n**HTTP Methods Semantics:**\n- `GET`: Retrieve resources (idempotent, safe)\n- `POST`: Create new resources\n- `PUT`: Replace entire resource (idempotent)\n- `PATCH`: Partial resource updates\n- `DELETE`: Remove resources (idempotent)\n\n### 2. GraphQL Design Principles\n\n**Schema-First Development**\n- Types define your domain model\n- Queries for reading data\n- Mutations for modifying data\n- Subscriptions for real-time updates\n\n**Query Structure:**\n- Clients request exactly what they need\n- Single endpoint, multiple operations\n- Strongly typed schema\n- Introspection built-in\n\n### 3. API Versioning Strategies\n\n**URL Versioning:**\n```\n/api/v1/users\n/api/v2/users\n```\n\n**Header Versioning:**\n```\nAccept: application/vnd.api+json; version=1\n```\n\n**Query Parameter Versioning:**\n```\n/api/users?version=1\n```\n\n## REST API Design Patterns\n\n### Pattern 1: Resource Collection Design\n\n```python\n# Good: Resource-oriented endpoints\nGET    /api/users              # List users (with pagination)\nPOST   /api/users              # Create user\nGET    /api/users/{id}         # Get specific user\nPUT    /api/users/{id}         # Replace user\nPATCH  /api/users/{",
  "tier3_resources": "id}         # Update user fields\nDELETE /api/users/{id}         # Delete user\n\n# Nested resources\nGET    /api/users/{id}/orders  # Get user's orders\nPOST   /api/users/{id}/orders  # Create order for user\n\n# Bad: Action-oriented endpoints (avoid)\nPOST   /api/createUser\nPOST   /api/getUserById\nPOST   /api/deleteUser\n```\n\n### Pattern 2: Pagination and Filtering\n\n```python\nfrom typing import List, Optional\nfrom pydantic import BaseModel, Field\n\nclass PaginationParams(BaseModel):\n    page: int = Field(1, ge=1, description=\"Page number\")\n    page_size: int = Field(20, ge=1, le=100, description=\"Items per page\")\n\nclass FilterParams(BaseModel):\n    status: Optional[str] = None\n    created_after: Optional[str] = None\n    search: Optional[str] = None\n\nclass PaginatedResponse(BaseModel):\n    items: List[dict]\n    total: int\n    page: int\n    page_size: int\n    pages: int\n\n    @property\n    def has_next(self) -> bool:\n        return self.page < self.pages\n\n    @property\n    def has_prev(self) -> bool:\n        return self.page > 1\n\n# FastAPI endpoint example\nfrom fastapi import FastAPI, Query, Depends\n\napp = FastAPI()\n\n@app.get(\"/api/users\", response_model=PaginatedResponse)\nasync def list_users(\n    page: int = Query(1, ge=1),\n    page_size: int = Query(20, ge=1, le=100),\n    status: Optional[str] = Query(None),\n    search: Optional[str] = Query(None)\n):\n    # Apply filters\n    query = build_query(status=status, search=search)\n\n    # Count total\n    total = await count_users(query)\n\n    # Fetch page\n    offset = (page - 1) * page_size\n    users = await fetch_users(query, limit=page_size, offset=offset)\n\n    return PaginatedResponse(\n        items=users,\n        total=total,\n        page=page,\n        page_size=page_size,\n        pages=(total + page_size - 1) // page_size\n    )\n```\n\n### Pattern 3: Error Handling and Status Codes\n\n```python\nfrom fastapi import HTTPException, status\nfrom pydantic import BaseModel\n\nclass ErrorResponse(BaseModel):\n    error: str\n    message: str\n    details: Optional[dict] = None\n    timestamp: str\n    path: str\n\nclass ValidationErrorDetail(BaseModel):\n    field: str\n    message: str\n    value: Any\n\n# Consistent error responses\nSTATUS_CODES = {\n    \"success\": 200,\n    \"created\": 201,\n    \"no_content\": 204,\n    \"bad_request\": 400,\n    \"unauthorized\": 401,\n    \"forbidden\": 403,\n    \"not_found\": 404,\n    \"conflict\": 409,\n    \"unprocessable\": 422,\n    \"internal_error\": 500\n}\n\ndef raise_not_found(resource: str, id: str):\n    raise HTTPException(\n        status_code=status.HTTP_404_NOT_FOUND,\n        detail={\n            \"error\": \"NotFound\",\n            \"message\": f\"{resource} not found\",\n            \"details\": {\"id\": id}\n        }\n    )\n\ndef raise_validation_error(errors: List[ValidationErrorDetail]):\n    raise HTTPException(\n        status_code=status.HTTP_422_UNPROCESSABLE_ENTITY,\n        detail={\n            \"error\": \"ValidationError\",\n            \"message\": \"Request validation failed\",\n            \"details\": {\"errors\": [e.dict() f",
  "tokenEstimate": {
    "tier1": 20.8,
    "tier2": 348.40000000000003,
    "tier3": 1579.5
  },
  "fullDefinition": "---\nname: api-design-principles\ndescription: Master REST and GraphQL API design principles to build intuitive, scalable, and maintainable APIs that delight developers. Use when designing new APIs, reviewing API specifications, or establishing API design standards.\n---\n\n# API Design Principles\n\nMaster REST and GraphQL API design principles to build intuitive, scalable, and maintainable APIs that delight developers and stand the test of time.\n\n## When to Use This Skill\n\n- Designing new REST or GraphQL APIs\n- Refactoring existing APIs for better usability\n- Establishing API design standards for your team\n- Reviewing API specifications before implementation\n- Migrating between API paradigms (REST to GraphQL, etc.)\n- Creating developer-friendly API documentation\n- Optimizing APIs for specific use cases (mobile, third-party integrations)\n\n## Core Concepts\n\n### 1. RESTful Design Principles\n\n**Resource-Oriented Architecture**\n- Resources are nouns (users, orders, products), not verbs\n- Use HTTP methods for actions (GET, POST, PUT, PATCH, DELETE)\n- URLs represent resource hierarchies\n- Consistent naming conventions\n\n**HTTP Methods Semantics:**\n- `GET`: Retrieve resources (idempotent, safe)\n- `POST`: Create new resources\n- `PUT`: Replace entire resource (idempotent)\n- `PATCH`: Partial resource updates\n- `DELETE`: Remove resources (idempotent)\n\n### 2. GraphQL Design Principles\n\n**Schema-First Development**\n- Types define your domain model\n- Queries for reading data\n- Mutations for modifying data\n- Subscriptions for real-time updates\n\n**Query Structure:**\n- Clients request exactly what they need\n- Single endpoint, multiple operations\n- Strongly typed schema\n- Introspection built-in\n\n### 3. API Versioning Strategies\n\n**URL Versioning:**\n```\n/api/v1/users\n/api/v2/users\n```\n\n**Header Versioning:**\n```\nAccept: application/vnd.api+json; version=1\n```\n\n**Query Parameter Versioning:**\n```\n/api/users?version=1\n```\n\n## REST API Design Patterns\n\n### Pattern 1: Resource Collection Design\n\n```python\n# Good: Resource-oriented endpoints\nGET    /api/users              # List users (with pagination)\nPOST   /api/users              # Create user\nGET    /api/users/{id}         # Get specific user\nPUT    /api/users/{id}         # Replace user\nPATCH  /api/users/{id}         # Update user fields\nDELETE /api/users/{id}         # Delete user\n\n# Nested resources\nGET    /api/users/{id}/orders  # Get user's orders\nPOST   /api/users/{id}/orders  # Create order for user\n\n# Bad: Action-oriented endpoints (avoid)\nPOST   /api/createUser\nPOST   /api/getUserById\nPOST   /api/deleteUser\n```\n\n### Pattern 2: Pagination and Filtering\n\n```python\nfrom typing import List, Optional\nfrom pydantic import BaseModel, Field\n\nclass PaginationParams(BaseModel):\n    page: int = Field(1, ge=1, description=\"Page number\")\n    page_size: int = Field(20, ge=1, le=100, description=\"Items per page\")\n\nclass FilterParams(BaseModel):\n    status: Optional[str] = None\n    created_after: Optional[str] = None\n    search: Optional[str] = None\n\nclass PaginatedResponse(BaseModel):\n    items: List[dict]\n    total: int\n    page: int\n    page_size: int\n    pages: int\n\n    @property\n    def has_next(self) -> bool:\n        return self.page < self.pages\n\n    @property\n    def has_prev(self) -> bool:\n        return self.page > 1\n\n# FastAPI endpoint example\nfrom fastapi import FastAPI, Query, Depends\n\napp = FastAPI()\n\n@app.get(\"/api/users\", response_model=PaginatedResponse)\nasync def list_users(\n    page: int = Query(1, ge=1),\n    page_size: int = Query(20, ge=1, le=100),\n    status: Optional[str] = Query(None),\n    search: Optional[str] = Query(None)\n):\n    # Apply filters\n    query = build_query(status=status, search=search)\n\n    # Count total\n    total = await count_users(query)\n\n    # Fetch page\n    offset = (page - 1) * page_size\n    users = await fetch_users(query, limit=page_size, offset=offset)\n\n    return PaginatedResponse(\n        items=users,\n        total=total,\n        page=page,\n        page_size=page_size,\n        pages=(total + page_size - 1) // page_size\n    )\n```\n\n### Pattern 3: Error Handling and Status Codes\n\n```python\nfrom fastapi import HTTPException, status\nfrom pydantic import BaseModel\n\nclass ErrorResponse(BaseModel):\n    error: str\n    message: str\n    details: Optional[dict] = None\n    timestamp: str\n    path: str\n\nclass ValidationErrorDetail(BaseModel):\n    field: str\n    message: str\n    value: Any\n\n# Consistent error responses\nSTATUS_CODES = {\n    \"success\": 200,\n    \"created\": 201,\n    \"no_content\": 204,\n    \"bad_request\": 400,\n    \"unauthorized\": 401,\n    \"forbidden\": 403,\n    \"not_found\": 404,\n    \"conflict\": 409,\n    \"unprocessable\": 422,\n    \"internal_error\": 500\n}\n\ndef raise_not_found(resource: str, id: str):\n    raise HTTPException(\n        status_code=status.HTTP_404_NOT_FOUND,\n        detail={\n            \"error\": \"NotFound\",\n            \"message\": f\"{resource} not found\",\n            \"details\": {\"id\": id}\n        }\n    )\n\ndef raise_validation_error(errors: List[ValidationErrorDetail]):\n    raise HTTPException(\n        status_code=status.HTTP_422_UNPROCESSABLE_ENTITY,\n        detail={\n            \"error\": \"ValidationError\",\n            \"message\": \"Request validation failed\",\n            \"details\": {\"errors\": [e.dict() for e in errors]}\n        }\n    )\n\n# Example usage\n@app.get(\"/api/users/{user_id}\")\nasync def get_user(user_id: str):\n    user = await fetch_user(user_id)\n    if not user:\n        raise_not_found(\"User\", user_id)\n    return user\n```\n\n### Pattern 4: HATEOAS (Hypermedia as the Engine of Application State)\n\n```python\nclass UserResponse(BaseModel):\n    id: str\n    name: str\n    email: str\n    _links: dict\n\n    @classmethod\n    def from_user(cls, user: User, base_url: str):\n        return cls(\n            id=user.id,\n            name=user.name,\n            email=user.email,\n            _links={\n                \"self\": {\"href\": f\"{base_url}/api/users/{user.id}\"},\n                \"orders\": {\"href\": f\"{base_url}/api/users/{user.id}/orders\"},\n                \"update\": {\n                    \"href\": f\"{base_url}/api/users/{user.id}\",\n                    \"method\": \"PATCH\"\n                },\n                \"delete\": {\n                    \"href\": f\"{base_url}/api/users/{user.id}\",\n                    \"method\": \"DELETE\"\n                }\n            }\n        )\n```\n\n## GraphQL Design Patterns\n\n### Pattern 1: Schema Design\n\n```graphql\n# schema.graphql\n\n# Clear type definitions\ntype User {\n  id: ID!\n  email: String!\n  name: String!\n  createdAt: DateTime!\n\n  # Relationships\n  orders(\n    first: Int = 20\n    after: String\n    status: OrderStatus\n  ): OrderConnection!\n\n  profile: UserProfile\n}\n\ntype Order {\n  id: ID!\n  status: OrderStatus!\n  total: Money!\n  items: [OrderItem!]!\n  createdAt: DateTime!\n\n  # Back-reference\n  user: User!\n}\n\n# Pagination pattern (Relay-style)\ntype OrderConnection {\n  edges: [OrderEdge!]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype OrderEdge {\n  node: Order!\n  cursor: String!\n}\n\ntype PageInfo {\n  hasNextPage: Boolean!\n  hasPreviousPage: Boolean!\n  startCursor: String\n  endCursor: String\n}\n\n# Enums for type safety\nenum OrderStatus {\n  PENDING\n  CONFIRMED\n  SHIPPED\n  DELIVERED\n  CANCELLED\n}\n\n# Custom scalars\nscalar DateTime\nscalar Money\n\n# Query root\ntype Query {\n  user(id: ID!): User\n  users(\n    first: Int = 20\n    after: String\n    search: String\n  ): UserConnection!\n\n  order(id: ID!): Order\n}\n\n# Mutation root\ntype Mutation {\n  createUser(input: CreateUserInput!): CreateUserPayload!\n  updateUser(input: UpdateUserInput!): UpdateUserPayload!\n  deleteUser(id: ID!): DeleteUserPayload!\n\n  createOrder(input: CreateOrderInput!): CreateOrderPayload!\n}\n\n# Input types for mutations\ninput CreateUserInput {\n  email: String!\n  name: String!\n  password: String!\n}\n\n# Payload types for mutations\ntype CreateUserPayload {\n  user: User\n  errors: [Error!]\n}\n\ntype Error {\n  field: String\n  message: String!\n}\n```\n\n### Pattern 2: Resolver Design\n\n```python\nfrom typing import Optional, List\nfrom ariadne import QueryType, MutationType, ObjectType\nfrom dataclasses import dataclass\n\nquery = QueryType()\nmutation = MutationType()\nuser_type = ObjectType(\"User\")\n\n@query.field(\"user\")\nasync def resolve_user(obj, info, id: str) -> Optional[dict]:\n    \"\"\"Resolve single user by ID.\"\"\"\n    return await fetch_user_by_id(id)\n\n@query.field(\"users\")\nasync def resolve_users(\n    obj,\n    info,\n    first: int = 20,\n    after: Optional[str] = None,\n    search: Optional[str] = None\n) -> dict:\n    \"\"\"Resolve paginated user list.\"\"\"\n    # Decode cursor\n    offset = decode_cursor(after) if after else 0\n\n    # Fetch users\n    users = await fetch_users(\n        limit=first + 1,  # Fetch one extra to check hasNextPage\n        offset=offset,\n        search=search\n    )\n\n    # Pagination\n    has_next = len(users) > first\n    if has_next:\n        users = users[:first]\n\n    edges = [\n        {\n            \"node\": user,\n            \"cursor\": encode_cursor(offset + i)\n        }\n        for i, user in enumerate(users)\n    ]\n\n    return {\n        \"edges\": edges,\n        \"pageInfo\": {\n            \"hasNextPage\": has_next,\n            \"hasPreviousPage\": offset > 0,\n            \"startCursor\": edges[0][\"cursor\"] if edges else None,\n            \"endCursor\": edges[-1][\"cursor\"] if edges else None\n        },\n        \"totalCount\": await count_users(search=search)\n    }\n\n@user_type.field(\"orders\")\nasync def resolve_user_orders(user: dict, info, first: int = 20) -> dict:\n    \"\"\"Resolve user's orders (N+1 prevention with DataLoader).\"\"\"\n    # Use DataLoader to batch requests\n    loader = info.context[\"loaders\"][\"orders_by_user\"]\n    orders = await loader.load(user[\"id\"])\n\n    return paginate_orders(orders, first)\n\n@mutation.field(\"createUser\")\nasync def resolve_create_user(obj, info, input: dict) -> dict:\n    \"\"\"Create new user.\"\"\"\n    try:\n        # Validate input\n        validate_user_input(input)\n\n        # Create user\n        user = await create_user(\n            email=input[\"email\"],\n            name=input[\"name\"],\n            password=hash_password(input[\"password\"])\n        )\n\n        return {\n            \"user\": user,\n            \"errors\": []\n        }\n    except ValidationError as e:\n        return {\n            \"user\": None,\n            \"errors\": [{\"field\": e.field, \"message\": e.message}]\n        }\n```\n\n### Pattern 3: DataLoader (N+1 Problem Prevention)\n\n```python\nfrom aiodataloader import DataLoader\nfrom typing import List, Optional\n\nclass UserLoader(DataLoader):\n    \"\"\"Batch load users by ID.\"\"\"\n\n    async def batch_load_fn(self, user_ids: List[str]) -> List[Optional[dict]]:\n        \"\"\"Load multiple users in single query.\"\"\"\n        users = await fetch_users_by_ids(user_ids)\n\n        # Map results back to input order\n        user_map = {user[\"id\"]: user for user in users}\n        return [user_map.get(user_id) for user_id in user_ids]\n\nclass OrdersByUserLoader(DataLoader):\n    \"\"\"Batch load orders by user ID.\"\"\"\n\n    async def batch_load_fn(self, user_ids: List[str]) -> List[List[dict]]:\n        \"\"\"Load orders for multiple users in single query.\"\"\"\n        orders = await fetch_orders_by_user_ids(user_ids)\n\n        # Group orders by user_id\n        orders_by_user = {}\n        for order in orders:\n            user_id = order[\"user_id\"]\n            if user_id not in orders_by_user:\n                orders_by_user[user_id] = []\n            orders_by_user[user_id].append(order)\n\n        # Return in input order\n        return [orders_by_user.get(user_id, []) for user_id in user_ids]\n\n# Context setup\ndef create_context():\n    return {\n        \"loaders\": {\n            \"user\": UserLoader(),\n            \"orders_by_user\": OrdersByUserLoader()\n        }\n    }\n```\n\n## Best Practices\n\n### REST APIs\n1. **Consistent Naming**: Use plural nouns for collections (`/users`, not `/user`)\n2. **Stateless**: Each request contains all necessary information\n3. **Use HTTP Status Codes Correctly**: 2xx success, 4xx client errors, 5xx server errors\n4. **Version Your API**: Plan for breaking changes from day one\n5. **Pagination**: Always paginate large collections\n6. **Rate Limiting**: Protect your API with rate limits\n7. **Documentation**: Use OpenAPI/Swagger for interactive docs\n\n### GraphQL APIs\n1. **Schema First**: Design schema before writing resolvers\n2. **Avoid N+1**: Use DataLoaders for efficient data fetching\n3. **Input Validation**: Validate at schema and resolver levels\n4. **Error Handling**: Return structured errors in mutation payloads\n5. **Pagination**: Use cursor-based pagination (Relay spec)\n6. **Deprecation**: Use `@deprecated` directive for gradual migration\n7. **Monitoring**: Track query complexity and execution time\n\n## Common Pitfalls\n\n- **Over-fetching/Under-fetching (REST)**: Fixed in GraphQL but requires DataLoaders\n- **Breaking Changes**: Version APIs or use deprecation strategies\n- **Inconsistent Error Formats**: Standardize error responses\n- **Missing Rate Limits**: APIs without limits are vulnerable to abuse\n- **Poor Documentation**: Undocumented APIs frustrate developers\n- **Ignoring HTTP Semantics**: POST for idempotent operations breaks expectations\n- **Tight Coupling**: API structure shouldn't mirror database schema\n\n## Resources\n\n- **references/rest-best-practices.md**: Comprehensive REST API design guide\n- **references/graphql-schema-design.md**: GraphQL schema patterns and anti-patterns\n- **references/api-versioning-strategies.md**: Versioning approaches and migration paths\n- **assets/rest-api-template.py**: FastAPI REST API template\n- **assets/graphql-schema-template.graphql**: Complete GraphQL schema example\n- **assets/api-design-checklist.md**: Pre-implementation review checklist\n- **scripts/openapi-generator.py**: Generate OpenAPI specs from code\n"
}