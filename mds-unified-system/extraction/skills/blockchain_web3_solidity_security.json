{
  "id": "blockchain_web3_solidity_security",
  "name": "solidity-security",
  "source": "blockchain-web3",
  "originalPath": "plugins/blockchain-web3/skills/solidity-security/SKILL.md",
  "activationCriteria": "Master smart contract security best practices to prevent common vulnerabilities and implement secure Solidity patterns. Use when writing smart contracts, auditing existing contracts, or implementing s",
  "tier1_metadata": "solidity-security: Master smart contract security best practices to prevent common vulnerabilities and implement secure",
  "tier2_instructions": "# Solidity Security\n\nMaster smart contract security best practices, vulnerability prevention, and secure Solidity development patterns.\n\n## When to Use This Skill\n\n- Writing secure smart contracts\n- Auditing existing contracts for vulnerabilities\n- Implementing secure DeFi protocols\n- Preventing reentrancy, overflow, and access control issues\n- Optimizing gas usage while maintaining security\n- Preparing contracts for professional audits\n- Understanding common attack vectors\n\n## Critical Vulnerabilities\n\n### 1. Reentrancy\nAttacker calls back into your contract before state is updated.\n\n**Vulnerable Code:**\n```solidity\n// VULNERABLE TO REENTRANCY\ncontract VulnerableBank {\n    mapping(address => uint256) public balances;\n\n    function withdraw() public {\n        uint256 amount = balances[msg.sender];\n\n        // DANGER: External call before state update\n        (bool success, ) = msg.sender.call{value: amount}(\"\");\n        require(success);\n\n        balances[msg.sender] = 0;  // Too late!\n    }\n}\n```\n\n**Secure Pattern (Checks-Effects-Interactions):**\n```solidity\ncontract SecureBank {\n    mapping(address => uint256) public balances;\n\n    function withdraw() public {\n        uint256 amount = balances[msg.sender];\n        require(amount > 0, \"Insufficient balance\");\n\n        // EFFECTS: Update state BEFORE external call\n        balances[msg.sender] = 0;\n\n        // INTERACTIONS: External call last\n        (bool success, ) = msg.sender.call{value: amount}(\"\");\n        require(success, \"Transfer failed\");\n    }\n}\n```\n\n**Alternative: ReentrancyGuard**\n```solidity\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\ncontract SecureBank is ReentrancyGuard {\n    mapping(address => uint256) public balances;\n\n    function withdraw() public nonReentrant {\n        uint256 amount = balances[msg.sender];\n        require(amount > 0, \"Insufficient balance\");\n\n        balances[msg.sender] = 0;\n\n        (bool success, ) = msg.sender.call{value: amount}(\"\");\n        require(suc",
  "tier3_resources": "cess, \"Transfer failed\");\n    }\n}\n```\n\n### 2. Integer Overflow/Underflow\n\n**Vulnerable Code (Solidity < 0.8.0):**\n```solidity\n// VULNERABLE\ncontract VulnerableToken {\n    mapping(address => uint256) public balances;\n\n    function transfer(address to, uint256 amount) public {\n        // No overflow check - can wrap around\n        balances[msg.sender] -= amount;  // Can underflow!\n        balances[to] += amount;          // Can overflow!\n    }\n}\n```\n\n**Secure Pattern (Solidity >= 0.8.0):**\n```solidity\n// Solidity 0.8+ has built-in overflow/underflow checks\ncontract SecureToken {\n    mapping(address => uint256) public balances;\n\n    function transfer(address to, uint256 amount) public {\n        // Automatically reverts on overflow/underflow\n        balances[msg.sender] -= amount;\n        balances[to] += amount;\n    }\n}\n```\n\n**For Solidity < 0.8.0, use SafeMath:**\n```solidity\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\ncontract SecureToken {\n    using SafeMath for uint256;\n    mapping(address => uint256) public balances;\n\n    function transfer(address to, uint256 amount) public {\n        balances[msg.sender] = balances[msg.sender].sub(amount);\n        balances[to] = balances[to].add(amount);\n    }\n}\n```\n\n### 3. Access Control\n\n**Vulnerable Code:**\n```solidity\n// VULNERABLE: Anyone can call critical functions\ncontract VulnerableContract {\n    address public owner;\n\n    function withdraw(uint256 amount) public {\n        // No access control!\n        payable(msg.sender).transfer(amount);\n    }\n}\n```\n\n**Secure Pattern:**\n```solidity\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\ncontract SecureContract is Ownable {\n    function withdraw(uint256 amount) public onlyOwner {\n        payable(owner()).transfer(amount);\n    }\n}\n\n// Or implement custom role-based access\ncontract RoleBasedContract {\n    mapping(address => bool) public admins;\n\n    modifier onlyAdmin() {\n        require(admins[msg.sender], \"Not an admin\");\n        _;\n    }\n\n    function criticalFunction() public onlyAdmin {\n        // Protected function\n    }\n}\n```\n\n### 4. Front-Running\n\n**Vulnerable:**\n```solidity\n// VULNERABLE TO FRONT-RUNNING\ncontract VulnerableDEX {\n    function swap(uint256 amount, uint256 minOutput) public {\n        // Attacker sees this in mempool and front-runs\n        uint256 output = calculateOutput(amount);\n        require(output >= minOutput, \"Slippage too high\");\n        // Perform swap\n    }\n}\n```\n\n**Mitigation:**\n```solidity\ncontract SecureDEX {\n    mapping(bytes32 => bool) public usedCommitments;\n\n    // Step 1: Commit to trade\n    function commitTrade(bytes32 commitment) public {\n        usedCommitments[commitment] = true;\n    }\n\n    // Step 2: Reveal trade (next block)\n    function revealTrade(\n        uint256 amount,\n        uint256 minOutput,\n        bytes32 secret\n    ) public {\n        bytes32 commitment = keccak256(abi.encodePacked(\n            msg.sender, amount, minOutput, secret\n        ));\n        require(usedCommitments[commitment]",
  "tokenEstimate": {
    "tier1": 18.2,
    "tier2": 282.1,
    "tier3": 1753.7
  },
  "fullDefinition": "---\nname: solidity-security\ndescription: Master smart contract security best practices to prevent common vulnerabilities and implement secure Solidity patterns. Use when writing smart contracts, auditing existing contracts, or implementing security measures for blockchain applications.\n---\n\n# Solidity Security\n\nMaster smart contract security best practices, vulnerability prevention, and secure Solidity development patterns.\n\n## When to Use This Skill\n\n- Writing secure smart contracts\n- Auditing existing contracts for vulnerabilities\n- Implementing secure DeFi protocols\n- Preventing reentrancy, overflow, and access control issues\n- Optimizing gas usage while maintaining security\n- Preparing contracts for professional audits\n- Understanding common attack vectors\n\n## Critical Vulnerabilities\n\n### 1. Reentrancy\nAttacker calls back into your contract before state is updated.\n\n**Vulnerable Code:**\n```solidity\n// VULNERABLE TO REENTRANCY\ncontract VulnerableBank {\n    mapping(address => uint256) public balances;\n\n    function withdraw() public {\n        uint256 amount = balances[msg.sender];\n\n        // DANGER: External call before state update\n        (bool success, ) = msg.sender.call{value: amount}(\"\");\n        require(success);\n\n        balances[msg.sender] = 0;  // Too late!\n    }\n}\n```\n\n**Secure Pattern (Checks-Effects-Interactions):**\n```solidity\ncontract SecureBank {\n    mapping(address => uint256) public balances;\n\n    function withdraw() public {\n        uint256 amount = balances[msg.sender];\n        require(amount > 0, \"Insufficient balance\");\n\n        // EFFECTS: Update state BEFORE external call\n        balances[msg.sender] = 0;\n\n        // INTERACTIONS: External call last\n        (bool success, ) = msg.sender.call{value: amount}(\"\");\n        require(success, \"Transfer failed\");\n    }\n}\n```\n\n**Alternative: ReentrancyGuard**\n```solidity\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\ncontract SecureBank is ReentrancyGuard {\n    mapping(address => uint256) public balances;\n\n    function withdraw() public nonReentrant {\n        uint256 amount = balances[msg.sender];\n        require(amount > 0, \"Insufficient balance\");\n\n        balances[msg.sender] = 0;\n\n        (bool success, ) = msg.sender.call{value: amount}(\"\");\n        require(success, \"Transfer failed\");\n    }\n}\n```\n\n### 2. Integer Overflow/Underflow\n\n**Vulnerable Code (Solidity < 0.8.0):**\n```solidity\n// VULNERABLE\ncontract VulnerableToken {\n    mapping(address => uint256) public balances;\n\n    function transfer(address to, uint256 amount) public {\n        // No overflow check - can wrap around\n        balances[msg.sender] -= amount;  // Can underflow!\n        balances[to] += amount;          // Can overflow!\n    }\n}\n```\n\n**Secure Pattern (Solidity >= 0.8.0):**\n```solidity\n// Solidity 0.8+ has built-in overflow/underflow checks\ncontract SecureToken {\n    mapping(address => uint256) public balances;\n\n    function transfer(address to, uint256 amount) public {\n        // Automatically reverts on overflow/underflow\n        balances[msg.sender] -= amount;\n        balances[to] += amount;\n    }\n}\n```\n\n**For Solidity < 0.8.0, use SafeMath:**\n```solidity\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\ncontract SecureToken {\n    using SafeMath for uint256;\n    mapping(address => uint256) public balances;\n\n    function transfer(address to, uint256 amount) public {\n        balances[msg.sender] = balances[msg.sender].sub(amount);\n        balances[to] = balances[to].add(amount);\n    }\n}\n```\n\n### 3. Access Control\n\n**Vulnerable Code:**\n```solidity\n// VULNERABLE: Anyone can call critical functions\ncontract VulnerableContract {\n    address public owner;\n\n    function withdraw(uint256 amount) public {\n        // No access control!\n        payable(msg.sender).transfer(amount);\n    }\n}\n```\n\n**Secure Pattern:**\n```solidity\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\ncontract SecureContract is Ownable {\n    function withdraw(uint256 amount) public onlyOwner {\n        payable(owner()).transfer(amount);\n    }\n}\n\n// Or implement custom role-based access\ncontract RoleBasedContract {\n    mapping(address => bool) public admins;\n\n    modifier onlyAdmin() {\n        require(admins[msg.sender], \"Not an admin\");\n        _;\n    }\n\n    function criticalFunction() public onlyAdmin {\n        // Protected function\n    }\n}\n```\n\n### 4. Front-Running\n\n**Vulnerable:**\n```solidity\n// VULNERABLE TO FRONT-RUNNING\ncontract VulnerableDEX {\n    function swap(uint256 amount, uint256 minOutput) public {\n        // Attacker sees this in mempool and front-runs\n        uint256 output = calculateOutput(amount);\n        require(output >= minOutput, \"Slippage too high\");\n        // Perform swap\n    }\n}\n```\n\n**Mitigation:**\n```solidity\ncontract SecureDEX {\n    mapping(bytes32 => bool) public usedCommitments;\n\n    // Step 1: Commit to trade\n    function commitTrade(bytes32 commitment) public {\n        usedCommitments[commitment] = true;\n    }\n\n    // Step 2: Reveal trade (next block)\n    function revealTrade(\n        uint256 amount,\n        uint256 minOutput,\n        bytes32 secret\n    ) public {\n        bytes32 commitment = keccak256(abi.encodePacked(\n            msg.sender, amount, minOutput, secret\n        ));\n        require(usedCommitments[commitment], \"Invalid commitment\");\n        // Perform swap\n    }\n}\n```\n\n## Security Best Practices\n\n### Checks-Effects-Interactions Pattern\n```solidity\ncontract SecurePattern {\n    mapping(address => uint256) public balances;\n\n    function withdraw(uint256 amount) public {\n        // 1. CHECKS: Validate conditions\n        require(amount <= balances[msg.sender], \"Insufficient balance\");\n        require(amount > 0, \"Amount must be positive\");\n\n        // 2. EFFECTS: Update state\n        balances[msg.sender] -= amount;\n\n        // 3. INTERACTIONS: External calls last\n        (bool success, ) = msg.sender.call{value: amount}(\"\");\n        require(success, \"Transfer failed\");\n    }\n}\n```\n\n### Pull Over Push Pattern\n```solidity\n// Prefer this (pull)\ncontract SecurePayment {\n    mapping(address => uint256) public pendingWithdrawals;\n\n    function recordPayment(address recipient, uint256 amount) internal {\n        pendingWithdrawals[recipient] += amount;\n    }\n\n    function withdraw() public {\n        uint256 amount = pendingWithdrawals[msg.sender];\n        require(amount > 0, \"Nothing to withdraw\");\n\n        pendingWithdrawals[msg.sender] = 0;\n        payable(msg.sender).transfer(amount);\n    }\n}\n\n// Over this (push)\ncontract RiskyPayment {\n    function distributePayments(address[] memory recipients, uint256[] memory amounts) public {\n        for (uint i = 0; i < recipients.length; i++) {\n            // If any transfer fails, entire batch fails\n            payable(recipients[i]).transfer(amounts[i]);\n        }\n    }\n}\n```\n\n### Input Validation\n```solidity\ncontract SecureContract {\n    function transfer(address to, uint256 amount) public {\n        // Validate inputs\n        require(to != address(0), \"Invalid recipient\");\n        require(to != address(this), \"Cannot send to contract\");\n        require(amount > 0, \"Amount must be positive\");\n        require(amount <= balances[msg.sender], \"Insufficient balance\");\n\n        // Proceed with transfer\n        balances[msg.sender] -= amount;\n        balances[to] += amount;\n    }\n}\n```\n\n### Emergency Stop (Circuit Breaker)\n```solidity\nimport \"@openzeppelin/contracts/security/Pausable.sol\";\n\ncontract EmergencyStop is Pausable, Ownable {\n    function criticalFunction() public whenNotPaused {\n        // Function logic\n    }\n\n    function emergencyStop() public onlyOwner {\n        _pause();\n    }\n\n    function resume() public onlyOwner {\n        _unpause();\n    }\n}\n```\n\n## Gas Optimization\n\n### Use `uint256` Instead of Smaller Types\n```solidity\n// More gas efficient\ncontract GasEfficient {\n    uint256 public value;  // Optimal\n\n    function set(uint256 _value) public {\n        value = _value;\n    }\n}\n\n// Less efficient\ncontract GasInefficient {\n    uint8 public value;  // Still uses 256-bit slot\n\n    function set(uint8 _value) public {\n        value = _value;  // Extra gas for type conversion\n    }\n}\n```\n\n### Pack Storage Variables\n```solidity\n// Gas efficient (3 variables in 1 slot)\ncontract PackedStorage {\n    uint128 public a;  // Slot 0\n    uint64 public b;   // Slot 0\n    uint64 public c;   // Slot 0\n    uint256 public d;  // Slot 1\n}\n\n// Gas inefficient (each variable in separate slot)\ncontract UnpackedStorage {\n    uint256 public a;  // Slot 0\n    uint256 public b;  // Slot 1\n    uint256 public c;  // Slot 2\n    uint256 public d;  // Slot 3\n}\n```\n\n### Use `calldata` Instead of `memory` for Function Arguments\n```solidity\ncontract GasOptimized {\n    // More gas efficient\n    function processData(uint256[] calldata data) public pure returns (uint256) {\n        return data[0];\n    }\n\n    // Less efficient\n    function processDataMemory(uint256[] memory data) public pure returns (uint256) {\n        return data[0];\n    }\n}\n```\n\n### Use Events for Data Storage (When Appropriate)\n```solidity\ncontract EventStorage {\n    // Emitting events is cheaper than storage\n    event DataStored(address indexed user, uint256 indexed id, bytes data);\n\n    function storeData(uint256 id, bytes calldata data) public {\n        emit DataStored(msg.sender, id, data);\n        // Don't store in contract storage unless needed\n    }\n}\n```\n\n## Common Vulnerabilities Checklist\n\n```solidity\n// Security Checklist Contract\ncontract SecurityChecklist {\n    /**\n     * [ ] Reentrancy protection (ReentrancyGuard or CEI pattern)\n     * [ ] Integer overflow/underflow (Solidity 0.8+ or SafeMath)\n     * [ ] Access control (Ownable, roles, modifiers)\n     * [ ] Input validation (require statements)\n     * [ ] Front-running mitigation (commit-reveal if applicable)\n     * [ ] Gas optimization (packed storage, calldata)\n     * [ ] Emergency stop mechanism (Pausable)\n     * [ ] Pull over push pattern for payments\n     * [ ] No delegatecall to untrusted contracts\n     * [ ] No tx.origin for authentication (use msg.sender)\n     * [ ] Proper event emission\n     * [ ] External calls at end of function\n     * [ ] Check return values of external calls\n     * [ ] No hardcoded addresses\n     * [ ] Upgrade mechanism (if proxy pattern)\n     */\n}\n```\n\n## Testing for Security\n\n```javascript\n// Hardhat test example\nconst { expect } = require(\"chai\");\nconst { ethers } = require(\"hardhat\");\n\ndescribe(\"Security Tests\", function () {\n    it(\"Should prevent reentrancy attack\", async function () {\n        const [attacker] = await ethers.getSigners();\n\n        const VictimBank = await ethers.getContractFactory(\"SecureBank\");\n        const bank = await VictimBank.deploy();\n\n        const Attacker = await ethers.getContractFactory(\"ReentrancyAttacker\");\n        const attackerContract = await Attacker.deploy(bank.address);\n\n        // Deposit funds\n        await bank.deposit({value: ethers.utils.parseEther(\"10\")});\n\n        // Attempt reentrancy attack\n        await expect(\n            attackerContract.attack({value: ethers.utils.parseEther(\"1\")})\n        ).to.be.revertedWith(\"ReentrancyGuard: reentrant call\");\n    });\n\n    it(\"Should prevent integer overflow\", async function () {\n        const Token = await ethers.getContractFactory(\"SecureToken\");\n        const token = await Token.deploy();\n\n        // Attempt overflow\n        await expect(\n            token.transfer(attacker.address, ethers.constants.MaxUint256)\n        ).to.be.reverted;\n    });\n\n    it(\"Should enforce access control\", async function () {\n        const [owner, attacker] = await ethers.getSigners();\n\n        const Contract = await ethers.getContractFactory(\"SecureContract\");\n        const contract = await Contract.deploy();\n\n        // Attempt unauthorized withdrawal\n        await expect(\n            contract.connect(attacker).withdraw(100)\n        ).to.be.revertedWith(\"Ownable: caller is not the owner\");\n    });\n});\n```\n\n## Audit Preparation\n\n```solidity\ncontract WellDocumentedContract {\n    /**\n     * @title Well Documented Contract\n     * @dev Example of proper documentation for audits\n     * @notice This contract handles user deposits and withdrawals\n     */\n\n    /// @notice Mapping of user balances\n    mapping(address => uint256) public balances;\n\n    /**\n     * @dev Deposits ETH into the contract\n     * @notice Anyone can deposit funds\n     */\n    function deposit() public payable {\n        require(msg.value > 0, \"Must send ETH\");\n        balances[msg.sender] += msg.value;\n    }\n\n    /**\n     * @dev Withdraws user's balance\n     * @notice Follows CEI pattern to prevent reentrancy\n     * @param amount Amount to withdraw in wei\n     */\n    function withdraw(uint256 amount) public {\n        // CHECKS\n        require(amount <= balances[msg.sender], \"Insufficient balance\");\n\n        // EFFECTS\n        balances[msg.sender] -= amount;\n\n        // INTERACTIONS\n        (bool success, ) = msg.sender.call{value: amount}(\"\");\n        require(success, \"Transfer failed\");\n    }\n}\n```\n\n## Resources\n\n- **references/reentrancy.md**: Comprehensive reentrancy prevention\n- **references/access-control.md**: Role-based access patterns\n- **references/overflow-underflow.md**: SafeMath and integer safety\n- **references/gas-optimization.md**: Gas saving techniques\n- **references/vulnerability-patterns.md**: Common vulnerability catalog\n- **assets/solidity-contracts-templates.sol**: Secure contract templates\n- **assets/security-checklist.md**: Pre-audit checklist\n- **scripts/analyze-contract.sh**: Static analysis tools\n\n## Tools for Security Analysis\n\n- **Slither**: Static analysis tool\n- **Mythril**: Security analysis tool\n- **Echidna**: Fuzzing tool\n- **Manticore**: Symbolic execution\n- **Securify**: Automated security scanner\n\n## Common Pitfalls\n\n1. **Using `tx.origin` for Authentication**: Use `msg.sender` instead\n2. **Unchecked External Calls**: Always check return values\n3. **Delegatecall to Untrusted Contracts**: Can hijack your contract\n4. **Floating Pragma**: Pin to specific Solidity version\n5. **Missing Events**: Emit events for state changes\n6. **Excessive Gas in Loops**: Can hit block gas limit\n7. **No Upgrade Path**: Consider proxy patterns if upgrades needed\n"
}