{
  "id": "systems_programming_memory_safety_patterns",
  "name": "memory-safety-patterns",
  "source": "systems-programming",
  "originalPath": "plugins/systems-programming/skills/memory-safety-patterns/SKILL.md",
  "activationCriteria": "Implement memory-safe programming with RAII, ownership, smart pointers, and resource management across Rust, C++, and C. Use when writing safe systems code, managing resources, or preventing memory bu",
  "tier1_metadata": "memory-safety-patterns: Implement memory-safe programming with RAII, ownership, smart pointers, and resource management acro",
  "tier2_instructions": "# Memory Safety Patterns\n\nCross-language patterns for memory-safe programming including RAII, ownership, smart pointers, and resource management.\n\n## When to Use This Skill\n\n- Writing memory-safe systems code\n- Managing resources (files, sockets, memory)\n- Preventing use-after-free and leaks\n- Implementing RAII patterns\n- Choosing between languages for safety\n- Debugging memory issues\n\n## Core Concepts\n\n### 1. Memory Bug Categories\n\n| Bug Type | Description | Prevention |\n|----------|-------------|------------|\n| **Use-after-free** | Access freed memory | Ownership, RAII |\n| **Double-free** | Free same memory twice | Smart pointers |\n| **Memory leak** | Never free memory | RAII, GC |\n| **Buffer overflow** | Write past buffer end | Bounds checking |\n| **Dangling pointer** | Pointer to freed memory | Lifetime tracking |\n| **Data race** | Concurrent unsynchronized access | Ownership, Sync |\n\n### 2. Safety Spectrum\n\n```\nManual (C) \u2192 Smart Pointers (C++) \u2192 Ownership (Rust) \u2192 GC (Go, Java)\nLess safe                                              More safe\nMore control                                           Less control\n```\n\n## Patterns by Language\n\n### Pattern 1: RAII in C++\n\n```cpp\n// RAII: Resource Acquisition Is Initialization\n// Resource lifetime tied to object lifetime\n\n#include <memory>\n#include <fstream>\n#include <mutex>\n\n// File handle with RAII\nclass FileHandle {\npublic:\n    explicit FileHandle(const std::string& path)\n        : file_(path) {\n        if (!file_.is_open()) {\n            throw std::runtime_error(\"Failed to open file\");\n        }\n    }\n\n    // Destructor automatically closes file\n    ~FileHandle() = default; // fstream closes in its destructor\n\n    // Delete copy (prevent double-close)\n    FileHandle(const FileHandle&) = delete;\n    FileHandle& operator=(const FileHandle&) = delete;\n\n    // Allow move\n    FileHandle(FileHandle&&) = default;\n    FileHandle& operator=(FileHandle&&) = default;\n\n    void write(const std::string& data) {\n        file_ <",
  "tier3_resources": "< data;\n    }\n\nprivate:\n    std::fstream file_;\n};\n\n// Lock guard (RAII for mutexes)\nclass Database {\npublic:\n    void update(const std::string& key, const std::string& value) {\n        std::lock_guard<std::mutex> lock(mutex_); // Released on scope exit\n        data_[key] = value;\n    }\n\n    std::string get(const std::string& key) {\n        std::shared_lock<std::shared_mutex> lock(shared_mutex_);\n        return data_[key];\n    }\n\nprivate:\n    std::mutex mutex_;\n    std::shared_mutex shared_mutex_;\n    std::map<std::string, std::string> data_;\n};\n\n// Transaction with rollback (RAII)\ntemplate<typename T>\nclass Transaction {\npublic:\n    explicit Transaction(T& target)\n        : target_(target), backup_(target), committed_(false) {}\n\n    ~Transaction() {\n        if (!committed_) {\n            target_ = backup_; // Rollback\n        }\n    }\n\n    void commit() { committed_ = true; }\n\n    T& get() { return target_; }\n\nprivate:\n    T& target_;\n    T backup_;\n    bool committed_;\n};\n```\n\n### Pattern 2: Smart Pointers in C++\n\n```cpp\n#include <memory>\n\n// unique_ptr: Single ownership\nclass Engine {\npublic:\n    void start() { /* ... */ }\n};\n\nclass Car {\npublic:\n    Car() : engine_(std::make_unique<Engine>()) {}\n\n    void start() {\n        engine_->start();\n    }\n\n    // Transfer ownership\n    std::unique_ptr<Engine> extractEngine() {\n        return std::move(engine_);\n    }\n\nprivate:\n    std::unique_ptr<Engine> engine_;\n};\n\n// shared_ptr: Shared ownership\nclass Node {\npublic:\n    std::string data;\n    std::shared_ptr<Node> next;\n\n    // Use weak_ptr to break cycles\n    std::weak_ptr<Node> parent;\n};\n\nvoid sharedPtrExample() {\n    auto node1 = std::make_shared<Node>();\n    auto node2 = std::make_shared<Node>();\n\n    node1->next = node2;\n    node2->parent = node1; // Weak reference prevents cycle\n\n    // Access weak_ptr\n    if (auto parent = node2->parent.lock()) {\n        // parent is valid shared_ptr\n    }\n}\n\n// Custom deleter for resources\nclass Socket {\npublic:\n    static void close(int* fd) {\n        if (fd && *fd >= 0) {\n            ::close(*fd);\n            delete fd;\n        }\n    }\n};\n\nauto createSocket() {\n    int fd = socket(AF_INET, SOCK_STREAM, 0);\n    return std::unique_ptr<int, decltype(&Socket::close)>(\n        new int(fd),\n        &Socket::close\n    );\n}\n\n// make_unique/make_shared best practices\nvoid bestPractices() {\n    // Good: Exception safe, single allocation\n    auto ptr = std::make_shared<Widget>();\n\n    // Bad: Two allocations, not exception safe\n    std::shared_ptr<Widget> ptr2(new Widget());\n\n    // For arrays\n    auto arr = std::make_unique<int[]>(10);\n}\n```\n\n### Pattern 3: Ownership in Rust\n\n```rust\n// Move semantics (default)\nfn move_example() {\n    let s1 = String::from(\"hello\");\n    let s2 = s1; // s1 is MOVED, no longer valid\n\n    // println!(\"{}\", s1); // Compile error!\n    println!(\"{}\", s2);\n}\n\n// Borrowing (references)\nfn borrow_example() {\n    let s = String::from(\"hello\");\n\n    // Immutable borrow (multiple allowed)\n    l",
  "tokenEstimate": {
    "tier1": 16.900000000000002,
    "tier2": 344.5,
    "tier3": 1753.7
  },
  "fullDefinition": "---\nname: memory-safety-patterns\ndescription: Implement memory-safe programming with RAII, ownership, smart pointers, and resource management across Rust, C++, and C. Use when writing safe systems code, managing resources, or preventing memory bugs.\n---\n\n# Memory Safety Patterns\n\nCross-language patterns for memory-safe programming including RAII, ownership, smart pointers, and resource management.\n\n## When to Use This Skill\n\n- Writing memory-safe systems code\n- Managing resources (files, sockets, memory)\n- Preventing use-after-free and leaks\n- Implementing RAII patterns\n- Choosing between languages for safety\n- Debugging memory issues\n\n## Core Concepts\n\n### 1. Memory Bug Categories\n\n| Bug Type | Description | Prevention |\n|----------|-------------|------------|\n| **Use-after-free** | Access freed memory | Ownership, RAII |\n| **Double-free** | Free same memory twice | Smart pointers |\n| **Memory leak** | Never free memory | RAII, GC |\n| **Buffer overflow** | Write past buffer end | Bounds checking |\n| **Dangling pointer** | Pointer to freed memory | Lifetime tracking |\n| **Data race** | Concurrent unsynchronized access | Ownership, Sync |\n\n### 2. Safety Spectrum\n\n```\nManual (C) \u2192 Smart Pointers (C++) \u2192 Ownership (Rust) \u2192 GC (Go, Java)\nLess safe                                              More safe\nMore control                                           Less control\n```\n\n## Patterns by Language\n\n### Pattern 1: RAII in C++\n\n```cpp\n// RAII: Resource Acquisition Is Initialization\n// Resource lifetime tied to object lifetime\n\n#include <memory>\n#include <fstream>\n#include <mutex>\n\n// File handle with RAII\nclass FileHandle {\npublic:\n    explicit FileHandle(const std::string& path)\n        : file_(path) {\n        if (!file_.is_open()) {\n            throw std::runtime_error(\"Failed to open file\");\n        }\n    }\n\n    // Destructor automatically closes file\n    ~FileHandle() = default; // fstream closes in its destructor\n\n    // Delete copy (prevent double-close)\n    FileHandle(const FileHandle&) = delete;\n    FileHandle& operator=(const FileHandle&) = delete;\n\n    // Allow move\n    FileHandle(FileHandle&&) = default;\n    FileHandle& operator=(FileHandle&&) = default;\n\n    void write(const std::string& data) {\n        file_ << data;\n    }\n\nprivate:\n    std::fstream file_;\n};\n\n// Lock guard (RAII for mutexes)\nclass Database {\npublic:\n    void update(const std::string& key, const std::string& value) {\n        std::lock_guard<std::mutex> lock(mutex_); // Released on scope exit\n        data_[key] = value;\n    }\n\n    std::string get(const std::string& key) {\n        std::shared_lock<std::shared_mutex> lock(shared_mutex_);\n        return data_[key];\n    }\n\nprivate:\n    std::mutex mutex_;\n    std::shared_mutex shared_mutex_;\n    std::map<std::string, std::string> data_;\n};\n\n// Transaction with rollback (RAII)\ntemplate<typename T>\nclass Transaction {\npublic:\n    explicit Transaction(T& target)\n        : target_(target), backup_(target), committed_(false) {}\n\n    ~Transaction() {\n        if (!committed_) {\n            target_ = backup_; // Rollback\n        }\n    }\n\n    void commit() { committed_ = true; }\n\n    T& get() { return target_; }\n\nprivate:\n    T& target_;\n    T backup_;\n    bool committed_;\n};\n```\n\n### Pattern 2: Smart Pointers in C++\n\n```cpp\n#include <memory>\n\n// unique_ptr: Single ownership\nclass Engine {\npublic:\n    void start() { /* ... */ }\n};\n\nclass Car {\npublic:\n    Car() : engine_(std::make_unique<Engine>()) {}\n\n    void start() {\n        engine_->start();\n    }\n\n    // Transfer ownership\n    std::unique_ptr<Engine> extractEngine() {\n        return std::move(engine_);\n    }\n\nprivate:\n    std::unique_ptr<Engine> engine_;\n};\n\n// shared_ptr: Shared ownership\nclass Node {\npublic:\n    std::string data;\n    std::shared_ptr<Node> next;\n\n    // Use weak_ptr to break cycles\n    std::weak_ptr<Node> parent;\n};\n\nvoid sharedPtrExample() {\n    auto node1 = std::make_shared<Node>();\n    auto node2 = std::make_shared<Node>();\n\n    node1->next = node2;\n    node2->parent = node1; // Weak reference prevents cycle\n\n    // Access weak_ptr\n    if (auto parent = node2->parent.lock()) {\n        // parent is valid shared_ptr\n    }\n}\n\n// Custom deleter for resources\nclass Socket {\npublic:\n    static void close(int* fd) {\n        if (fd && *fd >= 0) {\n            ::close(*fd);\n            delete fd;\n        }\n    }\n};\n\nauto createSocket() {\n    int fd = socket(AF_INET, SOCK_STREAM, 0);\n    return std::unique_ptr<int, decltype(&Socket::close)>(\n        new int(fd),\n        &Socket::close\n    );\n}\n\n// make_unique/make_shared best practices\nvoid bestPractices() {\n    // Good: Exception safe, single allocation\n    auto ptr = std::make_shared<Widget>();\n\n    // Bad: Two allocations, not exception safe\n    std::shared_ptr<Widget> ptr2(new Widget());\n\n    // For arrays\n    auto arr = std::make_unique<int[]>(10);\n}\n```\n\n### Pattern 3: Ownership in Rust\n\n```rust\n// Move semantics (default)\nfn move_example() {\n    let s1 = String::from(\"hello\");\n    let s2 = s1; // s1 is MOVED, no longer valid\n\n    // println!(\"{}\", s1); // Compile error!\n    println!(\"{}\", s2);\n}\n\n// Borrowing (references)\nfn borrow_example() {\n    let s = String::from(\"hello\");\n\n    // Immutable borrow (multiple allowed)\n    let len = calculate_length(&s);\n    println!(\"{} has length {}\", s, len);\n\n    // Mutable borrow (only one allowed)\n    let mut s = String::from(\"hello\");\n    change(&mut s);\n}\n\nfn calculate_length(s: &String) -> usize {\n    s.len()\n} // s goes out of scope, but doesn't drop since borrowed\n\nfn change(s: &mut String) {\n    s.push_str(\", world\");\n}\n\n// Lifetimes: Compiler tracks reference validity\nfn longest<'a>(x: &'a str, y: &'a str) -> &'a str {\n    if x.len() > y.len() { x } else { y }\n}\n\n// Struct with references needs lifetime annotation\nstruct ImportantExcerpt<'a> {\n    part: &'a str,\n}\n\nimpl<'a> ImportantExcerpt<'a> {\n    fn level(&self) -> i32 {\n        3\n    }\n\n    // Lifetime elision: compiler infers 'a for &self\n    fn announce_and_return_part(&self, announcement: &str) -> &str {\n        println!(\"Attention: {}\", announcement);\n        self.part\n    }\n}\n\n// Interior mutability\nuse std::cell::{Cell, RefCell};\nuse std::rc::Rc;\n\nstruct Stats {\n    count: Cell<i32>,           // Copy types\n    data: RefCell<Vec<String>>, // Non-Copy types\n}\n\nimpl Stats {\n    fn increment(&self) {\n        self.count.set(self.count.get() + 1);\n    }\n\n    fn add_data(&self, item: String) {\n        self.data.borrow_mut().push(item);\n    }\n}\n\n// Rc for shared ownership (single-threaded)\nfn rc_example() {\n    let data = Rc::new(vec![1, 2, 3]);\n    let data2 = Rc::clone(&data); // Increment reference count\n\n    println!(\"Count: {}\", Rc::strong_count(&data)); // 2\n}\n\n// Arc for shared ownership (thread-safe)\nuse std::sync::Arc;\nuse std::thread;\n\nfn arc_example() {\n    let data = Arc::new(vec![1, 2, 3]);\n\n    let handles: Vec<_> = (0..3)\n        .map(|_| {\n            let data = Arc::clone(&data);\n            thread::spawn(move || {\n                println!(\"{:?}\", data);\n            })\n        })\n        .collect();\n\n    for handle in handles {\n        handle.join().unwrap();\n    }\n}\n```\n\n### Pattern 4: Safe Resource Management in C\n\n```c\n// C doesn't have RAII, but we can use patterns\n\n#include <stdlib.h>\n#include <stdio.h>\n\n// Pattern: goto cleanup\nint process_file(const char* path) {\n    FILE* file = NULL;\n    char* buffer = NULL;\n    int result = -1;\n\n    file = fopen(path, \"r\");\n    if (!file) {\n        goto cleanup;\n    }\n\n    buffer = malloc(1024);\n    if (!buffer) {\n        goto cleanup;\n    }\n\n    // Process file...\n    result = 0;\n\ncleanup:\n    if (buffer) free(buffer);\n    if (file) fclose(file);\n    return result;\n}\n\n// Pattern: Opaque pointer with create/destroy\ntypedef struct Context Context;\n\nContext* context_create(void);\nvoid context_destroy(Context* ctx);\nint context_process(Context* ctx, const char* data);\n\n// Implementation\nstruct Context {\n    int* data;\n    size_t size;\n    FILE* log;\n};\n\nContext* context_create(void) {\n    Context* ctx = calloc(1, sizeof(Context));\n    if (!ctx) return NULL;\n\n    ctx->data = malloc(100 * sizeof(int));\n    if (!ctx->data) {\n        free(ctx);\n        return NULL;\n    }\n\n    ctx->log = fopen(\"log.txt\", \"w\");\n    if (!ctx->log) {\n        free(ctx->data);\n        free(ctx);\n        return NULL;\n    }\n\n    return ctx;\n}\n\nvoid context_destroy(Context* ctx) {\n    if (ctx) {\n        if (ctx->log) fclose(ctx->log);\n        if (ctx->data) free(ctx->data);\n        free(ctx);\n    }\n}\n\n// Pattern: Cleanup attribute (GCC/Clang extension)\n#define AUTO_FREE __attribute__((cleanup(auto_free_func)))\n\nvoid auto_free_func(void** ptr) {\n    free(*ptr);\n}\n\nvoid auto_free_example(void) {\n    AUTO_FREE char* buffer = malloc(1024);\n    // buffer automatically freed at end of scope\n}\n```\n\n### Pattern 5: Bounds Checking\n\n```cpp\n// C++: Use containers instead of raw arrays\n#include <vector>\n#include <array>\n#include <span>\n\nvoid safe_array_access() {\n    std::vector<int> vec = {1, 2, 3, 4, 5};\n\n    // Safe: throws std::out_of_range\n    try {\n        int val = vec.at(10);\n    } catch (const std::out_of_range& e) {\n        // Handle error\n    }\n\n    // Unsafe but faster (no bounds check)\n    int val = vec[2];\n\n    // Modern C++20: std::span for array views\n    std::span<int> view(vec);\n    // Iterators are bounds-safe\n    for (int& x : view) {\n        x *= 2;\n    }\n}\n\n// Fixed-size arrays\nvoid fixed_array() {\n    std::array<int, 5> arr = {1, 2, 3, 4, 5};\n\n    // Compile-time size known\n    static_assert(arr.size() == 5);\n\n    // Safe access\n    int val = arr.at(2);\n}\n```\n\n```rust\n// Rust: Bounds checking by default\n\nfn rust_bounds_checking() {\n    let vec = vec![1, 2, 3, 4, 5];\n\n    // Runtime bounds check (panics if out of bounds)\n    let val = vec[2];\n\n    // Explicit option (no panic)\n    match vec.get(10) {\n        Some(val) => println!(\"Got {}\", val),\n        None => println!(\"Index out of bounds\"),\n    }\n\n    // Iterators (no bounds checking needed)\n    for val in &vec {\n        println!(\"{}\", val);\n    }\n\n    // Slices are bounds-checked\n    let slice = &vec[1..3]; // [2, 3]\n}\n```\n\n### Pattern 6: Preventing Data Races\n\n```cpp\n// C++: Thread-safe shared state\n#include <mutex>\n#include <shared_mutex>\n#include <atomic>\n\nclass ThreadSafeCounter {\npublic:\n    void increment() {\n        // Atomic operations\n        count_.fetch_add(1, std::memory_order_relaxed);\n    }\n\n    int get() const {\n        return count_.load(std::memory_order_relaxed);\n    }\n\nprivate:\n    std::atomic<int> count_{0};\n};\n\nclass ThreadSafeMap {\npublic:\n    void write(const std::string& key, int value) {\n        std::unique_lock lock(mutex_);\n        data_[key] = value;\n    }\n\n    std::optional<int> read(const std::string& key) {\n        std::shared_lock lock(mutex_);\n        auto it = data_.find(key);\n        if (it != data_.end()) {\n            return it->second;\n        }\n        return std::nullopt;\n    }\n\nprivate:\n    mutable std::shared_mutex mutex_;\n    std::map<std::string, int> data_;\n};\n```\n\n```rust\n// Rust: Data race prevention at compile time\n\nuse std::sync::{Arc, Mutex, RwLock};\nuse std::sync::atomic::{AtomicI32, Ordering};\nuse std::thread;\n\n// Atomic for simple types\nfn atomic_example() {\n    let counter = Arc::new(AtomicI32::new(0));\n\n    let handles: Vec<_> = (0..10)\n        .map(|_| {\n            let counter = Arc::clone(&counter);\n            thread::spawn(move || {\n                counter.fetch_add(1, Ordering::SeqCst);\n            })\n        })\n        .collect();\n\n    for handle in handles {\n        handle.join().unwrap();\n    }\n\n    println!(\"Counter: {}\", counter.load(Ordering::SeqCst));\n}\n\n// Mutex for complex types\nfn mutex_example() {\n    let data = Arc::new(Mutex::new(vec![]));\n\n    let handles: Vec<_> = (0..10)\n        .map(|i| {\n            let data = Arc::clone(&data);\n            thread::spawn(move || {\n                let mut vec = data.lock().unwrap();\n                vec.push(i);\n            })\n        })\n        .collect();\n\n    for handle in handles {\n        handle.join().unwrap();\n    }\n}\n\n// RwLock for read-heavy workloads\nfn rwlock_example() {\n    let data = Arc::new(RwLock::new(HashMap::new()));\n\n    // Multiple readers OK\n    let read_guard = data.read().unwrap();\n\n    // Writer blocks readers\n    let write_guard = data.write().unwrap();\n}\n```\n\n## Best Practices\n\n### Do's\n- **Prefer RAII** - Tie resource lifetime to scope\n- **Use smart pointers** - Avoid raw pointers in C++\n- **Understand ownership** - Know who owns what\n- **Check bounds** - Use safe access methods\n- **Use tools** - AddressSanitizer, Valgrind, Miri\n\n### Don'ts\n- **Don't use raw pointers** - Unless interfacing with C\n- **Don't return local references** - Dangling pointer\n- **Don't ignore compiler warnings** - They catch bugs\n- **Don't use `unsafe` carelessly** - In Rust, minimize it\n- **Don't assume thread safety** - Be explicit\n\n## Debugging Tools\n\n```bash\n# AddressSanitizer (Clang/GCC)\nclang++ -fsanitize=address -g source.cpp\n\n# Valgrind\nvalgrind --leak-check=full ./program\n\n# Rust Miri (undefined behavior detector)\ncargo +nightly miri run\n\n# ThreadSanitizer\nclang++ -fsanitize=thread -g source.cpp\n```\n\n## Resources\n\n- [C++ Core Guidelines](https://isocpp.github.io/CppCoreGuidelines/)\n- [Rust Ownership](https://doc.rust-lang.org/book/ch04-00-understanding-ownership.html)\n- [AddressSanitizer](https://clang.llvm.org/docs/AddressSanitizer.html)\n"
}