{
  "id": "payment_processing_billing_automation",
  "name": "billing-automation",
  "source": "payment-processing",
  "originalPath": "plugins/payment-processing/skills/billing-automation/SKILL.md",
  "activationCriteria": "Build automated billing systems for recurring payments, invoicing, subscription lifecycle, and dunning management. Use when implementing subscription billing, automating invoicing, or managing recurri",
  "tier1_metadata": "billing-automation: Build automated billing systems for recurring payments, invoicing, subscription lifecycle, and dunni",
  "tier2_instructions": "# Billing Automation\n\nMaster automated billing systems including recurring billing, invoice generation, dunning management, proration, and tax calculation.\n\n## When to Use This Skill\n\n- Implementing SaaS subscription billing\n- Automating invoice generation and delivery\n- Managing failed payment recovery (dunning)\n- Calculating prorated charges for plan changes\n- Handling sales tax, VAT, and GST\n- Processing usage-based billing\n- Managing billing cycles and renewals\n\n## Core Concepts\n\n### 1. Billing Cycles\n**Common Intervals:**\n- Monthly (most common for SaaS)\n- Annual (discounted long-term)\n- Quarterly\n- Weekly\n- Custom (usage-based, per-seat)\n\n### 2. Subscription States\n```\ntrial \u2192 active \u2192 past_due \u2192 canceled\n              \u2192 paused \u2192 resumed\n```\n\n### 3. Dunning Management\nAutomated process to recover failed payments through:\n- Retry schedules\n- Customer notifications\n- Grace periods\n- Account restrictions\n\n### 4. Proration\nAdjusting charges when:\n- Upgrading/downgrading mid-cycle\n- Adding/removing seats\n- Changing billing frequency\n\n## Quick Start\n\n```python\nfrom billing import BillingEngine, Subscription\n\n# Initialize billing engine\nbilling = BillingEngine()\n\n# Create subscription\nsubscription = billing.create_subscription(\n    customer_id=\"cus_123\",\n    plan_id=\"plan_pro_monthly\",\n    billing_cycle_anchor=datetime.now(),\n    trial_days=14\n)\n\n# Process billing cycle\nbilling.process_billing_cycle(subscription.id)\n```\n\n## Subscription Lifecycle Management\n\n```python\nfrom datetime import datetime, timedelta\nfrom enum import Enum\n\nclass SubscriptionStatus(Enum):\n    TRIAL = \"trial\"\n    ACTIVE = \"active\"\n    PAST_DUE = \"past_due\"\n    CANCELED = \"canceled\"\n    PAUSED = \"paused\"\n\nclass Subscription:\n    def __init__(self, customer_id, plan, billing_cycle_day=None):\n        self.id = generate_id()\n        self.customer_id = customer_id\n        self.plan = plan\n        self.status = SubscriptionStatus.TRIAL\n        self.current_period_start = datetime.now()\n        self.c",
  "tier3_resources": "urrent_period_end = self.current_period_start + timedelta(days=plan.trial_days or 30)\n        self.billing_cycle_day = billing_cycle_day or self.current_period_start.day\n        self.trial_end = datetime.now() + timedelta(days=plan.trial_days) if plan.trial_days else None\n\n    def start_trial(self, trial_days):\n        \"\"\"Start trial period.\"\"\"\n        self.status = SubscriptionStatus.TRIAL\n        self.trial_end = datetime.now() + timedelta(days=trial_days)\n        self.current_period_end = self.trial_end\n\n    def activate(self):\n        \"\"\"Activate subscription after trial or immediately.\"\"\"\n        self.status = SubscriptionStatus.ACTIVE\n        self.current_period_start = datetime.now()\n        self.current_period_end = self.calculate_next_billing_date()\n\n    def mark_past_due(self):\n        \"\"\"Mark subscription as past due after failed payment.\"\"\"\n        self.status = SubscriptionStatus.PAST_DUE\n        # Trigger dunning workflow\n\n    def cancel(self, at_period_end=True):\n        \"\"\"Cancel subscription.\"\"\"\n        if at_period_end:\n            self.cancel_at_period_end = True\n            # Will cancel when current period ends\n        else:\n            self.status = SubscriptionStatus.CANCELED\n            self.canceled_at = datetime.now()\n\n    def calculate_next_billing_date(self):\n        \"\"\"Calculate next billing date based on interval.\"\"\"\n        if self.plan.interval == 'month':\n            return self.current_period_start + timedelta(days=30)\n        elif self.plan.interval == 'year':\n            return self.current_period_start + timedelta(days=365)\n        elif self.plan.interval == 'week':\n            return self.current_period_start + timedelta(days=7)\n```\n\n## Billing Cycle Processing\n\n```python\nclass BillingEngine:\n    def process_billing_cycle(self, subscription_id):\n        \"\"\"Process billing for a subscription.\"\"\"\n        subscription = self.get_subscription(subscription_id)\n\n        # Check if billing is due\n        if datetime.now() < subscription.current_period_end:\n            return\n\n        # Generate invoice\n        invoice = self.generate_invoice(subscription)\n\n        # Attempt payment\n        payment_result = self.charge_customer(\n            subscription.customer_id,\n            invoice.total\n        )\n\n        if payment_result.success:\n            # Payment successful\n            invoice.mark_paid()\n            subscription.advance_billing_period()\n            self.send_invoice(invoice)\n        else:\n            # Payment failed\n            subscription.mark_past_due()\n            self.start_dunning_process(subscription, invoice)\n\n    def generate_invoice(self, subscription):\n        \"\"\"Generate invoice for billing period.\"\"\"\n        invoice = Invoice(\n            customer_id=subscription.customer_id,\n            subscription_id=subscription.id,\n            period_start=subscription.current_period_start,\n            period_end=subscription.current_period_end\n        )\n\n        # Add subscription line item\n        in",
  "tokenEstimate": {
    "tier1": 16.900000000000002,
    "tier2": 305.5,
    "tier3": 1596.4
  },
  "fullDefinition": "---\nname: billing-automation\ndescription: Build automated billing systems for recurring payments, invoicing, subscription lifecycle, and dunning management. Use when implementing subscription billing, automating invoicing, or managing recurring payment systems.\n---\n\n# Billing Automation\n\nMaster automated billing systems including recurring billing, invoice generation, dunning management, proration, and tax calculation.\n\n## When to Use This Skill\n\n- Implementing SaaS subscription billing\n- Automating invoice generation and delivery\n- Managing failed payment recovery (dunning)\n- Calculating prorated charges for plan changes\n- Handling sales tax, VAT, and GST\n- Processing usage-based billing\n- Managing billing cycles and renewals\n\n## Core Concepts\n\n### 1. Billing Cycles\n**Common Intervals:**\n- Monthly (most common for SaaS)\n- Annual (discounted long-term)\n- Quarterly\n- Weekly\n- Custom (usage-based, per-seat)\n\n### 2. Subscription States\n```\ntrial \u2192 active \u2192 past_due \u2192 canceled\n              \u2192 paused \u2192 resumed\n```\n\n### 3. Dunning Management\nAutomated process to recover failed payments through:\n- Retry schedules\n- Customer notifications\n- Grace periods\n- Account restrictions\n\n### 4. Proration\nAdjusting charges when:\n- Upgrading/downgrading mid-cycle\n- Adding/removing seats\n- Changing billing frequency\n\n## Quick Start\n\n```python\nfrom billing import BillingEngine, Subscription\n\n# Initialize billing engine\nbilling = BillingEngine()\n\n# Create subscription\nsubscription = billing.create_subscription(\n    customer_id=\"cus_123\",\n    plan_id=\"plan_pro_monthly\",\n    billing_cycle_anchor=datetime.now(),\n    trial_days=14\n)\n\n# Process billing cycle\nbilling.process_billing_cycle(subscription.id)\n```\n\n## Subscription Lifecycle Management\n\n```python\nfrom datetime import datetime, timedelta\nfrom enum import Enum\n\nclass SubscriptionStatus(Enum):\n    TRIAL = \"trial\"\n    ACTIVE = \"active\"\n    PAST_DUE = \"past_due\"\n    CANCELED = \"canceled\"\n    PAUSED = \"paused\"\n\nclass Subscription:\n    def __init__(self, customer_id, plan, billing_cycle_day=None):\n        self.id = generate_id()\n        self.customer_id = customer_id\n        self.plan = plan\n        self.status = SubscriptionStatus.TRIAL\n        self.current_period_start = datetime.now()\n        self.current_period_end = self.current_period_start + timedelta(days=plan.trial_days or 30)\n        self.billing_cycle_day = billing_cycle_day or self.current_period_start.day\n        self.trial_end = datetime.now() + timedelta(days=plan.trial_days) if plan.trial_days else None\n\n    def start_trial(self, trial_days):\n        \"\"\"Start trial period.\"\"\"\n        self.status = SubscriptionStatus.TRIAL\n        self.trial_end = datetime.now() + timedelta(days=trial_days)\n        self.current_period_end = self.trial_end\n\n    def activate(self):\n        \"\"\"Activate subscription after trial or immediately.\"\"\"\n        self.status = SubscriptionStatus.ACTIVE\n        self.current_period_start = datetime.now()\n        self.current_period_end = self.calculate_next_billing_date()\n\n    def mark_past_due(self):\n        \"\"\"Mark subscription as past due after failed payment.\"\"\"\n        self.status = SubscriptionStatus.PAST_DUE\n        # Trigger dunning workflow\n\n    def cancel(self, at_period_end=True):\n        \"\"\"Cancel subscription.\"\"\"\n        if at_period_end:\n            self.cancel_at_period_end = True\n            # Will cancel when current period ends\n        else:\n            self.status = SubscriptionStatus.CANCELED\n            self.canceled_at = datetime.now()\n\n    def calculate_next_billing_date(self):\n        \"\"\"Calculate next billing date based on interval.\"\"\"\n        if self.plan.interval == 'month':\n            return self.current_period_start + timedelta(days=30)\n        elif self.plan.interval == 'year':\n            return self.current_period_start + timedelta(days=365)\n        elif self.plan.interval == 'week':\n            return self.current_period_start + timedelta(days=7)\n```\n\n## Billing Cycle Processing\n\n```python\nclass BillingEngine:\n    def process_billing_cycle(self, subscription_id):\n        \"\"\"Process billing for a subscription.\"\"\"\n        subscription = self.get_subscription(subscription_id)\n\n        # Check if billing is due\n        if datetime.now() < subscription.current_period_end:\n            return\n\n        # Generate invoice\n        invoice = self.generate_invoice(subscription)\n\n        # Attempt payment\n        payment_result = self.charge_customer(\n            subscription.customer_id,\n            invoice.total\n        )\n\n        if payment_result.success:\n            # Payment successful\n            invoice.mark_paid()\n            subscription.advance_billing_period()\n            self.send_invoice(invoice)\n        else:\n            # Payment failed\n            subscription.mark_past_due()\n            self.start_dunning_process(subscription, invoice)\n\n    def generate_invoice(self, subscription):\n        \"\"\"Generate invoice for billing period.\"\"\"\n        invoice = Invoice(\n            customer_id=subscription.customer_id,\n            subscription_id=subscription.id,\n            period_start=subscription.current_period_start,\n            period_end=subscription.current_period_end\n        )\n\n        # Add subscription line item\n        invoice.add_line_item(\n            description=subscription.plan.name,\n            amount=subscription.plan.amount,\n            quantity=subscription.quantity or 1\n        )\n\n        # Add usage-based charges if applicable\n        if subscription.has_usage_billing:\n            usage_charges = self.calculate_usage_charges(subscription)\n            invoice.add_line_item(\n                description=\"Usage charges\",\n                amount=usage_charges\n            )\n\n        # Calculate tax\n        tax = self.calculate_tax(invoice.subtotal, subscription.customer)\n        invoice.tax = tax\n\n        invoice.finalize()\n        return invoice\n\n    def charge_customer(self, customer_id, amount):\n        \"\"\"Charge customer using saved payment method.\"\"\"\n        customer = self.get_customer(customer_id)\n\n        try:\n            # Charge using payment processor\n            charge = stripe.Charge.create(\n                customer=customer.stripe_id,\n                amount=int(amount * 100),  # Convert to cents\n                currency='usd'\n            )\n\n            return PaymentResult(success=True, transaction_id=charge.id)\n        except stripe.error.CardError as e:\n            return PaymentResult(success=False, error=str(e))\n```\n\n## Dunning Management\n\n```python\nclass DunningManager:\n    \"\"\"Manage failed payment recovery.\"\"\"\n\n    def __init__(self):\n        self.retry_schedule = [\n            {'days': 3, 'email_template': 'payment_failed_first'},\n            {'days': 7, 'email_template': 'payment_failed_reminder'},\n            {'days': 14, 'email_template': 'payment_failed_final'}\n        ]\n\n    def start_dunning_process(self, subscription, invoice):\n        \"\"\"Start dunning process for failed payment.\"\"\"\n        dunning_attempt = DunningAttempt(\n            subscription_id=subscription.id,\n            invoice_id=invoice.id,\n            attempt_number=1,\n            next_retry=datetime.now() + timedelta(days=3)\n        )\n\n        # Send initial failure notification\n        self.send_dunning_email(subscription, 'payment_failed_first')\n\n        # Schedule retries\n        self.schedule_retries(dunning_attempt)\n\n    def retry_payment(self, dunning_attempt):\n        \"\"\"Retry failed payment.\"\"\"\n        subscription = self.get_subscription(dunning_attempt.subscription_id)\n        invoice = self.get_invoice(dunning_attempt.invoice_id)\n\n        # Attempt payment again\n        result = self.charge_customer(subscription.customer_id, invoice.total)\n\n        if result.success:\n            # Payment succeeded\n            invoice.mark_paid()\n            subscription.status = SubscriptionStatus.ACTIVE\n            self.send_dunning_email(subscription, 'payment_recovered')\n            dunning_attempt.mark_resolved()\n        else:\n            # Still failing\n            dunning_attempt.attempt_number += 1\n\n            if dunning_attempt.attempt_number < len(self.retry_schedule):\n                # Schedule next retry\n                next_retry_config = self.retry_schedule[dunning_attempt.attempt_number]\n                dunning_attempt.next_retry = datetime.now() + timedelta(days=next_retry_config['days'])\n                self.send_dunning_email(subscription, next_retry_config['email_template'])\n            else:\n                # Exhausted retries, cancel subscription\n                subscription.cancel(at_period_end=False)\n                self.send_dunning_email(subscription, 'subscription_canceled')\n\n    def send_dunning_email(self, subscription, template):\n        \"\"\"Send dunning notification to customer.\"\"\"\n        customer = self.get_customer(subscription.customer_id)\n\n        email_content = self.render_template(template, {\n            'customer_name': customer.name,\n            'amount_due': subscription.plan.amount,\n            'update_payment_url': f\"https://app.example.com/billing\"\n        })\n\n        send_email(\n            to=customer.email,\n            subject=email_content['subject'],\n            body=email_content['body']\n        )\n```\n\n## Proration\n\n```python\nclass ProrationCalculator:\n    \"\"\"Calculate prorated charges for plan changes.\"\"\"\n\n    @staticmethod\n    def calculate_proration(old_plan, new_plan, period_start, period_end, change_date):\n        \"\"\"Calculate proration for plan change.\"\"\"\n        # Days in current period\n        total_days = (period_end - period_start).days\n\n        # Days used on old plan\n        days_used = (change_date - period_start).days\n\n        # Days remaining on new plan\n        days_remaining = (period_end - change_date).days\n\n        # Calculate prorated amounts\n        unused_amount = (old_plan.amount / total_days) * days_remaining\n        new_plan_amount = (new_plan.amount / total_days) * days_remaining\n\n        # Net charge/credit\n        proration = new_plan_amount - unused_amount\n\n        return {\n            'old_plan_credit': -unused_amount,\n            'new_plan_charge': new_plan_amount,\n            'net_proration': proration,\n            'days_used': days_used,\n            'days_remaining': days_remaining\n        }\n\n    @staticmethod\n    def calculate_seat_proration(current_seats, new_seats, price_per_seat, period_start, period_end, change_date):\n        \"\"\"Calculate proration for seat changes.\"\"\"\n        total_days = (period_end - period_start).days\n        days_remaining = (period_end - change_date).days\n\n        # Additional seats charge\n        additional_seats = new_seats - current_seats\n        prorated_amount = (additional_seats * price_per_seat / total_days) * days_remaining\n\n        return {\n            'additional_seats': additional_seats,\n            'prorated_charge': max(0, prorated_amount),  # No refund for removing seats mid-cycle\n            'effective_date': change_date\n        }\n```\n\n## Tax Calculation\n\n```python\nclass TaxCalculator:\n    \"\"\"Calculate sales tax, VAT, GST.\"\"\"\n\n    def __init__(self):\n        # Tax rates by region\n        self.tax_rates = {\n            'US_CA': 0.0725,  # California sales tax\n            'US_NY': 0.04,    # New York sales tax\n            'GB': 0.20,       # UK VAT\n            'DE': 0.19,       # Germany VAT\n            'FR': 0.20,       # France VAT\n            'AU': 0.10,       # Australia GST\n        }\n\n    def calculate_tax(self, amount, customer):\n        \"\"\"Calculate applicable tax.\"\"\"\n        # Determine tax jurisdiction\n        jurisdiction = self.get_tax_jurisdiction(customer)\n\n        if not jurisdiction:\n            return 0\n\n        # Get tax rate\n        tax_rate = self.tax_rates.get(jurisdiction, 0)\n\n        # Calculate tax\n        tax = amount * tax_rate\n\n        return {\n            'tax_amount': tax,\n            'tax_rate': tax_rate,\n            'jurisdiction': jurisdiction,\n            'tax_type': self.get_tax_type(jurisdiction)\n        }\n\n    def get_tax_jurisdiction(self, customer):\n        \"\"\"Determine tax jurisdiction based on customer location.\"\"\"\n        if customer.country == 'US':\n            # US: Tax based on customer state\n            return f\"US_{customer.state}\"\n        elif customer.country in ['GB', 'DE', 'FR']:\n            # EU: VAT\n            return customer.country\n        elif customer.country == 'AU':\n            # Australia: GST\n            return 'AU'\n        else:\n            return None\n\n    def get_tax_type(self, jurisdiction):\n        \"\"\"Get type of tax for jurisdiction.\"\"\"\n        if jurisdiction.startswith('US_'):\n            return 'Sales Tax'\n        elif jurisdiction in ['GB', 'DE', 'FR']:\n            return 'VAT'\n        elif jurisdiction == 'AU':\n            return 'GST'\n        return 'Tax'\n\n    def validate_vat_number(self, vat_number, country):\n        \"\"\"Validate EU VAT number.\"\"\"\n        # Use VIES API for validation\n        # Returns True if valid, False otherwise\n        pass\n```\n\n## Invoice Generation\n\n```python\nclass Invoice:\n    def __init__(self, customer_id, subscription_id=None):\n        self.id = generate_invoice_number()\n        self.customer_id = customer_id\n        self.subscription_id = subscription_id\n        self.status = 'draft'\n        self.line_items = []\n        self.subtotal = 0\n        self.tax = 0\n        self.total = 0\n        self.created_at = datetime.now()\n\n    def add_line_item(self, description, amount, quantity=1):\n        \"\"\"Add line item to invoice.\"\"\"\n        line_item = {\n            'description': description,\n            'unit_amount': amount,\n            'quantity': quantity,\n            'total': amount * quantity\n        }\n        self.line_items.append(line_item)\n        self.subtotal += line_item['total']\n\n    def finalize(self):\n        \"\"\"Finalize invoice and calculate total.\"\"\"\n        self.total = self.subtotal + self.tax\n        self.status = 'open'\n        self.finalized_at = datetime.now()\n\n    def mark_paid(self):\n        \"\"\"Mark invoice as paid.\"\"\"\n        self.status = 'paid'\n        self.paid_at = datetime.now()\n\n    def to_pdf(self):\n        \"\"\"Generate PDF invoice.\"\"\"\n        from reportlab.pdfgen import canvas\n\n        # Generate PDF\n        # Include: company info, customer info, line items, tax, total\n        pass\n\n    def to_html(self):\n        \"\"\"Generate HTML invoice.\"\"\"\n        template = \"\"\"\n        <!DOCTYPE html>\n        <html>\n        <head><title>Invoice #{invoice_number}</title></head>\n        <body>\n            <h1>Invoice #{invoice_number}</h1>\n            <p>Date: {date}</p>\n            <h2>Bill To:</h2>\n            <p>{customer_name}<br>{customer_address}</p>\n            <table>\n                <tr><th>Description</th><th>Quantity</th><th>Amount</th></tr>\n                {line_items}\n            </table>\n            <p>Subtotal: ${subtotal}</p>\n            <p>Tax: ${tax}</p>\n            <h3>Total: ${total}</h3>\n        </body>\n        </html>\n        \"\"\"\n\n        return template.format(\n            invoice_number=self.id,\n            date=self.created_at.strftime('%Y-%m-%d'),\n            customer_name=self.customer.name,\n            customer_address=self.customer.address,\n            line_items=self.render_line_items(),\n            subtotal=self.subtotal,\n            tax=self.tax,\n            total=self.total\n        )\n```\n\n## Usage-Based Billing\n\n```python\nclass UsageBillingEngine:\n    \"\"\"Track and bill for usage.\"\"\"\n\n    def track_usage(self, customer_id, metric, quantity):\n        \"\"\"Track usage event.\"\"\"\n        UsageRecord.create(\n            customer_id=customer_id,\n            metric=metric,\n            quantity=quantity,\n            timestamp=datetime.now()\n        )\n\n    def calculate_usage_charges(self, subscription, period_start, period_end):\n        \"\"\"Calculate charges for usage in billing period.\"\"\"\n        usage_records = UsageRecord.get_for_period(\n            subscription.customer_id,\n            period_start,\n            period_end\n        )\n\n        total_usage = sum(record.quantity for record in usage_records)\n\n        # Tiered pricing\n        if subscription.plan.pricing_model == 'tiered':\n            charge = self.calculate_tiered_pricing(total_usage, subscription.plan.tiers)\n        # Per-unit pricing\n        elif subscription.plan.pricing_model == 'per_unit':\n            charge = total_usage * subscription.plan.unit_price\n        # Volume pricing\n        elif subscription.plan.pricing_model == 'volume':\n            charge = self.calculate_volume_pricing(total_usage, subscription.plan.tiers)\n\n        return charge\n\n    def calculate_tiered_pricing(self, total_usage, tiers):\n        \"\"\"Calculate cost using tiered pricing.\"\"\"\n        charge = 0\n        remaining = total_usage\n\n        for tier in sorted(tiers, key=lambda x: x['up_to']):\n            tier_usage = min(remaining, tier['up_to'] - tier['from'])\n            charge += tier_usage * tier['unit_price']\n            remaining -= tier_usage\n\n            if remaining <= 0:\n                break\n\n        return charge\n```\n\n## Resources\n\n- **references/billing-cycles.md**: Billing cycle management\n- **references/dunning-management.md**: Failed payment recovery\n- **references/proration.md**: Prorated charge calculations\n- **references/tax-calculation.md**: Tax/VAT/GST handling\n- **references/invoice-lifecycle.md**: Invoice state management\n- **assets/billing-state-machine.yaml**: Billing workflow\n- **assets/invoice-template.html**: Invoice templates\n- **assets/dunning-policy.yaml**: Dunning configuration\n\n## Best Practices\n\n1. **Automate Everything**: Minimize manual intervention\n2. **Clear Communication**: Notify customers of billing events\n3. **Flexible Retry Logic**: Balance recovery with customer experience\n4. **Accurate Proration**: Fair calculation for plan changes\n5. **Tax Compliance**: Calculate correct tax for jurisdiction\n6. **Audit Trail**: Log all billing events\n7. **Graceful Degradation**: Handle edge cases without breaking\n\n## Common Pitfalls\n\n- **Incorrect Proration**: Not accounting for partial periods\n- **Missing Tax**: Forgetting to add tax to invoices\n- **Aggressive Dunning**: Canceling too quickly\n- **No Notifications**: Not informing customers of failures\n- **Hardcoded Cycles**: Not supporting custom billing dates\n"
}