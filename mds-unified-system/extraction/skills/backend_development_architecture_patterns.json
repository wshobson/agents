{
  "id": "backend_development_architecture_patterns",
  "name": "architecture-patterns",
  "source": "backend-development",
  "originalPath": "plugins/backend-development/skills/architecture-patterns/SKILL.md",
  "activationCriteria": "Implement proven backend architecture patterns including Clean Architecture, Hexagonal Architecture, and Domain-Driven Design. Use when architecting complex backend systems or refactoring existing app",
  "tier1_metadata": "architecture-patterns: Implement proven backend architecture patterns including Clean Architecture, Hexagonal Architecture,",
  "tier2_instructions": "# Architecture Patterns\n\nMaster proven backend architecture patterns including Clean Architecture, Hexagonal Architecture, and Domain-Driven Design to build maintainable, testable, and scalable systems.\n\n## When to Use This Skill\n\n- Designing new backend systems from scratch\n- Refactoring monolithic applications for better maintainability\n- Establishing architecture standards for your team\n- Migrating from tightly coupled to loosely coupled architectures\n- Implementing domain-driven design principles\n- Creating testable and mockable codebases\n- Planning microservices decomposition\n\n## Core Concepts\n\n### 1. Clean Architecture (Uncle Bob)\n\n**Layers (dependency flows inward):**\n- **Entities**: Core business models\n- **Use Cases**: Application business rules\n- **Interface Adapters**: Controllers, presenters, gateways\n- **Frameworks & Drivers**: UI, database, external services\n\n**Key Principles:**\n- Dependencies point inward\n- Inner layers know nothing about outer layers\n- Business logic independent of frameworks\n- Testable without UI, database, or external services\n\n### 2. Hexagonal Architecture (Ports and Adapters)\n\n**Components:**\n- **Domain Core**: Business logic\n- **Ports**: Interfaces defining interactions\n- **Adapters**: Implementations of ports (database, REST, message queue)\n\n**Benefits:**\n- Swap implementations easily (mock for testing)\n- Technology-agnostic core\n- Clear separation of concerns\n\n### 3. Domain-Driven Design (DDD)\n\n**Strategic Patterns:**\n- **Bounded Contexts**: Separate models for different domains\n- **Context Mapping**: How contexts relate\n- **Ubiquitous Language**: Shared terminology\n\n**Tactical Patterns:**\n- **Entities**: Objects with identity\n- **Value Objects**: Immutable objects defined by attributes\n- **Aggregates**: Consistency boundaries\n- **Repositories**: Data access abstraction\n- **Domain Events**: Things that happened\n\n## Clean Architecture Pattern\n\n### Directory Structure\n```\napp/\n\u251c\u2500\u2500 domain/           # Entities & business rules\n\u2502 ",
  "tier3_resources": "  \u251c\u2500\u2500 entities/\n\u2502   \u2502   \u251c\u2500\u2500 user.py\n\u2502   \u2502   \u2514\u2500\u2500 order.py\n\u2502   \u251c\u2500\u2500 value_objects/\n\u2502   \u2502   \u251c\u2500\u2500 email.py\n\u2502   \u2502   \u2514\u2500\u2500 money.py\n\u2502   \u2514\u2500\u2500 interfaces/   # Abstract interfaces\n\u2502       \u251c\u2500\u2500 user_repository.py\n\u2502       \u2514\u2500\u2500 payment_gateway.py\n\u251c\u2500\u2500 use_cases/        # Application business rules\n\u2502   \u251c\u2500\u2500 create_user.py\n\u2502   \u251c\u2500\u2500 process_order.py\n\u2502   \u2514\u2500\u2500 send_notification.py\n\u251c\u2500\u2500 adapters/         # Interface implementations\n\u2502   \u251c\u2500\u2500 repositories/\n\u2502   \u2502   \u251c\u2500\u2500 postgres_user_repository.py\n\u2502   \u2502   \u2514\u2500\u2500 redis_cache_repository.py\n\u2502   \u251c\u2500\u2500 controllers/\n\u2502   \u2502   \u2514\u2500\u2500 user_controller.py\n\u2502   \u2514\u2500\u2500 gateways/\n\u2502       \u251c\u2500\u2500 stripe_payment_gateway.py\n\u2502       \u2514\u2500\u2500 sendgrid_email_gateway.py\n\u2514\u2500\u2500 infrastructure/   # Framework & external concerns\n    \u251c\u2500\u2500 database.py\n    \u251c\u2500\u2500 config.py\n    \u2514\u2500\u2500 logging.py\n```\n\n### Implementation Example\n\n```python\n# domain/entities/user.py\nfrom dataclasses import dataclass\nfrom datetime import datetime\nfrom typing import Optional\n\n@dataclass\nclass User:\n    \"\"\"Core user entity - no framework dependencies.\"\"\"\n    id: str\n    email: str\n    name: str\n    created_at: datetime\n    is_active: bool = True\n\n    def deactivate(self):\n        \"\"\"Business rule: deactivating user.\"\"\"\n        self.is_active = False\n\n    def can_place_order(self) -> bool:\n        \"\"\"Business rule: active users can order.\"\"\"\n        return self.is_active\n\n# domain/interfaces/user_repository.py\nfrom abc import ABC, abstractmethod\nfrom typing import Optional, List\nfrom domain.entities.user import User\n\nclass IUserRepository(ABC):\n    \"\"\"Port: defines contract, no implementation.\"\"\"\n\n    @abstractmethod\n    async def find_by_id(self, user_id: str) -> Optional[User]:\n        pass\n\n    @abstractmethod\n    async def find_by_email(self, email: str) -> Optional[User]:\n        pass\n\n    @abstractmethod\n    async def save(self, user: User) -> User:\n        pass\n\n    @abstractmethod\n    async def delete(self, user_id: str) -> bool:\n        pass\n\n# use_cases/create_user.py\nfrom domain.entities.user import User\nfrom domain.interfaces.user_repository import IUserRepository\nfrom dataclasses import dataclass\nfrom datetime import datetime\nimport uuid\n\n@dataclass\nclass CreateUserRequest:\n    email: str\n    name: str\n\n@dataclass\nclass CreateUserResponse:\n    user: User\n    success: bool\n    error: Optional[str] = None\n\nclass CreateUserUseCase:\n    \"\"\"Use case: orchestrates business logic.\"\"\"\n\n    def __init__(self, user_repository: IUserRepository):\n        self.user_repository = user_repository\n\n    async def execute(self, request: CreateUserRequest) -> CreateUserResponse:\n        # Business validation\n        existing = await self.user_repository.find_by_email(request.email)\n        if existing:\n            return CreateUserResponse(\n                user=None,\n                success=False,\n                error=\"Email already exists\"\n            )\n\n        # Create entity\n        user = User(\n            id=str(uuid.uuid4()),\n            email=request.email,\n            name=request.name,\n            created_at=",
  "tokenEstimate": {
    "tier1": 14.3,
    "tier2": 332.8,
    "tier3": 1524.9
  },
  "fullDefinition": "---\nname: architecture-patterns\ndescription: Implement proven backend architecture patterns including Clean Architecture, Hexagonal Architecture, and Domain-Driven Design. Use when architecting complex backend systems or refactoring existing applications for better maintainability.\n---\n\n# Architecture Patterns\n\nMaster proven backend architecture patterns including Clean Architecture, Hexagonal Architecture, and Domain-Driven Design to build maintainable, testable, and scalable systems.\n\n## When to Use This Skill\n\n- Designing new backend systems from scratch\n- Refactoring monolithic applications for better maintainability\n- Establishing architecture standards for your team\n- Migrating from tightly coupled to loosely coupled architectures\n- Implementing domain-driven design principles\n- Creating testable and mockable codebases\n- Planning microservices decomposition\n\n## Core Concepts\n\n### 1. Clean Architecture (Uncle Bob)\n\n**Layers (dependency flows inward):**\n- **Entities**: Core business models\n- **Use Cases**: Application business rules\n- **Interface Adapters**: Controllers, presenters, gateways\n- **Frameworks & Drivers**: UI, database, external services\n\n**Key Principles:**\n- Dependencies point inward\n- Inner layers know nothing about outer layers\n- Business logic independent of frameworks\n- Testable without UI, database, or external services\n\n### 2. Hexagonal Architecture (Ports and Adapters)\n\n**Components:**\n- **Domain Core**: Business logic\n- **Ports**: Interfaces defining interactions\n- **Adapters**: Implementations of ports (database, REST, message queue)\n\n**Benefits:**\n- Swap implementations easily (mock for testing)\n- Technology-agnostic core\n- Clear separation of concerns\n\n### 3. Domain-Driven Design (DDD)\n\n**Strategic Patterns:**\n- **Bounded Contexts**: Separate models for different domains\n- **Context Mapping**: How contexts relate\n- **Ubiquitous Language**: Shared terminology\n\n**Tactical Patterns:**\n- **Entities**: Objects with identity\n- **Value Objects**: Immutable objects defined by attributes\n- **Aggregates**: Consistency boundaries\n- **Repositories**: Data access abstraction\n- **Domain Events**: Things that happened\n\n## Clean Architecture Pattern\n\n### Directory Structure\n```\napp/\n\u251c\u2500\u2500 domain/           # Entities & business rules\n\u2502   \u251c\u2500\u2500 entities/\n\u2502   \u2502   \u251c\u2500\u2500 user.py\n\u2502   \u2502   \u2514\u2500\u2500 order.py\n\u2502   \u251c\u2500\u2500 value_objects/\n\u2502   \u2502   \u251c\u2500\u2500 email.py\n\u2502   \u2502   \u2514\u2500\u2500 money.py\n\u2502   \u2514\u2500\u2500 interfaces/   # Abstract interfaces\n\u2502       \u251c\u2500\u2500 user_repository.py\n\u2502       \u2514\u2500\u2500 payment_gateway.py\n\u251c\u2500\u2500 use_cases/        # Application business rules\n\u2502   \u251c\u2500\u2500 create_user.py\n\u2502   \u251c\u2500\u2500 process_order.py\n\u2502   \u2514\u2500\u2500 send_notification.py\n\u251c\u2500\u2500 adapters/         # Interface implementations\n\u2502   \u251c\u2500\u2500 repositories/\n\u2502   \u2502   \u251c\u2500\u2500 postgres_user_repository.py\n\u2502   \u2502   \u2514\u2500\u2500 redis_cache_repository.py\n\u2502   \u251c\u2500\u2500 controllers/\n\u2502   \u2502   \u2514\u2500\u2500 user_controller.py\n\u2502   \u2514\u2500\u2500 gateways/\n\u2502       \u251c\u2500\u2500 stripe_payment_gateway.py\n\u2502       \u2514\u2500\u2500 sendgrid_email_gateway.py\n\u2514\u2500\u2500 infrastructure/   # Framework & external concerns\n    \u251c\u2500\u2500 database.py\n    \u251c\u2500\u2500 config.py\n    \u2514\u2500\u2500 logging.py\n```\n\n### Implementation Example\n\n```python\n# domain/entities/user.py\nfrom dataclasses import dataclass\nfrom datetime import datetime\nfrom typing import Optional\n\n@dataclass\nclass User:\n    \"\"\"Core user entity - no framework dependencies.\"\"\"\n    id: str\n    email: str\n    name: str\n    created_at: datetime\n    is_active: bool = True\n\n    def deactivate(self):\n        \"\"\"Business rule: deactivating user.\"\"\"\n        self.is_active = False\n\n    def can_place_order(self) -> bool:\n        \"\"\"Business rule: active users can order.\"\"\"\n        return self.is_active\n\n# domain/interfaces/user_repository.py\nfrom abc import ABC, abstractmethod\nfrom typing import Optional, List\nfrom domain.entities.user import User\n\nclass IUserRepository(ABC):\n    \"\"\"Port: defines contract, no implementation.\"\"\"\n\n    @abstractmethod\n    async def find_by_id(self, user_id: str) -> Optional[User]:\n        pass\n\n    @abstractmethod\n    async def find_by_email(self, email: str) -> Optional[User]:\n        pass\n\n    @abstractmethod\n    async def save(self, user: User) -> User:\n        pass\n\n    @abstractmethod\n    async def delete(self, user_id: str) -> bool:\n        pass\n\n# use_cases/create_user.py\nfrom domain.entities.user import User\nfrom domain.interfaces.user_repository import IUserRepository\nfrom dataclasses import dataclass\nfrom datetime import datetime\nimport uuid\n\n@dataclass\nclass CreateUserRequest:\n    email: str\n    name: str\n\n@dataclass\nclass CreateUserResponse:\n    user: User\n    success: bool\n    error: Optional[str] = None\n\nclass CreateUserUseCase:\n    \"\"\"Use case: orchestrates business logic.\"\"\"\n\n    def __init__(self, user_repository: IUserRepository):\n        self.user_repository = user_repository\n\n    async def execute(self, request: CreateUserRequest) -> CreateUserResponse:\n        # Business validation\n        existing = await self.user_repository.find_by_email(request.email)\n        if existing:\n            return CreateUserResponse(\n                user=None,\n                success=False,\n                error=\"Email already exists\"\n            )\n\n        # Create entity\n        user = User(\n            id=str(uuid.uuid4()),\n            email=request.email,\n            name=request.name,\n            created_at=datetime.now(),\n            is_active=True\n        )\n\n        # Persist\n        saved_user = await self.user_repository.save(user)\n\n        return CreateUserResponse(\n            user=saved_user,\n            success=True\n        )\n\n# adapters/repositories/postgres_user_repository.py\nfrom domain.interfaces.user_repository import IUserRepository\nfrom domain.entities.user import User\nfrom typing import Optional\nimport asyncpg\n\nclass PostgresUserRepository(IUserRepository):\n    \"\"\"Adapter: PostgreSQL implementation.\"\"\"\n\n    def __init__(self, pool: asyncpg.Pool):\n        self.pool = pool\n\n    async def find_by_id(self, user_id: str) -> Optional[User]:\n        async with self.pool.acquire() as conn:\n            row = await conn.fetchrow(\n                \"SELECT * FROM users WHERE id = $1\", user_id\n            )\n            return self._to_entity(row) if row else None\n\n    async def find_by_email(self, email: str) -> Optional[User]:\n        async with self.pool.acquire() as conn:\n            row = await conn.fetchrow(\n                \"SELECT * FROM users WHERE email = $1\", email\n            )\n            return self._to_entity(row) if row else None\n\n    async def save(self, user: User) -> User:\n        async with self.pool.acquire() as conn:\n            await conn.execute(\n                \"\"\"\n                INSERT INTO users (id, email, name, created_at, is_active)\n                VALUES ($1, $2, $3, $4, $5)\n                ON CONFLICT (id) DO UPDATE\n                SET email = $2, name = $3, is_active = $5\n                \"\"\",\n                user.id, user.email, user.name, user.created_at, user.is_active\n            )\n            return user\n\n    async def delete(self, user_id: str) -> bool:\n        async with self.pool.acquire() as conn:\n            result = await conn.execute(\n                \"DELETE FROM users WHERE id = $1\", user_id\n            )\n            return result == \"DELETE 1\"\n\n    def _to_entity(self, row) -> User:\n        \"\"\"Map database row to entity.\"\"\"\n        return User(\n            id=row[\"id\"],\n            email=row[\"email\"],\n            name=row[\"name\"],\n            created_at=row[\"created_at\"],\n            is_active=row[\"is_active\"]\n        )\n\n# adapters/controllers/user_controller.py\nfrom fastapi import APIRouter, Depends, HTTPException\nfrom use_cases.create_user import CreateUserUseCase, CreateUserRequest\nfrom pydantic import BaseModel\n\nrouter = APIRouter()\n\nclass CreateUserDTO(BaseModel):\n    email: str\n    name: str\n\n@router.post(\"/users\")\nasync def create_user(\n    dto: CreateUserDTO,\n    use_case: CreateUserUseCase = Depends(get_create_user_use_case)\n):\n    \"\"\"Controller: handles HTTP concerns only.\"\"\"\n    request = CreateUserRequest(email=dto.email, name=dto.name)\n    response = await use_case.execute(request)\n\n    if not response.success:\n        raise HTTPException(status_code=400, detail=response.error)\n\n    return {\"user\": response.user}\n```\n\n## Hexagonal Architecture Pattern\n\n```python\n# Core domain (hexagon center)\nclass OrderService:\n    \"\"\"Domain service - no infrastructure dependencies.\"\"\"\n\n    def __init__(\n        self,\n        order_repository: OrderRepositoryPort,\n        payment_gateway: PaymentGatewayPort,\n        notification_service: NotificationPort\n    ):\n        self.orders = order_repository\n        self.payments = payment_gateway\n        self.notifications = notification_service\n\n    async def place_order(self, order: Order) -> OrderResult:\n        # Business logic\n        if not order.is_valid():\n            return OrderResult(success=False, error=\"Invalid order\")\n\n        # Use ports (interfaces)\n        payment = await self.payments.charge(\n            amount=order.total,\n            customer=order.customer_id\n        )\n\n        if not payment.success:\n            return OrderResult(success=False, error=\"Payment failed\")\n\n        order.mark_as_paid()\n        saved_order = await self.orders.save(order)\n\n        await self.notifications.send(\n            to=order.customer_email,\n            subject=\"Order confirmed\",\n            body=f\"Order {order.id} confirmed\"\n        )\n\n        return OrderResult(success=True, order=saved_order)\n\n# Ports (interfaces)\nclass OrderRepositoryPort(ABC):\n    @abstractmethod\n    async def save(self, order: Order) -> Order:\n        pass\n\nclass PaymentGatewayPort(ABC):\n    @abstractmethod\n    async def charge(self, amount: Money, customer: str) -> PaymentResult:\n        pass\n\nclass NotificationPort(ABC):\n    @abstractmethod\n    async def send(self, to: str, subject: str, body: str):\n        pass\n\n# Adapters (implementations)\nclass StripePaymentAdapter(PaymentGatewayPort):\n    \"\"\"Primary adapter: connects to Stripe API.\"\"\"\n\n    def __init__(self, api_key: str):\n        self.stripe = stripe\n        self.stripe.api_key = api_key\n\n    async def charge(self, amount: Money, customer: str) -> PaymentResult:\n        try:\n            charge = self.stripe.Charge.create(\n                amount=amount.cents,\n                currency=amount.currency,\n                customer=customer\n            )\n            return PaymentResult(success=True, transaction_id=charge.id)\n        except stripe.error.CardError as e:\n            return PaymentResult(success=False, error=str(e))\n\nclass MockPaymentAdapter(PaymentGatewayPort):\n    \"\"\"Test adapter: no external dependencies.\"\"\"\n\n    async def charge(self, amount: Money, customer: str) -> PaymentResult:\n        return PaymentResult(success=True, transaction_id=\"mock-123\")\n```\n\n## Domain-Driven Design Pattern\n\n```python\n# Value Objects (immutable)\nfrom dataclasses import dataclass\nfrom typing import Optional\n\n@dataclass(frozen=True)\nclass Email:\n    \"\"\"Value object: validated email.\"\"\"\n    value: str\n\n    def __post_init__(self):\n        if \"@\" not in self.value:\n            raise ValueError(\"Invalid email\")\n\n@dataclass(frozen=True)\nclass Money:\n    \"\"\"Value object: amount with currency.\"\"\"\n    amount: int  # cents\n    currency: str\n\n    def add(self, other: \"Money\") -> \"Money\":\n        if self.currency != other.currency:\n            raise ValueError(\"Currency mismatch\")\n        return Money(self.amount + other.amount, self.currency)\n\n# Entities (with identity)\nclass Order:\n    \"\"\"Entity: has identity, mutable state.\"\"\"\n\n    def __init__(self, id: str, customer: Customer):\n        self.id = id\n        self.customer = customer\n        self.items: List[OrderItem] = []\n        self.status = OrderStatus.PENDING\n        self._events: List[DomainEvent] = []\n\n    def add_item(self, product: Product, quantity: int):\n        \"\"\"Business logic in entity.\"\"\"\n        item = OrderItem(product, quantity)\n        self.items.append(item)\n        self._events.append(ItemAddedEvent(self.id, item))\n\n    def total(self) -> Money:\n        \"\"\"Calculated property.\"\"\"\n        return sum(item.subtotal() for item in self.items)\n\n    def submit(self):\n        \"\"\"State transition with business rules.\"\"\"\n        if not self.items:\n            raise ValueError(\"Cannot submit empty order\")\n        if self.status != OrderStatus.PENDING:\n            raise ValueError(\"Order already submitted\")\n\n        self.status = OrderStatus.SUBMITTED\n        self._events.append(OrderSubmittedEvent(self.id))\n\n# Aggregates (consistency boundary)\nclass Customer:\n    \"\"\"Aggregate root: controls access to entities.\"\"\"\n\n    def __init__(self, id: str, email: Email):\n        self.id = id\n        self.email = email\n        self._addresses: List[Address] = []\n        self._orders: List[str] = []  # Order IDs, not full objects\n\n    def add_address(self, address: Address):\n        \"\"\"Aggregate enforces invariants.\"\"\"\n        if len(self._addresses) >= 5:\n            raise ValueError(\"Maximum 5 addresses allowed\")\n        self._addresses.append(address)\n\n    @property\n    def primary_address(self) -> Optional[Address]:\n        return next((a for a in self._addresses if a.is_primary), None)\n\n# Domain Events\n@dataclass\nclass OrderSubmittedEvent:\n    order_id: str\n    occurred_at: datetime = field(default_factory=datetime.now)\n\n# Repository (aggregate persistence)\nclass OrderRepository:\n    \"\"\"Repository: persist/retrieve aggregates.\"\"\"\n\n    async def find_by_id(self, order_id: str) -> Optional[Order]:\n        \"\"\"Reconstitute aggregate from storage.\"\"\"\n        pass\n\n    async def save(self, order: Order):\n        \"\"\"Persist aggregate and publish events.\"\"\"\n        await self._persist(order)\n        await self._publish_events(order._events)\n        order._events.clear()\n```\n\n## Resources\n\n- **references/clean-architecture-guide.md**: Detailed layer breakdown\n- **references/hexagonal-architecture-guide.md**: Ports and adapters patterns\n- **references/ddd-tactical-patterns.md**: Entities, value objects, aggregates\n- **assets/clean-architecture-template/**: Complete project structure\n- **assets/ddd-examples/**: Domain modeling examples\n\n## Best Practices\n\n1. **Dependency Rule**: Dependencies always point inward\n2. **Interface Segregation**: Small, focused interfaces\n3. **Business Logic in Domain**: Keep frameworks out of core\n4. **Test Independence**: Core testable without infrastructure\n5. **Bounded Contexts**: Clear domain boundaries\n6. **Ubiquitous Language**: Consistent terminology\n7. **Thin Controllers**: Delegate to use cases\n8. **Rich Domain Models**: Behavior with data\n\n## Common Pitfalls\n\n- **Anemic Domain**: Entities with only data, no behavior\n- **Framework Coupling**: Business logic depends on frameworks\n- **Fat Controllers**: Business logic in controllers\n- **Repository Leakage**: Exposing ORM objects\n- **Missing Abstractions**: Concrete dependencies in core\n- **Over-Engineering**: Clean architecture for simple CRUD\n"
}