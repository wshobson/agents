{
  "id": "quantitative_trading_backtesting_frameworks",
  "name": "backtesting-frameworks",
  "source": "quantitative-trading",
  "originalPath": "plugins/quantitative-trading/skills/backtesting-frameworks/SKILL.md",
  "activationCriteria": "Build robust backtesting systems for trading strategies with proper handling of look-ahead bias, survivorship bias, and transaction costs. Use when developing trading algorithms, validating strategies",
  "tier1_metadata": "backtesting-frameworks: Build robust backtesting systems for trading strategies with proper handling of look-ahead bias, sur",
  "tier2_instructions": "# Backtesting Frameworks\n\nBuild robust, production-grade backtesting systems that avoid common pitfalls and produce reliable strategy performance estimates.\n\n## When to Use This Skill\n\n- Developing trading strategy backtests\n- Building backtesting infrastructure\n- Validating strategy performance\n- Avoiding common backtesting biases\n- Implementing walk-forward analysis\n- Comparing strategy alternatives\n\n## Core Concepts\n\n### 1. Backtesting Biases\n\n| Bias | Description | Mitigation |\n|------|-------------|------------|\n| **Look-ahead** | Using future information | Point-in-time data |\n| **Survivorship** | Only testing on survivors | Use delisted securities |\n| **Overfitting** | Curve-fitting to history | Out-of-sample testing |\n| **Selection** | Cherry-picking strategies | Pre-registration |\n| **Transaction** | Ignoring trading costs | Realistic cost models |\n\n### 2. Proper Backtest Structure\n\n```\nHistorical Data\n      \u2502\n      \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502              Training Set               \u2502\n\u2502  (Strategy Development & Optimization)  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n      \u2502\n      \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502             Validation Set              \u2502\n\u2502  (Parameter Selection, No Peeking)      \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n      \u2502\n      \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502               Test Set                  \u2502\n\u2502  (Final Performance Evaluation)         \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n```\n\n### 3. Walk-Forward Analysis\n\n```\nWindow 1: [Train\u2500\u2500\u2500\u2500\u2500\u2500][Test]\nWindow 2:     [Train\u2500\u2500\u2500\u2500\u2500\u2500][Test]\nWindow 3:         [Train\u2500\u2500\u2500\u2500\u2500\u2500][Test]\nWindow 4:             [Train\u2500\u2500\u2500\u2500\u2500\u2500][Test]\n                                     \u2500\u2500\u2500\u2500\u2500\u25b6 Time\n```\n\n## Implementation Patterns\n\n### Pattern 1: Event-Driven Backtester\n\n```python\nfrom abc import ABC, abstractmethod\nfrom dataclasses import dataclass, field\nfrom datetime import datetime\nfrom decimal import Decimal\nfrom enum import Enum\nfrom typing import Dict, Li",
  "tier3_resources": "st, Optional\nimport pandas as pd\nimport numpy as np\n\nclass OrderSide(Enum):\n    BUY = \"buy\"\n    SELL = \"sell\"\n\nclass OrderType(Enum):\n    MARKET = \"market\"\n    LIMIT = \"limit\"\n    STOP = \"stop\"\n\n@dataclass\nclass Order:\n    symbol: str\n    side: OrderSide\n    quantity: Decimal\n    order_type: OrderType\n    limit_price: Optional[Decimal] = None\n    stop_price: Optional[Decimal] = None\n    timestamp: Optional[datetime] = None\n\n@dataclass\nclass Fill:\n    order: Order\n    fill_price: Decimal\n    fill_quantity: Decimal\n    commission: Decimal\n    slippage: Decimal\n    timestamp: datetime\n\n@dataclass\nclass Position:\n    symbol: str\n    quantity: Decimal = Decimal(\"0\")\n    avg_cost: Decimal = Decimal(\"0\")\n    realized_pnl: Decimal = Decimal(\"0\")\n\n    def update(self, fill: Fill) -> None:\n        if fill.order.side == OrderSide.BUY:\n            new_quantity = self.quantity + fill.fill_quantity\n            if new_quantity != 0:\n                self.avg_cost = (\n                    (self.quantity * self.avg_cost + fill.fill_quantity * fill.fill_price)\n                    / new_quantity\n                )\n            self.quantity = new_quantity\n        else:\n            self.realized_pnl += fill.fill_quantity * (fill.fill_price - self.avg_cost)\n            self.quantity -= fill.fill_quantity\n\n@dataclass\nclass Portfolio:\n    cash: Decimal\n    positions: Dict[str, Position] = field(default_factory=dict)\n\n    def get_position(self, symbol: str) -> Position:\n        if symbol not in self.positions:\n            self.positions[symbol] = Position(symbol=symbol)\n        return self.positions[symbol]\n\n    def process_fill(self, fill: Fill) -> None:\n        position = self.get_position(fill.order.symbol)\n        position.update(fill)\n\n        if fill.order.side == OrderSide.BUY:\n            self.cash -= fill.fill_price * fill.fill_quantity + fill.commission\n        else:\n            self.cash += fill.fill_price * fill.fill_quantity - fill.commission\n\n    def get_equity(self, prices: Dict[str, Decimal]) -> Decimal:\n        equity = self.cash\n        for symbol, position in self.positions.items():\n            if position.quantity != 0 and symbol in prices:\n                equity += position.quantity * prices[symbol]\n        return equity\n\nclass Strategy(ABC):\n    @abstractmethod\n    def on_bar(self, timestamp: datetime, data: pd.DataFrame) -> List[Order]:\n        pass\n\n    @abstractmethod\n    def on_fill(self, fill: Fill) -> None:\n        pass\n\nclass ExecutionModel(ABC):\n    @abstractmethod\n    def execute(self, order: Order, bar: pd.Series) -> Optional[Fill]:\n        pass\n\nclass SimpleExecutionModel(ExecutionModel):\n    def __init__(self, slippage_bps: float = 10, commission_per_share: float = 0.01):\n        self.slippage_bps = slippage_bps\n        self.commission_per_share = commission_per_share\n\n    def execute(self, order: Order, bar: pd.Series) -> Optional[Fill]:\n        if order.order_type == OrderType.MARKET:\n            base_price = Decimal(str(bar[\"open\"]))\n\n  ",
  "tokenEstimate": {
    "tier1": 19.5,
    "tier2": 288.6,
    "tier3": 2243.8
  },
  "fullDefinition": "---\nname: backtesting-frameworks\ndescription: Build robust backtesting systems for trading strategies with proper handling of look-ahead bias, survivorship bias, and transaction costs. Use when developing trading algorithms, validating strategies, or building backtesting infrastructure.\n---\n\n# Backtesting Frameworks\n\nBuild robust, production-grade backtesting systems that avoid common pitfalls and produce reliable strategy performance estimates.\n\n## When to Use This Skill\n\n- Developing trading strategy backtests\n- Building backtesting infrastructure\n- Validating strategy performance\n- Avoiding common backtesting biases\n- Implementing walk-forward analysis\n- Comparing strategy alternatives\n\n## Core Concepts\n\n### 1. Backtesting Biases\n\n| Bias | Description | Mitigation |\n|------|-------------|------------|\n| **Look-ahead** | Using future information | Point-in-time data |\n| **Survivorship** | Only testing on survivors | Use delisted securities |\n| **Overfitting** | Curve-fitting to history | Out-of-sample testing |\n| **Selection** | Cherry-picking strategies | Pre-registration |\n| **Transaction** | Ignoring trading costs | Realistic cost models |\n\n### 2. Proper Backtest Structure\n\n```\nHistorical Data\n      \u2502\n      \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502              Training Set               \u2502\n\u2502  (Strategy Development & Optimization)  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n      \u2502\n      \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502             Validation Set              \u2502\n\u2502  (Parameter Selection, No Peeking)      \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n      \u2502\n      \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502               Test Set                  \u2502\n\u2502  (Final Performance Evaluation)         \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n```\n\n### 3. Walk-Forward Analysis\n\n```\nWindow 1: [Train\u2500\u2500\u2500\u2500\u2500\u2500][Test]\nWindow 2:     [Train\u2500\u2500\u2500\u2500\u2500\u2500][Test]\nWindow 3:         [Train\u2500\u2500\u2500\u2500\u2500\u2500][Test]\nWindow 4:             [Train\u2500\u2500\u2500\u2500\u2500\u2500][Test]\n                                     \u2500\u2500\u2500\u2500\u2500\u25b6 Time\n```\n\n## Implementation Patterns\n\n### Pattern 1: Event-Driven Backtester\n\n```python\nfrom abc import ABC, abstractmethod\nfrom dataclasses import dataclass, field\nfrom datetime import datetime\nfrom decimal import Decimal\nfrom enum import Enum\nfrom typing import Dict, List, Optional\nimport pandas as pd\nimport numpy as np\n\nclass OrderSide(Enum):\n    BUY = \"buy\"\n    SELL = \"sell\"\n\nclass OrderType(Enum):\n    MARKET = \"market\"\n    LIMIT = \"limit\"\n    STOP = \"stop\"\n\n@dataclass\nclass Order:\n    symbol: str\n    side: OrderSide\n    quantity: Decimal\n    order_type: OrderType\n    limit_price: Optional[Decimal] = None\n    stop_price: Optional[Decimal] = None\n    timestamp: Optional[datetime] = None\n\n@dataclass\nclass Fill:\n    order: Order\n    fill_price: Decimal\n    fill_quantity: Decimal\n    commission: Decimal\n    slippage: Decimal\n    timestamp: datetime\n\n@dataclass\nclass Position:\n    symbol: str\n    quantity: Decimal = Decimal(\"0\")\n    avg_cost: Decimal = Decimal(\"0\")\n    realized_pnl: Decimal = Decimal(\"0\")\n\n    def update(self, fill: Fill) -> None:\n        if fill.order.side == OrderSide.BUY:\n            new_quantity = self.quantity + fill.fill_quantity\n            if new_quantity != 0:\n                self.avg_cost = (\n                    (self.quantity * self.avg_cost + fill.fill_quantity * fill.fill_price)\n                    / new_quantity\n                )\n            self.quantity = new_quantity\n        else:\n            self.realized_pnl += fill.fill_quantity * (fill.fill_price - self.avg_cost)\n            self.quantity -= fill.fill_quantity\n\n@dataclass\nclass Portfolio:\n    cash: Decimal\n    positions: Dict[str, Position] = field(default_factory=dict)\n\n    def get_position(self, symbol: str) -> Position:\n        if symbol not in self.positions:\n            self.positions[symbol] = Position(symbol=symbol)\n        return self.positions[symbol]\n\n    def process_fill(self, fill: Fill) -> None:\n        position = self.get_position(fill.order.symbol)\n        position.update(fill)\n\n        if fill.order.side == OrderSide.BUY:\n            self.cash -= fill.fill_price * fill.fill_quantity + fill.commission\n        else:\n            self.cash += fill.fill_price * fill.fill_quantity - fill.commission\n\n    def get_equity(self, prices: Dict[str, Decimal]) -> Decimal:\n        equity = self.cash\n        for symbol, position in self.positions.items():\n            if position.quantity != 0 and symbol in prices:\n                equity += position.quantity * prices[symbol]\n        return equity\n\nclass Strategy(ABC):\n    @abstractmethod\n    def on_bar(self, timestamp: datetime, data: pd.DataFrame) -> List[Order]:\n        pass\n\n    @abstractmethod\n    def on_fill(self, fill: Fill) -> None:\n        pass\n\nclass ExecutionModel(ABC):\n    @abstractmethod\n    def execute(self, order: Order, bar: pd.Series) -> Optional[Fill]:\n        pass\n\nclass SimpleExecutionModel(ExecutionModel):\n    def __init__(self, slippage_bps: float = 10, commission_per_share: float = 0.01):\n        self.slippage_bps = slippage_bps\n        self.commission_per_share = commission_per_share\n\n    def execute(self, order: Order, bar: pd.Series) -> Optional[Fill]:\n        if order.order_type == OrderType.MARKET:\n            base_price = Decimal(str(bar[\"open\"]))\n\n            # Apply slippage\n            slippage_mult = 1 + (self.slippage_bps / 10000)\n            if order.side == OrderSide.BUY:\n                fill_price = base_price * Decimal(str(slippage_mult))\n            else:\n                fill_price = base_price / Decimal(str(slippage_mult))\n\n            commission = order.quantity * Decimal(str(self.commission_per_share))\n            slippage = abs(fill_price - base_price) * order.quantity\n\n            return Fill(\n                order=order,\n                fill_price=fill_price,\n                fill_quantity=order.quantity,\n                commission=commission,\n                slippage=slippage,\n                timestamp=bar.name\n            )\n        return None\n\nclass Backtester:\n    def __init__(\n        self,\n        strategy: Strategy,\n        execution_model: ExecutionModel,\n        initial_capital: Decimal = Decimal(\"100000\")\n    ):\n        self.strategy = strategy\n        self.execution_model = execution_model\n        self.portfolio = Portfolio(cash=initial_capital)\n        self.equity_curve: List[tuple] = []\n        self.trades: List[Fill] = []\n\n    def run(self, data: pd.DataFrame) -> pd.DataFrame:\n        \"\"\"Run backtest on OHLCV data with DatetimeIndex.\"\"\"\n        pending_orders: List[Order] = []\n\n        for timestamp, bar in data.iterrows():\n            # Execute pending orders at today's prices\n            for order in pending_orders:\n                fill = self.execution_model.execute(order, bar)\n                if fill:\n                    self.portfolio.process_fill(fill)\n                    self.strategy.on_fill(fill)\n                    self.trades.append(fill)\n\n            pending_orders.clear()\n\n            # Get current prices for equity calculation\n            prices = {data.index.name or \"default\": Decimal(str(bar[\"close\"]))}\n            equity = self.portfolio.get_equity(prices)\n            self.equity_curve.append((timestamp, float(equity)))\n\n            # Generate new orders for next bar\n            new_orders = self.strategy.on_bar(timestamp, data.loc[:timestamp])\n            pending_orders.extend(new_orders)\n\n        return self._create_results()\n\n    def _create_results(self) -> pd.DataFrame:\n        equity_df = pd.DataFrame(self.equity_curve, columns=[\"timestamp\", \"equity\"])\n        equity_df.set_index(\"timestamp\", inplace=True)\n        equity_df[\"returns\"] = equity_df[\"equity\"].pct_change()\n        return equity_df\n```\n\n### Pattern 2: Vectorized Backtester (Fast)\n\n```python\nimport pandas as pd\nimport numpy as np\nfrom typing import Callable, Dict, Any\n\nclass VectorizedBacktester:\n    \"\"\"Fast vectorized backtester for simple strategies.\"\"\"\n\n    def __init__(\n        self,\n        initial_capital: float = 100000,\n        commission: float = 0.001,  # 0.1%\n        slippage: float = 0.0005   # 0.05%\n    ):\n        self.initial_capital = initial_capital\n        self.commission = commission\n        self.slippage = slippage\n\n    def run(\n        self,\n        prices: pd.DataFrame,\n        signal_func: Callable[[pd.DataFrame], pd.Series]\n    ) -> Dict[str, Any]:\n        \"\"\"\n        Run backtest with signal function.\n\n        Args:\n            prices: DataFrame with 'close' column\n            signal_func: Function that returns position signals (-1, 0, 1)\n\n        Returns:\n            Dictionary with results\n        \"\"\"\n        # Generate signals (shifted to avoid look-ahead)\n        signals = signal_func(prices).shift(1).fillna(0)\n\n        # Calculate returns\n        returns = prices[\"close\"].pct_change()\n\n        # Calculate strategy returns with costs\n        position_changes = signals.diff().abs()\n        trading_costs = position_changes * (self.commission + self.slippage)\n\n        strategy_returns = signals * returns - trading_costs\n\n        # Build equity curve\n        equity = (1 + strategy_returns).cumprod() * self.initial_capital\n\n        # Calculate metrics\n        results = {\n            \"equity\": equity,\n            \"returns\": strategy_returns,\n            \"signals\": signals,\n            \"metrics\": self._calculate_metrics(strategy_returns, equity)\n        }\n\n        return results\n\n    def _calculate_metrics(\n        self,\n        returns: pd.Series,\n        equity: pd.Series\n    ) -> Dict[str, float]:\n        \"\"\"Calculate performance metrics.\"\"\"\n        total_return = (equity.iloc[-1] / self.initial_capital) - 1\n        annual_return = (1 + total_return) ** (252 / len(returns)) - 1\n        annual_vol = returns.std() * np.sqrt(252)\n        sharpe = annual_return / annual_vol if annual_vol > 0 else 0\n\n        # Drawdown\n        rolling_max = equity.cummax()\n        drawdown = (equity - rolling_max) / rolling_max\n        max_drawdown = drawdown.min()\n\n        # Win rate\n        winning_days = (returns > 0).sum()\n        total_days = (returns != 0).sum()\n        win_rate = winning_days / total_days if total_days > 0 else 0\n\n        return {\n            \"total_return\": total_return,\n            \"annual_return\": annual_return,\n            \"annual_volatility\": annual_vol,\n            \"sharpe_ratio\": sharpe,\n            \"max_drawdown\": max_drawdown,\n            \"win_rate\": win_rate,\n            \"num_trades\": int((returns != 0).sum())\n        }\n\n# Example usage\ndef momentum_signal(prices: pd.DataFrame, lookback: int = 20) -> pd.Series:\n    \"\"\"Simple momentum strategy: long when price > SMA, else flat.\"\"\"\n    sma = prices[\"close\"].rolling(lookback).mean()\n    return (prices[\"close\"] > sma).astype(int)\n\n# Run backtest\n# backtester = VectorizedBacktester()\n# results = backtester.run(price_data, lambda p: momentum_signal(p, 50))\n```\n\n### Pattern 3: Walk-Forward Optimization\n\n```python\nfrom typing import Callable, Dict, List, Tuple, Any\nimport pandas as pd\nimport numpy as np\nfrom itertools import product\n\nclass WalkForwardOptimizer:\n    \"\"\"Walk-forward analysis with anchored or rolling windows.\"\"\"\n\n    def __init__(\n        self,\n        train_period: int,\n        test_period: int,\n        anchored: bool = False,\n        n_splits: int = None\n    ):\n        \"\"\"\n        Args:\n            train_period: Number of bars in training window\n            test_period: Number of bars in test window\n            anchored: If True, training always starts from beginning\n            n_splits: Number of train/test splits (auto-calculated if None)\n        \"\"\"\n        self.train_period = train_period\n        self.test_period = test_period\n        self.anchored = anchored\n        self.n_splits = n_splits\n\n    def generate_splits(\n        self,\n        data: pd.DataFrame\n    ) -> List[Tuple[pd.DataFrame, pd.DataFrame]]:\n        \"\"\"Generate train/test splits.\"\"\"\n        splits = []\n        n = len(data)\n\n        if self.n_splits:\n            step = (n - self.train_period) // self.n_splits\n        else:\n            step = self.test_period\n\n        start = 0\n        while start + self.train_period + self.test_period <= n:\n            if self.anchored:\n                train_start = 0\n            else:\n                train_start = start\n\n            train_end = start + self.train_period\n            test_end = min(train_end + self.test_period, n)\n\n            train_data = data.iloc[train_start:train_end]\n            test_data = data.iloc[train_end:test_end]\n\n            splits.append((train_data, test_data))\n            start += step\n\n        return splits\n\n    def optimize(\n        self,\n        data: pd.DataFrame,\n        strategy_func: Callable,\n        param_grid: Dict[str, List],\n        metric: str = \"sharpe_ratio\"\n    ) -> Dict[str, Any]:\n        \"\"\"\n        Run walk-forward optimization.\n\n        Args:\n            data: Full dataset\n            strategy_func: Function(data, **params) -> results dict\n            param_grid: Parameter combinations to test\n            metric: Metric to optimize\n\n        Returns:\n            Combined results from all test periods\n        \"\"\"\n        splits = self.generate_splits(data)\n        all_results = []\n        optimal_params_history = []\n\n        for i, (train_data, test_data) in enumerate(splits):\n            # Optimize on training data\n            best_params, best_metric = self._grid_search(\n                train_data, strategy_func, param_grid, metric\n            )\n            optimal_params_history.append(best_params)\n\n            # Test with optimal params\n            test_results = strategy_func(test_data, **best_params)\n            test_results[\"split\"] = i\n            test_results[\"params\"] = best_params\n            all_results.append(test_results)\n\n            print(f\"Split {i+1}/{len(splits)}: \"\n                  f\"Best {metric}={best_metric:.4f}, params={best_params}\")\n\n        return {\n            \"split_results\": all_results,\n            \"param_history\": optimal_params_history,\n            \"combined_equity\": self._combine_equity_curves(all_results)\n        }\n\n    def _grid_search(\n        self,\n        data: pd.DataFrame,\n        strategy_func: Callable,\n        param_grid: Dict[str, List],\n        metric: str\n    ) -> Tuple[Dict, float]:\n        \"\"\"Grid search for best parameters.\"\"\"\n        best_params = None\n        best_metric = -np.inf\n\n        # Generate all parameter combinations\n        param_names = list(param_grid.keys())\n        param_values = list(param_grid.values())\n\n        for values in product(*param_values):\n            params = dict(zip(param_names, values))\n            results = strategy_func(data, **params)\n\n            if results[\"metrics\"][metric] > best_metric:\n                best_metric = results[\"metrics\"][metric]\n                best_params = params\n\n        return best_params, best_metric\n\n    def _combine_equity_curves(\n        self,\n        results: List[Dict]\n    ) -> pd.Series:\n        \"\"\"Combine equity curves from all test periods.\"\"\"\n        combined = pd.concat([r[\"equity\"] for r in results])\n        return combined\n```\n\n### Pattern 4: Monte Carlo Analysis\n\n```python\nimport numpy as np\nimport pandas as pd\nfrom typing import Dict, List\n\nclass MonteCarloAnalyzer:\n    \"\"\"Monte Carlo simulation for strategy robustness.\"\"\"\n\n    def __init__(self, n_simulations: int = 1000, confidence: float = 0.95):\n        self.n_simulations = n_simulations\n        self.confidence = confidence\n\n    def bootstrap_returns(\n        self,\n        returns: pd.Series,\n        n_periods: int = None\n    ) -> np.ndarray:\n        \"\"\"\n        Bootstrap simulation by resampling returns.\n\n        Args:\n            returns: Historical returns series\n            n_periods: Length of each simulation (default: same as input)\n\n        Returns:\n            Array of shape (n_simulations, n_periods)\n        \"\"\"\n        if n_periods is None:\n            n_periods = len(returns)\n\n        simulations = np.zeros((self.n_simulations, n_periods))\n\n        for i in range(self.n_simulations):\n            # Resample with replacement\n            simulated_returns = np.random.choice(\n                returns.values,\n                size=n_periods,\n                replace=True\n            )\n            simulations[i] = simulated_returns\n\n        return simulations\n\n    def analyze_drawdowns(\n        self,\n        returns: pd.Series\n    ) -> Dict[str, float]:\n        \"\"\"Analyze drawdown distribution via simulation.\"\"\"\n        simulations = self.bootstrap_returns(returns)\n\n        max_drawdowns = []\n        for sim_returns in simulations:\n            equity = (1 + sim_returns).cumprod()\n            rolling_max = np.maximum.accumulate(equity)\n            drawdowns = (equity - rolling_max) / rolling_max\n            max_drawdowns.append(drawdowns.min())\n\n        max_drawdowns = np.array(max_drawdowns)\n\n        return {\n            \"expected_max_dd\": np.mean(max_drawdowns),\n            \"median_max_dd\": np.median(max_drawdowns),\n            f\"worst_{int(self.confidence*100)}pct\": np.percentile(\n                max_drawdowns, (1 - self.confidence) * 100\n            ),\n            \"worst_case\": max_drawdowns.min()\n        }\n\n    def probability_of_loss(\n        self,\n        returns: pd.Series,\n        holding_periods: List[int] = [21, 63, 126, 252]\n    ) -> Dict[int, float]:\n        \"\"\"Calculate probability of loss over various holding periods.\"\"\"\n        results = {}\n\n        for period in holding_periods:\n            if period > len(returns):\n                continue\n\n            simulations = self.bootstrap_returns(returns, period)\n            total_returns = (1 + simulations).prod(axis=1) - 1\n            prob_loss = (total_returns < 0).mean()\n            results[period] = prob_loss\n\n        return results\n\n    def confidence_interval(\n        self,\n        returns: pd.Series,\n        periods: int = 252\n    ) -> Dict[str, float]:\n        \"\"\"Calculate confidence interval for future returns.\"\"\"\n        simulations = self.bootstrap_returns(returns, periods)\n        total_returns = (1 + simulations).prod(axis=1) - 1\n\n        lower = (1 - self.confidence) / 2\n        upper = 1 - lower\n\n        return {\n            \"expected\": total_returns.mean(),\n            \"lower_bound\": np.percentile(total_returns, lower * 100),\n            \"upper_bound\": np.percentile(total_returns, upper * 100),\n            \"std\": total_returns.std()\n        }\n```\n\n## Performance Metrics\n\n```python\ndef calculate_metrics(returns: pd.Series, rf_rate: float = 0.02) -> Dict[str, float]:\n    \"\"\"Calculate comprehensive performance metrics.\"\"\"\n    # Annualization factor (assuming daily returns)\n    ann_factor = 252\n\n    # Basic metrics\n    total_return = (1 + returns).prod() - 1\n    annual_return = (1 + total_return) ** (ann_factor / len(returns)) - 1\n    annual_vol = returns.std() * np.sqrt(ann_factor)\n\n    # Risk-adjusted returns\n    sharpe = (annual_return - rf_rate) / annual_vol if annual_vol > 0 else 0\n\n    # Sortino (downside deviation)\n    downside_returns = returns[returns < 0]\n    downside_vol = downside_returns.std() * np.sqrt(ann_factor)\n    sortino = (annual_return - rf_rate) / downside_vol if downside_vol > 0 else 0\n\n    # Calmar ratio\n    equity = (1 + returns).cumprod()\n    rolling_max = equity.cummax()\n    drawdowns = (equity - rolling_max) / rolling_max\n    max_drawdown = drawdowns.min()\n    calmar = annual_return / abs(max_drawdown) if max_drawdown != 0 else 0\n\n    # Win rate and profit factor\n    wins = returns[returns > 0]\n    losses = returns[returns < 0]\n    win_rate = len(wins) / len(returns[returns != 0]) if len(returns[returns != 0]) > 0 else 0\n    profit_factor = wins.sum() / abs(losses.sum()) if losses.sum() != 0 else np.inf\n\n    return {\n        \"total_return\": total_return,\n        \"annual_return\": annual_return,\n        \"annual_volatility\": annual_vol,\n        \"sharpe_ratio\": sharpe,\n        \"sortino_ratio\": sortino,\n        \"calmar_ratio\": calmar,\n        \"max_drawdown\": max_drawdown,\n        \"win_rate\": win_rate,\n        \"profit_factor\": profit_factor,\n        \"num_trades\": int((returns != 0).sum())\n    }\n```\n\n## Best Practices\n\n### Do's\n- **Use point-in-time data** - Avoid look-ahead bias\n- **Include transaction costs** - Realistic estimates\n- **Test out-of-sample** - Always reserve data\n- **Use walk-forward** - Not just train/test\n- **Monte Carlo analysis** - Understand uncertainty\n\n### Don'ts\n- **Don't overfit** - Limit parameters\n- **Don't ignore survivorship** - Include delisted\n- **Don't use adjusted data carelessly** - Understand adjustments\n- **Don't optimize on full history** - Reserve test set\n- **Don't ignore capacity** - Market impact matters\n\n## Resources\n\n- [Advances in Financial Machine Learning (Marcos L\u00f3pez de Prado)](https://www.amazon.com/Advances-Financial-Machine-Learning-Marcos/dp/1119482089)\n- [Quantitative Trading (Ernest Chan)](https://www.amazon.com/Quantitative-Trading-Build-Algorithmic-Business/dp/1119800064)\n- [Backtrader Documentation](https://www.backtrader.com/docu/)\n"
}