{
  "id": "blockchain_web3_web3_testing",
  "name": "web3-testing",
  "source": "blockchain-web3",
  "originalPath": "plugins/blockchain-web3/skills/web3-testing/SKILL.md",
  "activationCriteria": "Test smart contracts comprehensively using Hardhat and Foundry with unit tests, integration tests, and mainnet forking. Use when testing Solidity contracts, setting up blockchain test suites, or valid",
  "tier1_metadata": "web3-testing: Test smart contracts comprehensively using Hardhat and Foundry with unit tests, integration tests, a",
  "tier2_instructions": "# Web3 Smart Contract Testing\n\nMaster comprehensive testing strategies for smart contracts using Hardhat, Foundry, and advanced testing patterns.\n\n## When to Use This Skill\n\n- Writing unit tests for smart contracts\n- Setting up integration test suites\n- Performing gas optimization testing\n- Fuzzing for edge cases\n- Forking mainnet for realistic testing\n- Automating test coverage reporting\n- Verifying contracts on Etherscan\n\n## Hardhat Testing Setup\n\n```javascript\n// hardhat.config.js\nrequire(\"@nomicfoundation/hardhat-toolbox\");\nrequire(\"@nomiclabs/hardhat-etherscan\");\nrequire(\"hardhat-gas-reporter\");\nrequire(\"solidity-coverage\");\n\nmodule.exports = {\n  solidity: {\n    version: \"0.8.19\",\n    settings: {\n      optimizer: {\n        enabled: true,\n        runs: 200\n      }\n    }\n  },\n  networks: {\n    hardhat: {\n      forking: {\n        url: process.env.MAINNET_RPC_URL,\n        blockNumber: 15000000\n      }\n    },\n    goerli: {\n      url: process.env.GOERLI_RPC_URL,\n      accounts: [process.env.PRIVATE_KEY]\n    }\n  },\n  gasReporter: {\n    enabled: true,\n    currency: 'USD',\n    coinmarketcap: process.env.COINMARKETCAP_API_KEY\n  },\n  etherscan: {\n    apiKey: process.env.ETHERSCAN_API_KEY\n  }\n};\n```\n\n## Unit Testing Patterns\n\n```javascript\nconst { expect } = require(\"chai\");\nconst { ethers } = require(\"hardhat\");\nconst { loadFixture, time } = require(\"@nomicfoundation/hardhat-network-helpers\");\n\ndescribe(\"Token Contract\", function () {\n  // Fixture for test setup\n  async function deployTokenFixture() {\n    const [owner, addr1, addr2] = await ethers.getSigners();\n\n    const Token = await ethers.getContractFactory(\"Token\");\n    const token = await Token.deploy();\n\n    return { token, owner, addr1, addr2 };\n  }\n\n  describe(\"Deployment\", function () {\n    it(\"Should set the right owner\", async function () {\n      const { token, owner } = await loadFixture(deployTokenFixture);\n      expect(await token.owner()).to.equal(owner.address);\n    });\n\n    it(\"Should assign total supply",
  "tier3_resources": " to owner\", async function () {\n      const { token, owner } = await loadFixture(deployTokenFixture);\n      const ownerBalance = await token.balanceOf(owner.address);\n      expect(await token.totalSupply()).to.equal(ownerBalance);\n    });\n  });\n\n  describe(\"Transactions\", function () {\n    it(\"Should transfer tokens between accounts\", async function () {\n      const { token, owner, addr1 } = await loadFixture(deployTokenFixture);\n\n      await expect(token.transfer(addr1.address, 50))\n        .to.changeTokenBalances(token, [owner, addr1], [-50, 50]);\n    });\n\n    it(\"Should fail if sender doesn't have enough tokens\", async function () {\n      const { token, addr1 } = await loadFixture(deployTokenFixture);\n      const initialBalance = await token.balanceOf(addr1.address);\n\n      await expect(\n        token.connect(addr1).transfer(owner.address, 1)\n      ).to.be.revertedWith(\"Insufficient balance\");\n    });\n\n    it(\"Should emit Transfer event\", async function () {\n      const { token, owner, addr1 } = await loadFixture(deployTokenFixture);\n\n      await expect(token.transfer(addr1.address, 50))\n        .to.emit(token, \"Transfer\")\n        .withArgs(owner.address, addr1.address, 50);\n    });\n  });\n\n  describe(\"Time-based tests\", function () {\n    it(\"Should handle time-locked operations\", async function () {\n      const { token } = await loadFixture(deployTokenFixture);\n\n      // Increase time by 1 day\n      await time.increase(86400);\n\n      // Test time-dependent functionality\n    });\n  });\n\n  describe(\"Gas optimization\", function () {\n    it(\"Should use gas efficiently\", async function () {\n      const { token } = await loadFixture(deployTokenFixture);\n\n      const tx = await token.transfer(addr1.address, 100);\n      const receipt = await tx.wait();\n\n      expect(receipt.gasUsed).to.be.lessThan(50000);\n    });\n  });\n});\n```\n\n## Foundry Testing (Forge)\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"forge-std/Test.sol\";\nimport \"../src/Token.sol\";\n\ncontract TokenTest is Test {\n    Token token;\n    address owner = address(1);\n    address user1 = address(2);\n    address user2 = address(3);\n\n    function setUp() public {\n        vm.prank(owner);\n        token = new Token();\n    }\n\n    function testInitialSupply() public {\n        assertEq(token.totalSupply(), 1000000 * 10**18);\n    }\n\n    function testTransfer() public {\n        vm.prank(owner);\n        token.transfer(user1, 100);\n\n        assertEq(token.balanceOf(user1), 100);\n        assertEq(token.balanceOf(owner), token.totalSupply() - 100);\n    }\n\n    function testFailTransferInsufficientBalance() public {\n        vm.prank(user1);\n        token.transfer(user2, 100); // Should fail\n    }\n\n    function testCannotTransferToZeroAddress() public {\n        vm.prank(owner);\n        vm.expectRevert(\"Invalid recipient\");\n        token.transfer(address(0), 100);\n    }\n\n    // Fuzzing test\n    function testFuzzTransfer(uint256 amount) public {\n        vm.assume(amount > 0 && amoun",
  "tokenEstimate": {
    "tier1": 19.5,
    "tier2": 286.0,
    "tier3": 1077.7
  },
  "fullDefinition": "---\nname: web3-testing\ndescription: Test smart contracts comprehensively using Hardhat and Foundry with unit tests, integration tests, and mainnet forking. Use when testing Solidity contracts, setting up blockchain test suites, or validating DeFi protocols.\n---\n\n# Web3 Smart Contract Testing\n\nMaster comprehensive testing strategies for smart contracts using Hardhat, Foundry, and advanced testing patterns.\n\n## When to Use This Skill\n\n- Writing unit tests for smart contracts\n- Setting up integration test suites\n- Performing gas optimization testing\n- Fuzzing for edge cases\n- Forking mainnet for realistic testing\n- Automating test coverage reporting\n- Verifying contracts on Etherscan\n\n## Hardhat Testing Setup\n\n```javascript\n// hardhat.config.js\nrequire(\"@nomicfoundation/hardhat-toolbox\");\nrequire(\"@nomiclabs/hardhat-etherscan\");\nrequire(\"hardhat-gas-reporter\");\nrequire(\"solidity-coverage\");\n\nmodule.exports = {\n  solidity: {\n    version: \"0.8.19\",\n    settings: {\n      optimizer: {\n        enabled: true,\n        runs: 200\n      }\n    }\n  },\n  networks: {\n    hardhat: {\n      forking: {\n        url: process.env.MAINNET_RPC_URL,\n        blockNumber: 15000000\n      }\n    },\n    goerli: {\n      url: process.env.GOERLI_RPC_URL,\n      accounts: [process.env.PRIVATE_KEY]\n    }\n  },\n  gasReporter: {\n    enabled: true,\n    currency: 'USD',\n    coinmarketcap: process.env.COINMARKETCAP_API_KEY\n  },\n  etherscan: {\n    apiKey: process.env.ETHERSCAN_API_KEY\n  }\n};\n```\n\n## Unit Testing Patterns\n\n```javascript\nconst { expect } = require(\"chai\");\nconst { ethers } = require(\"hardhat\");\nconst { loadFixture, time } = require(\"@nomicfoundation/hardhat-network-helpers\");\n\ndescribe(\"Token Contract\", function () {\n  // Fixture for test setup\n  async function deployTokenFixture() {\n    const [owner, addr1, addr2] = await ethers.getSigners();\n\n    const Token = await ethers.getContractFactory(\"Token\");\n    const token = await Token.deploy();\n\n    return { token, owner, addr1, addr2 };\n  }\n\n  describe(\"Deployment\", function () {\n    it(\"Should set the right owner\", async function () {\n      const { token, owner } = await loadFixture(deployTokenFixture);\n      expect(await token.owner()).to.equal(owner.address);\n    });\n\n    it(\"Should assign total supply to owner\", async function () {\n      const { token, owner } = await loadFixture(deployTokenFixture);\n      const ownerBalance = await token.balanceOf(owner.address);\n      expect(await token.totalSupply()).to.equal(ownerBalance);\n    });\n  });\n\n  describe(\"Transactions\", function () {\n    it(\"Should transfer tokens between accounts\", async function () {\n      const { token, owner, addr1 } = await loadFixture(deployTokenFixture);\n\n      await expect(token.transfer(addr1.address, 50))\n        .to.changeTokenBalances(token, [owner, addr1], [-50, 50]);\n    });\n\n    it(\"Should fail if sender doesn't have enough tokens\", async function () {\n      const { token, addr1 } = await loadFixture(deployTokenFixture);\n      const initialBalance = await token.balanceOf(addr1.address);\n\n      await expect(\n        token.connect(addr1).transfer(owner.address, 1)\n      ).to.be.revertedWith(\"Insufficient balance\");\n    });\n\n    it(\"Should emit Transfer event\", async function () {\n      const { token, owner, addr1 } = await loadFixture(deployTokenFixture);\n\n      await expect(token.transfer(addr1.address, 50))\n        .to.emit(token, \"Transfer\")\n        .withArgs(owner.address, addr1.address, 50);\n    });\n  });\n\n  describe(\"Time-based tests\", function () {\n    it(\"Should handle time-locked operations\", async function () {\n      const { token } = await loadFixture(deployTokenFixture);\n\n      // Increase time by 1 day\n      await time.increase(86400);\n\n      // Test time-dependent functionality\n    });\n  });\n\n  describe(\"Gas optimization\", function () {\n    it(\"Should use gas efficiently\", async function () {\n      const { token } = await loadFixture(deployTokenFixture);\n\n      const tx = await token.transfer(addr1.address, 100);\n      const receipt = await tx.wait();\n\n      expect(receipt.gasUsed).to.be.lessThan(50000);\n    });\n  });\n});\n```\n\n## Foundry Testing (Forge)\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"forge-std/Test.sol\";\nimport \"../src/Token.sol\";\n\ncontract TokenTest is Test {\n    Token token;\n    address owner = address(1);\n    address user1 = address(2);\n    address user2 = address(3);\n\n    function setUp() public {\n        vm.prank(owner);\n        token = new Token();\n    }\n\n    function testInitialSupply() public {\n        assertEq(token.totalSupply(), 1000000 * 10**18);\n    }\n\n    function testTransfer() public {\n        vm.prank(owner);\n        token.transfer(user1, 100);\n\n        assertEq(token.balanceOf(user1), 100);\n        assertEq(token.balanceOf(owner), token.totalSupply() - 100);\n    }\n\n    function testFailTransferInsufficientBalance() public {\n        vm.prank(user1);\n        token.transfer(user2, 100); // Should fail\n    }\n\n    function testCannotTransferToZeroAddress() public {\n        vm.prank(owner);\n        vm.expectRevert(\"Invalid recipient\");\n        token.transfer(address(0), 100);\n    }\n\n    // Fuzzing test\n    function testFuzzTransfer(uint256 amount) public {\n        vm.assume(amount > 0 && amount <= token.totalSupply());\n\n        vm.prank(owner);\n        token.transfer(user1, amount);\n\n        assertEq(token.balanceOf(user1), amount);\n    }\n\n    // Test with cheatcodes\n    function testDealAndPrank() public {\n        // Give ETH to address\n        vm.deal(user1, 10 ether);\n\n        // Impersonate address\n        vm.prank(user1);\n\n        // Test functionality\n        assertEq(user1.balance, 10 ether);\n    }\n\n    // Mainnet fork test\n    function testForkMainnet() public {\n        vm.createSelectFork(\"https://eth-mainnet.alchemyapi.io/v2/...\");\n\n        // Interact with mainnet contracts\n        address dai = 0x6B175474E89094C44Da98b954EedeAC495271d0F;\n        assertEq(IERC20(dai).symbol(), \"DAI\");\n    }\n}\n```\n\n## Advanced Testing Patterns\n\n### Snapshot and Revert\n```javascript\ndescribe(\"Complex State Changes\", function () {\n  let snapshotId;\n\n  beforeEach(async function () {\n    snapshotId = await network.provider.send(\"evm_snapshot\");\n  });\n\n  afterEach(async function () {\n    await network.provider.send(\"evm_revert\", [snapshotId]);\n  });\n\n  it(\"Test 1\", async function () {\n    // Make state changes\n  });\n\n  it(\"Test 2\", async function () {\n    // State reverted, clean slate\n  });\n});\n```\n\n### Mainnet Forking\n```javascript\ndescribe(\"Mainnet Fork Tests\", function () {\n  let uniswapRouter, dai, usdc;\n\n  before(async function () {\n    await network.provider.request({\n      method: \"hardhat_reset\",\n      params: [{\n        forking: {\n          jsonRpcUrl: process.env.MAINNET_RPC_URL,\n          blockNumber: 15000000\n        }\n      }]\n    });\n\n    // Connect to existing mainnet contracts\n    uniswapRouter = await ethers.getContractAt(\n      \"IUniswapV2Router\",\n      \"0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D\"\n    );\n\n    dai = await ethers.getContractAt(\n      \"IERC20\",\n      \"0x6B175474E89094C44Da98b954EedeAC495271d0F\"\n    );\n  });\n\n  it(\"Should swap on Uniswap\", async function () {\n    // Test with real Uniswap contracts\n  });\n});\n```\n\n### Impersonating Accounts\n```javascript\nit(\"Should impersonate whale account\", async function () {\n  const whaleAddress = \"0x...\";\n\n  await network.provider.request({\n    method: \"hardhat_impersonateAccount\",\n    params: [whaleAddress]\n  });\n\n  const whale = await ethers.getSigner(whaleAddress);\n\n  // Use whale's tokens\n  await dai.connect(whale).transfer(addr1.address, ethers.utils.parseEther(\"1000\"));\n});\n```\n\n## Gas Optimization Testing\n\n```javascript\nconst { expect } = require(\"chai\");\n\ndescribe(\"Gas Optimization\", function () {\n  it(\"Compare gas usage between implementations\", async function () {\n    const Implementation1 = await ethers.getContractFactory(\"OptimizedContract\");\n    const Implementation2 = await ethers.getContractFactory(\"UnoptimizedContract\");\n\n    const contract1 = await Implementation1.deploy();\n    const contract2 = await Implementation2.deploy();\n\n    const tx1 = await contract1.doSomething();\n    const receipt1 = await tx1.wait();\n\n    const tx2 = await contract2.doSomething();\n    const receipt2 = await tx2.wait();\n\n    console.log(\"Optimized gas:\", receipt1.gasUsed.toString());\n    console.log(\"Unoptimized gas:\", receipt2.gasUsed.toString());\n\n    expect(receipt1.gasUsed).to.be.lessThan(receipt2.gasUsed);\n  });\n});\n```\n\n## Coverage Reporting\n\n```bash\n# Generate coverage report\nnpx hardhat coverage\n\n# Output shows:\n# File                | % Stmts | % Branch | % Funcs | % Lines |\n# -------------------|---------|----------|---------|---------|\n# contracts/Token.sol |   100   |   90     |   100   |   95    |\n```\n\n## Contract Verification\n\n```javascript\n// Verify on Etherscan\nawait hre.run(\"verify:verify\", {\n  address: contractAddress,\n  constructorArguments: [arg1, arg2]\n});\n```\n\n```bash\n# Or via CLI\nnpx hardhat verify --network mainnet CONTRACT_ADDRESS \"Constructor arg1\" \"arg2\"\n```\n\n## CI/CD Integration\n\n```yaml\n# .github/workflows/test.yml\nname: Tests\n\non: [push, pull_request]\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n\n    steps:\n      - uses: actions/checkout@v2\n      - uses: actions/setup-node@v2\n        with:\n          node-version: '16'\n\n      - run: npm install\n      - run: npx hardhat compile\n      - run: npx hardhat test\n      - run: npx hardhat coverage\n\n      - name: Upload coverage to Codecov\n        uses: codecov/codecov-action@v2\n```\n\n## Resources\n\n- **references/hardhat-setup.md**: Hardhat configuration guide\n- **references/foundry-setup.md**: Foundry testing framework\n- **references/test-patterns.md**: Testing best practices\n- **references/mainnet-forking.md**: Fork testing strategies\n- **references/contract-verification.md**: Etherscan verification\n- **assets/hardhat-config.js**: Complete Hardhat configuration\n- **assets/test-suite.js**: Comprehensive test examples\n- **assets/foundry.toml**: Foundry configuration\n- **scripts/test-contract.sh**: Automated testing script\n\n## Best Practices\n\n1. **Test Coverage**: Aim for >90% coverage\n2. **Edge Cases**: Test boundary conditions\n3. **Gas Limits**: Verify functions don't hit block gas limit\n4. **Reentrancy**: Test for reentrancy vulnerabilities\n5. **Access Control**: Test unauthorized access attempts\n6. **Events**: Verify event emissions\n7. **Fixtures**: Use fixtures to avoid code duplication\n8. **Mainnet Fork**: Test with real contracts\n9. **Fuzzing**: Use property-based testing\n10. **CI/CD**: Automate testing on every commit\n"
}