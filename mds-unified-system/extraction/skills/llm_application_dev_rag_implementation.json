{
  "id": "llm_application_dev_rag_implementation",
  "name": "rag-implementation",
  "source": "llm-application-dev",
  "originalPath": "plugins/llm-application-dev/skills/rag-implementation/SKILL.md",
  "activationCriteria": "Build Retrieval-Augmented Generation (RAG) systems for LLM applications with vector databases and semantic search. Use when implementing knowledge-grounded AI, building document Q&A systems, or integr",
  "tier1_metadata": "rag-implementation: Build Retrieval-Augmented Generation (RAG) systems for LLM applications with vector databases and se",
  "tier2_instructions": "# RAG Implementation\n\nMaster Retrieval-Augmented Generation (RAG) to build LLM applications that provide accurate, grounded responses using external knowledge sources.\n\n## When to Use This Skill\n\n- Building Q&A systems over proprietary documents\n- Creating chatbots with current, factual information\n- Implementing semantic search with natural language queries\n- Reducing hallucinations with grounded responses\n- Enabling LLMs to access domain-specific knowledge\n- Building documentation assistants\n- Creating research tools with source citation\n\n## Core Components\n\n### 1. Vector Databases\n**Purpose**: Store and retrieve document embeddings efficiently\n\n**Options:**\n- **Pinecone**: Managed, scalable, fast queries\n- **Weaviate**: Open-source, hybrid search\n- **Milvus**: High performance, on-premise\n- **Chroma**: Lightweight, easy to use\n- **Qdrant**: Fast, filtered search\n- **FAISS**: Meta's library, local deployment\n\n### 2. Embeddings\n**Purpose**: Convert text to numerical vectors for similarity search\n\n**Models:**\n- **text-embedding-ada-002** (OpenAI): General purpose, 1536 dims\n- **all-MiniLM-L6-v2** (Sentence Transformers): Fast, lightweight\n- **e5-large-v2**: High quality, multilingual\n- **Instructor**: Task-specific instructions\n- **bge-large-en-v1.5**: SOTA performance\n\n### 3. Retrieval Strategies\n**Approaches:**\n- **Dense Retrieval**: Semantic similarity via embeddings\n- **Sparse Retrieval**: Keyword matching (BM25, TF-IDF)\n- **Hybrid Search**: Combine dense + sparse\n- **Multi-Query**: Generate multiple query variations\n- **HyDE**: Generate hypothetical documents\n\n### 4. Reranking\n**Purpose**: Improve retrieval quality by reordering results\n\n**Methods:**\n- **Cross-Encoders**: BERT-based reranking\n- **Cohere Rerank**: API-based reranking\n- **Maximal Marginal Relevance (MMR)**: Diversity + relevance\n- **LLM-based**: Use LLM to score relevance\n\n## Quick Start\n\n```python\nfrom langchain.document_loaders import DirectoryLoader\nfrom langchain.text_splitters import Recursi",
  "tier3_resources": "veCharacterTextSplitter\nfrom langchain.embeddings import OpenAIEmbeddings\nfrom langchain.vectorstores import Chroma\nfrom langchain.chains import RetrievalQA\nfrom langchain.llms import OpenAI\n\n# 1. Load documents\nloader = DirectoryLoader('./docs', glob=\"**/*.txt\")\ndocuments = loader.load()\n\n# 2. Split into chunks\ntext_splitter = RecursiveCharacterTextSplitter(\n    chunk_size=1000,\n    chunk_overlap=200,\n    length_function=len\n)\nchunks = text_splitter.split_documents(documents)\n\n# 3. Create embeddings and vector store\nembeddings = OpenAIEmbeddings()\nvectorstore = Chroma.from_documents(chunks, embeddings)\n\n# 4. Create retrieval chain\nqa_chain = RetrievalQA.from_chain_type(\n    llm=OpenAI(),\n    chain_type=\"stuff\",\n    retriever=vectorstore.as_retriever(search_kwargs={\"k\": 4}),\n    return_source_documents=True\n)\n\n# 5. Query\nresult = qa_chain({\"query\": \"What are the main features?\"})\nprint(result['result'])\nprint(result['source_documents'])\n```\n\n## Advanced RAG Patterns\n\n### Pattern 1: Hybrid Search\n```python\nfrom langchain.retrievers import BM25Retriever, EnsembleRetriever\n\n# Sparse retriever (BM25)\nbm25_retriever = BM25Retriever.from_documents(chunks)\nbm25_retriever.k = 5\n\n# Dense retriever (embeddings)\nembedding_retriever = vectorstore.as_retriever(search_kwargs={\"k\": 5})\n\n# Combine with weights\nensemble_retriever = EnsembleRetriever(\n    retrievers=[bm25_retriever, embedding_retriever],\n    weights=[0.3, 0.7]\n)\n```\n\n### Pattern 2: Multi-Query Retrieval\n```python\nfrom langchain.retrievers.multi_query import MultiQueryRetriever\n\n# Generate multiple query perspectives\nretriever = MultiQueryRetriever.from_llm(\n    retriever=vectorstore.as_retriever(),\n    llm=OpenAI()\n)\n\n# Single query \u2192 multiple variations \u2192 combined results\nresults = retriever.get_relevant_documents(\"What is the main topic?\")\n```\n\n### Pattern 3: Contextual Compression\n```python\nfrom langchain.retrievers import ContextualCompressionRetriever\nfrom langchain.retrievers.document_compressors import LLMChainExtractor\n\ncompressor = LLMChainExtractor.from_llm(llm)\n\ncompression_retriever = ContextualCompressionRetriever(\n    base_compressor=compressor,\n    base_retriever=vectorstore.as_retriever()\n)\n\n# Returns only relevant parts of documents\ncompressed_docs = compression_retriever.get_relevant_documents(\"query\")\n```\n\n### Pattern 4: Parent Document Retriever\n```python\nfrom langchain.retrievers import ParentDocumentRetriever\nfrom langchain.storage import InMemoryStore\n\n# Store for parent documents\nstore = InMemoryStore()\n\n# Small chunks for retrieval, large chunks for context\nchild_splitter = RecursiveCharacterTextSplitter(chunk_size=400)\nparent_splitter = RecursiveCharacterTextSplitter(chunk_size=2000)\n\nretriever = ParentDocumentRetriever(\n    vectorstore=vectorstore,\n    docstore=store,\n    child_splitter=child_splitter,\n    parent_splitter=parent_splitter\n)\n```\n\n## Document Chunking Strategies\n\n### Recursive Character Text Splitter\n```python\nfrom langchain.text_splitters import RecursiveC",
  "tokenEstimate": {
    "tier1": 18.2,
    "tier2": 315.90000000000003,
    "tier3": 1125.8
  },
  "fullDefinition": "---\nname: rag-implementation\ndescription: Build Retrieval-Augmented Generation (RAG) systems for LLM applications with vector databases and semantic search. Use when implementing knowledge-grounded AI, building document Q&A systems, or integrating LLMs with external knowledge bases.\n---\n\n# RAG Implementation\n\nMaster Retrieval-Augmented Generation (RAG) to build LLM applications that provide accurate, grounded responses using external knowledge sources.\n\n## When to Use This Skill\n\n- Building Q&A systems over proprietary documents\n- Creating chatbots with current, factual information\n- Implementing semantic search with natural language queries\n- Reducing hallucinations with grounded responses\n- Enabling LLMs to access domain-specific knowledge\n- Building documentation assistants\n- Creating research tools with source citation\n\n## Core Components\n\n### 1. Vector Databases\n**Purpose**: Store and retrieve document embeddings efficiently\n\n**Options:**\n- **Pinecone**: Managed, scalable, fast queries\n- **Weaviate**: Open-source, hybrid search\n- **Milvus**: High performance, on-premise\n- **Chroma**: Lightweight, easy to use\n- **Qdrant**: Fast, filtered search\n- **FAISS**: Meta's library, local deployment\n\n### 2. Embeddings\n**Purpose**: Convert text to numerical vectors for similarity search\n\n**Models:**\n- **text-embedding-ada-002** (OpenAI): General purpose, 1536 dims\n- **all-MiniLM-L6-v2** (Sentence Transformers): Fast, lightweight\n- **e5-large-v2**: High quality, multilingual\n- **Instructor**: Task-specific instructions\n- **bge-large-en-v1.5**: SOTA performance\n\n### 3. Retrieval Strategies\n**Approaches:**\n- **Dense Retrieval**: Semantic similarity via embeddings\n- **Sparse Retrieval**: Keyword matching (BM25, TF-IDF)\n- **Hybrid Search**: Combine dense + sparse\n- **Multi-Query**: Generate multiple query variations\n- **HyDE**: Generate hypothetical documents\n\n### 4. Reranking\n**Purpose**: Improve retrieval quality by reordering results\n\n**Methods:**\n- **Cross-Encoders**: BERT-based reranking\n- **Cohere Rerank**: API-based reranking\n- **Maximal Marginal Relevance (MMR)**: Diversity + relevance\n- **LLM-based**: Use LLM to score relevance\n\n## Quick Start\n\n```python\nfrom langchain.document_loaders import DirectoryLoader\nfrom langchain.text_splitters import RecursiveCharacterTextSplitter\nfrom langchain.embeddings import OpenAIEmbeddings\nfrom langchain.vectorstores import Chroma\nfrom langchain.chains import RetrievalQA\nfrom langchain.llms import OpenAI\n\n# 1. Load documents\nloader = DirectoryLoader('./docs', glob=\"**/*.txt\")\ndocuments = loader.load()\n\n# 2. Split into chunks\ntext_splitter = RecursiveCharacterTextSplitter(\n    chunk_size=1000,\n    chunk_overlap=200,\n    length_function=len\n)\nchunks = text_splitter.split_documents(documents)\n\n# 3. Create embeddings and vector store\nembeddings = OpenAIEmbeddings()\nvectorstore = Chroma.from_documents(chunks, embeddings)\n\n# 4. Create retrieval chain\nqa_chain = RetrievalQA.from_chain_type(\n    llm=OpenAI(),\n    chain_type=\"stuff\",\n    retriever=vectorstore.as_retriever(search_kwargs={\"k\": 4}),\n    return_source_documents=True\n)\n\n# 5. Query\nresult = qa_chain({\"query\": \"What are the main features?\"})\nprint(result['result'])\nprint(result['source_documents'])\n```\n\n## Advanced RAG Patterns\n\n### Pattern 1: Hybrid Search\n```python\nfrom langchain.retrievers import BM25Retriever, EnsembleRetriever\n\n# Sparse retriever (BM25)\nbm25_retriever = BM25Retriever.from_documents(chunks)\nbm25_retriever.k = 5\n\n# Dense retriever (embeddings)\nembedding_retriever = vectorstore.as_retriever(search_kwargs={\"k\": 5})\n\n# Combine with weights\nensemble_retriever = EnsembleRetriever(\n    retrievers=[bm25_retriever, embedding_retriever],\n    weights=[0.3, 0.7]\n)\n```\n\n### Pattern 2: Multi-Query Retrieval\n```python\nfrom langchain.retrievers.multi_query import MultiQueryRetriever\n\n# Generate multiple query perspectives\nretriever = MultiQueryRetriever.from_llm(\n    retriever=vectorstore.as_retriever(),\n    llm=OpenAI()\n)\n\n# Single query \u2192 multiple variations \u2192 combined results\nresults = retriever.get_relevant_documents(\"What is the main topic?\")\n```\n\n### Pattern 3: Contextual Compression\n```python\nfrom langchain.retrievers import ContextualCompressionRetriever\nfrom langchain.retrievers.document_compressors import LLMChainExtractor\n\ncompressor = LLMChainExtractor.from_llm(llm)\n\ncompression_retriever = ContextualCompressionRetriever(\n    base_compressor=compressor,\n    base_retriever=vectorstore.as_retriever()\n)\n\n# Returns only relevant parts of documents\ncompressed_docs = compression_retriever.get_relevant_documents(\"query\")\n```\n\n### Pattern 4: Parent Document Retriever\n```python\nfrom langchain.retrievers import ParentDocumentRetriever\nfrom langchain.storage import InMemoryStore\n\n# Store for parent documents\nstore = InMemoryStore()\n\n# Small chunks for retrieval, large chunks for context\nchild_splitter = RecursiveCharacterTextSplitter(chunk_size=400)\nparent_splitter = RecursiveCharacterTextSplitter(chunk_size=2000)\n\nretriever = ParentDocumentRetriever(\n    vectorstore=vectorstore,\n    docstore=store,\n    child_splitter=child_splitter,\n    parent_splitter=parent_splitter\n)\n```\n\n## Document Chunking Strategies\n\n### Recursive Character Text Splitter\n```python\nfrom langchain.text_splitters import RecursiveCharacterTextSplitter\n\nsplitter = RecursiveCharacterTextSplitter(\n    chunk_size=1000,\n    chunk_overlap=200,\n    length_function=len,\n    separators=[\"\\n\\n\", \"\\n\", \" \", \"\"]  # Try these in order\n)\n```\n\n### Token-Based Splitting\n```python\nfrom langchain.text_splitters import TokenTextSplitter\n\nsplitter = TokenTextSplitter(\n    chunk_size=512,\n    chunk_overlap=50\n)\n```\n\n### Semantic Chunking\n```python\nfrom langchain.text_splitters import SemanticChunker\n\nsplitter = SemanticChunker(\n    embeddings=OpenAIEmbeddings(),\n    breakpoint_threshold_type=\"percentile\"\n)\n```\n\n### Markdown Header Splitter\n```python\nfrom langchain.text_splitters import MarkdownHeaderTextSplitter\n\nheaders_to_split_on = [\n    (\"#\", \"Header 1\"),\n    (\"##\", \"Header 2\"),\n    (\"###\", \"Header 3\"),\n]\n\nsplitter = MarkdownHeaderTextSplitter(headers_to_split_on=headers_to_split_on)\n```\n\n## Vector Store Configurations\n\n### Pinecone\n```python\nimport pinecone\nfrom langchain.vectorstores import Pinecone\n\npinecone.init(api_key=\"your-api-key\", environment=\"us-west1-gcp\")\n\nindex = pinecone.Index(\"your-index-name\")\n\nvectorstore = Pinecone(index, embeddings.embed_query, \"text\")\n```\n\n### Weaviate\n```python\nimport weaviate\nfrom langchain.vectorstores import Weaviate\n\nclient = weaviate.Client(\"http://localhost:8080\")\n\nvectorstore = Weaviate(client, \"Document\", \"content\", embeddings)\n```\n\n### Chroma (Local)\n```python\nfrom langchain.vectorstores import Chroma\n\nvectorstore = Chroma(\n    collection_name=\"my_collection\",\n    embedding_function=embeddings,\n    persist_directory=\"./chroma_db\"\n)\n```\n\n## Retrieval Optimization\n\n### 1. Metadata Filtering\n```python\n# Add metadata during indexing\nchunks_with_metadata = []\nfor i, chunk in enumerate(chunks):\n    chunk.metadata = {\n        \"source\": chunk.metadata.get(\"source\"),\n        \"page\": i,\n        \"category\": determine_category(chunk.page_content)\n    }\n    chunks_with_metadata.append(chunk)\n\n# Filter during retrieval\nresults = vectorstore.similarity_search(\n    \"query\",\n    filter={\"category\": \"technical\"},\n    k=5\n)\n```\n\n### 2. Maximal Marginal Relevance\n```python\n# Balance relevance with diversity\nresults = vectorstore.max_marginal_relevance_search(\n    \"query\",\n    k=5,\n    fetch_k=20,  # Fetch 20, return top 5 diverse\n    lambda_mult=0.5  # 0=max diversity, 1=max relevance\n)\n```\n\n### 3. Reranking with Cross-Encoder\n```python\nfrom sentence_transformers import CrossEncoder\n\nreranker = CrossEncoder('cross-encoder/ms-marco-MiniLM-L-6-v2')\n\n# Get initial results\ncandidates = vectorstore.similarity_search(\"query\", k=20)\n\n# Rerank\npairs = [[query, doc.page_content] for doc in candidates]\nscores = reranker.predict(pairs)\n\n# Sort by score and take top k\nreranked = sorted(zip(candidates, scores), key=lambda x: x[1], reverse=True)[:5]\n```\n\n## Prompt Engineering for RAG\n\n### Contextual Prompt\n```python\nprompt_template = \"\"\"Use the following context to answer the question. If you cannot answer based on the context, say \"I don't have enough information.\"\n\nContext:\n{context}\n\nQuestion: {question}\n\nAnswer:\"\"\"\n```\n\n### With Citations\n```python\nprompt_template = \"\"\"Answer the question based on the context below. Include citations using [1], [2], etc.\n\nContext:\n{context}\n\nQuestion: {question}\n\nAnswer (with citations):\"\"\"\n```\n\n### With Confidence\n```python\nprompt_template = \"\"\"Answer the question using the context. Provide a confidence score (0-100%) for your answer.\n\nContext:\n{context}\n\nQuestion: {question}\n\nAnswer:\nConfidence:\"\"\"\n```\n\n## Evaluation Metrics\n\n```python\ndef evaluate_rag_system(qa_chain, test_cases):\n    metrics = {\n        'accuracy': [],\n        'retrieval_quality': [],\n        'groundedness': []\n    }\n\n    for test in test_cases:\n        result = qa_chain({\"query\": test['question']})\n\n        # Check if answer matches expected\n        accuracy = calculate_accuracy(result['result'], test['expected'])\n        metrics['accuracy'].append(accuracy)\n\n        # Check if relevant docs were retrieved\n        retrieval_quality = evaluate_retrieved_docs(\n            result['source_documents'],\n            test['relevant_docs']\n        )\n        metrics['retrieval_quality'].append(retrieval_quality)\n\n        # Check if answer is grounded in context\n        groundedness = check_groundedness(\n            result['result'],\n            result['source_documents']\n        )\n        metrics['groundedness'].append(groundedness)\n\n    return {k: sum(v)/len(v) for k, v in metrics.items()}\n```\n\n## Resources\n\n- **references/vector-databases.md**: Detailed comparison of vector DBs\n- **references/embeddings.md**: Embedding model selection guide\n- **references/retrieval-strategies.md**: Advanced retrieval techniques\n- **references/reranking.md**: Reranking methods and when to use them\n- **references/context-window.md**: Managing context limits\n- **assets/vector-store-config.yaml**: Configuration templates\n- **assets/retriever-pipeline.py**: Complete RAG pipeline\n- **assets/embedding-models.md**: Model comparison and benchmarks\n\n## Best Practices\n\n1. **Chunk Size**: Balance between context and specificity (500-1000 tokens)\n2. **Overlap**: Use 10-20% overlap to preserve context at boundaries\n3. **Metadata**: Include source, page, timestamp for filtering and debugging\n4. **Hybrid Search**: Combine semantic and keyword search for best results\n5. **Reranking**: Improve top results with cross-encoder\n6. **Citations**: Always return source documents for transparency\n7. **Evaluation**: Continuously test retrieval quality and answer accuracy\n8. **Monitoring**: Track retrieval metrics in production\n\n## Common Issues\n\n- **Poor Retrieval**: Check embedding quality, chunk size, query formulation\n- **Irrelevant Results**: Add metadata filtering, use hybrid search, rerank\n- **Missing Information**: Ensure documents are properly indexed\n- **Slow Queries**: Optimize vector store, use caching, reduce k\n- **Hallucinations**: Improve grounding prompt, add verification step\n"
}