{
  "id": "shell_scripting_bats_testing_patterns",
  "name": "bats-testing-patterns",
  "source": "shell-scripting",
  "originalPath": "plugins/shell-scripting/skills/bats-testing-patterns/SKILL.md",
  "activationCriteria": "Master Bash Automated Testing System (Bats) for comprehensive shell script testing. Use when writing tests for shell scripts, CI/CD pipelines, or requiring test-driven development of shell utilities.",
  "tier1_metadata": "bats-testing-patterns: Master Bash Automated Testing System (Bats) for comprehensive shell script testing. Use when writing",
  "tier2_instructions": "# Bats Testing Patterns\n\nComprehensive guidance for writing comprehensive unit tests for shell scripts using Bats (Bash Automated Testing System), including test patterns, fixtures, and best practices for production-grade shell testing.\n\n## When to Use This Skill\n\n- Writing unit tests for shell scripts\n- Implementing test-driven development (TDD) for scripts\n- Setting up automated testing in CI/CD pipelines\n- Testing edge cases and error conditions\n- Validating behavior across different shell environments\n- Building maintainable test suites for scripts\n- Creating fixtures for complex test scenarios\n- Testing multiple shell dialects (bash, sh, dash)\n\n## Bats Fundamentals\n\n### What is Bats?\n\nBats (Bash Automated Testing System) is a TAP (Test Anything Protocol) compliant testing framework for shell scripts that provides:\n- Simple, natural test syntax\n- TAP output format compatible with CI systems\n- Fixtures and setup/teardown support\n- Assertion helpers\n- Parallel test execution\n\n### Installation\n\n```bash\n# macOS with Homebrew\nbrew install bats-core\n\n# Ubuntu/Debian\ngit clone https://github.com/bats-core/bats-core.git\ncd bats-core\n./install.sh /usr/local\n\n# From npm (Node.js)\nnpm install --global bats\n\n# Verify installation\nbats --version\n```\n\n### File Structure\n\n```\nproject/\n\u251c\u2500\u2500 bin/\n\u2502   \u251c\u2500\u2500 script.sh\n\u2502   \u2514\u2500\u2500 helper.sh\n\u251c\u2500\u2500 tests/\n\u2502   \u251c\u2500\u2500 test_script.bats\n\u2502   \u251c\u2500\u2500 test_helper.sh\n\u2502   \u251c\u2500\u2500 fixtures/\n\u2502   \u2502   \u251c\u2500\u2500 input.txt\n\u2502   \u2502   \u2514\u2500\u2500 expected_output.txt\n\u2502   \u2514\u2500\u2500 helpers/\n\u2502       \u2514\u2500\u2500 mocks.bash\n\u2514\u2500\u2500 README.md\n```\n\n## Basic Test Structure\n\n### Simple Test File\n\n```bash\n#!/usr/bin/env bats\n\n# Load test helper if present\nload test_helper\n\n# Setup runs before each test\nsetup() {\n    export TMPDIR=$(mktemp -d)\n}\n\n# Teardown runs after each test\nteardown() {\n    rm -rf \"$TMPDIR\"\n}\n\n# Test: simple assertion\n@test \"Function returns 0 on success\" {\n    run my_function \"input\"\n    [ \"$status\" -eq 0 ]\n}\n\n# Test: output verification\n@test \"Function outputs correct result\" {\n    run my_fu",
  "tier3_resources": "nction \"test\"\n    [ \"$output\" = \"expected output\" ]\n}\n\n# Test: error handling\n@test \"Function returns 1 on missing argument\" {\n    run my_function\n    [ \"$status\" -eq 1 ]\n}\n```\n\n## Assertion Patterns\n\n### Exit Code Assertions\n\n```bash\n#!/usr/bin/env bats\n\n@test \"Command succeeds\" {\n    run true\n    [ \"$status\" -eq 0 ]\n}\n\n@test \"Command fails as expected\" {\n    run false\n    [ \"$status\" -ne 0 ]\n}\n\n@test \"Command returns specific exit code\" {\n    run my_function --invalid\n    [ \"$status\" -eq 127 ]\n}\n\n@test \"Can capture command result\" {\n    run echo \"hello\"\n    [ $status -eq 0 ]\n    [ \"$output\" = \"hello\" ]\n}\n```\n\n### Output Assertions\n\n```bash\n#!/usr/bin/env bats\n\n@test \"Output matches string\" {\n    result=$(echo \"hello world\")\n    [ \"$result\" = \"hello world\" ]\n}\n\n@test \"Output contains substring\" {\n    result=$(echo \"hello world\")\n    [[ \"$result\" == *\"world\"* ]]\n}\n\n@test \"Output matches pattern\" {\n    result=$(date +%Y)\n    [[ \"$result\" =~ ^[0-9]{4}$ ]]\n}\n\n@test \"Multi-line output\" {\n    run printf \"line1\\nline2\\nline3\"\n    [ \"$output\" = \"line1\nline2\nline3\" ]\n}\n\n@test \"Lines variable contains output\" {\n    run printf \"line1\\nline2\\nline3\"\n    [ \"${lines[0]}\" = \"line1\" ]\n    [ \"${lines[1]}\" = \"line2\" ]\n    [ \"${lines[2]}\" = \"line3\" ]\n}\n```\n\n### File Assertions\n\n```bash\n#!/usr/bin/env bats\n\n@test \"File is created\" {\n    [ ! -f \"$TMPDIR/output.txt\" ]\n    my_function > \"$TMPDIR/output.txt\"\n    [ -f \"$TMPDIR/output.txt\" ]\n}\n\n@test \"File contents match expected\" {\n    my_function > \"$TMPDIR/output.txt\"\n    [ \"$(cat \"$TMPDIR/output.txt\")\" = \"expected content\" ]\n}\n\n@test \"File is readable\" {\n    touch \"$TMPDIR/test.txt\"\n    [ -r \"$TMPDIR/test.txt\" ]\n}\n\n@test \"File has correct permissions\" {\n    touch \"$TMPDIR/test.txt\"\n    chmod 644 \"$TMPDIR/test.txt\"\n    [ \"$(stat -f %OLp \"$TMPDIR/test.txt\")\" = \"644\" ]\n}\n\n@test \"File size is correct\" {\n    echo -n \"12345\" > \"$TMPDIR/test.txt\"\n    [ \"$(wc -c < \"$TMPDIR/test.txt\")\" -eq 5 ]\n}\n```\n\n## Setup and Teardown Patterns\n\n### Basic Setup and Teardown\n\n```bash\n#!/usr/bin/env bats\n\nsetup() {\n    # Create test directory\n    TEST_DIR=$(mktemp -d)\n    export TEST_DIR\n\n    # Source script under test\n    source \"${BATS_TEST_DIRNAME}/../bin/script.sh\"\n}\n\nteardown() {\n    # Clean up temporary directory\n    rm -rf \"$TEST_DIR\"\n}\n\n@test \"Test using TEST_DIR\" {\n    touch \"$TEST_DIR/file.txt\"\n    [ -f \"$TEST_DIR/file.txt\" ]\n}\n```\n\n### Setup with Resources\n\n```bash\n#!/usr/bin/env bats\n\nsetup() {\n    # Create directory structure\n    mkdir -p \"$TMPDIR/data/input\"\n    mkdir -p \"$TMPDIR/data/output\"\n\n    # Create test fixtures\n    echo \"line1\" > \"$TMPDIR/data/input/file1.txt\"\n    echo \"line2\" > \"$TMPDIR/data/input/file2.txt\"\n\n    # Initialize environment\n    export DATA_DIR=\"$TMPDIR/data\"\n    export INPUT_DIR=\"$DATA_DIR/input\"\n    export OUTPUT_DIR=\"$DATA_DIR/output\"\n}\n\nteardown() {\n    rm -rf \"$TMPDIR/data\"\n}\n\n@test \"Processes input files\" {\n    run my_process_script \"$INPUT_DIR\" \"$OUTPUT_DIR\"\n    [ \"$status\" -eq 0 ]\n    [ -f \"$OUTPU",
  "tokenEstimate": {
    "tier1": 19.5,
    "tier2": 383.5,
    "tier3": 1717.3
  },
  "fullDefinition": "---\nname: bats-testing-patterns\ndescription: Master Bash Automated Testing System (Bats) for comprehensive shell script testing. Use when writing tests for shell scripts, CI/CD pipelines, or requiring test-driven development of shell utilities.\n---\n\n# Bats Testing Patterns\n\nComprehensive guidance for writing comprehensive unit tests for shell scripts using Bats (Bash Automated Testing System), including test patterns, fixtures, and best practices for production-grade shell testing.\n\n## When to Use This Skill\n\n- Writing unit tests for shell scripts\n- Implementing test-driven development (TDD) for scripts\n- Setting up automated testing in CI/CD pipelines\n- Testing edge cases and error conditions\n- Validating behavior across different shell environments\n- Building maintainable test suites for scripts\n- Creating fixtures for complex test scenarios\n- Testing multiple shell dialects (bash, sh, dash)\n\n## Bats Fundamentals\n\n### What is Bats?\n\nBats (Bash Automated Testing System) is a TAP (Test Anything Protocol) compliant testing framework for shell scripts that provides:\n- Simple, natural test syntax\n- TAP output format compatible with CI systems\n- Fixtures and setup/teardown support\n- Assertion helpers\n- Parallel test execution\n\n### Installation\n\n```bash\n# macOS with Homebrew\nbrew install bats-core\n\n# Ubuntu/Debian\ngit clone https://github.com/bats-core/bats-core.git\ncd bats-core\n./install.sh /usr/local\n\n# From npm (Node.js)\nnpm install --global bats\n\n# Verify installation\nbats --version\n```\n\n### File Structure\n\n```\nproject/\n\u251c\u2500\u2500 bin/\n\u2502   \u251c\u2500\u2500 script.sh\n\u2502   \u2514\u2500\u2500 helper.sh\n\u251c\u2500\u2500 tests/\n\u2502   \u251c\u2500\u2500 test_script.bats\n\u2502   \u251c\u2500\u2500 test_helper.sh\n\u2502   \u251c\u2500\u2500 fixtures/\n\u2502   \u2502   \u251c\u2500\u2500 input.txt\n\u2502   \u2502   \u2514\u2500\u2500 expected_output.txt\n\u2502   \u2514\u2500\u2500 helpers/\n\u2502       \u2514\u2500\u2500 mocks.bash\n\u2514\u2500\u2500 README.md\n```\n\n## Basic Test Structure\n\n### Simple Test File\n\n```bash\n#!/usr/bin/env bats\n\n# Load test helper if present\nload test_helper\n\n# Setup runs before each test\nsetup() {\n    export TMPDIR=$(mktemp -d)\n}\n\n# Teardown runs after each test\nteardown() {\n    rm -rf \"$TMPDIR\"\n}\n\n# Test: simple assertion\n@test \"Function returns 0 on success\" {\n    run my_function \"input\"\n    [ \"$status\" -eq 0 ]\n}\n\n# Test: output verification\n@test \"Function outputs correct result\" {\n    run my_function \"test\"\n    [ \"$output\" = \"expected output\" ]\n}\n\n# Test: error handling\n@test \"Function returns 1 on missing argument\" {\n    run my_function\n    [ \"$status\" -eq 1 ]\n}\n```\n\n## Assertion Patterns\n\n### Exit Code Assertions\n\n```bash\n#!/usr/bin/env bats\n\n@test \"Command succeeds\" {\n    run true\n    [ \"$status\" -eq 0 ]\n}\n\n@test \"Command fails as expected\" {\n    run false\n    [ \"$status\" -ne 0 ]\n}\n\n@test \"Command returns specific exit code\" {\n    run my_function --invalid\n    [ \"$status\" -eq 127 ]\n}\n\n@test \"Can capture command result\" {\n    run echo \"hello\"\n    [ $status -eq 0 ]\n    [ \"$output\" = \"hello\" ]\n}\n```\n\n### Output Assertions\n\n```bash\n#!/usr/bin/env bats\n\n@test \"Output matches string\" {\n    result=$(echo \"hello world\")\n    [ \"$result\" = \"hello world\" ]\n}\n\n@test \"Output contains substring\" {\n    result=$(echo \"hello world\")\n    [[ \"$result\" == *\"world\"* ]]\n}\n\n@test \"Output matches pattern\" {\n    result=$(date +%Y)\n    [[ \"$result\" =~ ^[0-9]{4}$ ]]\n}\n\n@test \"Multi-line output\" {\n    run printf \"line1\\nline2\\nline3\"\n    [ \"$output\" = \"line1\nline2\nline3\" ]\n}\n\n@test \"Lines variable contains output\" {\n    run printf \"line1\\nline2\\nline3\"\n    [ \"${lines[0]}\" = \"line1\" ]\n    [ \"${lines[1]}\" = \"line2\" ]\n    [ \"${lines[2]}\" = \"line3\" ]\n}\n```\n\n### File Assertions\n\n```bash\n#!/usr/bin/env bats\n\n@test \"File is created\" {\n    [ ! -f \"$TMPDIR/output.txt\" ]\n    my_function > \"$TMPDIR/output.txt\"\n    [ -f \"$TMPDIR/output.txt\" ]\n}\n\n@test \"File contents match expected\" {\n    my_function > \"$TMPDIR/output.txt\"\n    [ \"$(cat \"$TMPDIR/output.txt\")\" = \"expected content\" ]\n}\n\n@test \"File is readable\" {\n    touch \"$TMPDIR/test.txt\"\n    [ -r \"$TMPDIR/test.txt\" ]\n}\n\n@test \"File has correct permissions\" {\n    touch \"$TMPDIR/test.txt\"\n    chmod 644 \"$TMPDIR/test.txt\"\n    [ \"$(stat -f %OLp \"$TMPDIR/test.txt\")\" = \"644\" ]\n}\n\n@test \"File size is correct\" {\n    echo -n \"12345\" > \"$TMPDIR/test.txt\"\n    [ \"$(wc -c < \"$TMPDIR/test.txt\")\" -eq 5 ]\n}\n```\n\n## Setup and Teardown Patterns\n\n### Basic Setup and Teardown\n\n```bash\n#!/usr/bin/env bats\n\nsetup() {\n    # Create test directory\n    TEST_DIR=$(mktemp -d)\n    export TEST_DIR\n\n    # Source script under test\n    source \"${BATS_TEST_DIRNAME}/../bin/script.sh\"\n}\n\nteardown() {\n    # Clean up temporary directory\n    rm -rf \"$TEST_DIR\"\n}\n\n@test \"Test using TEST_DIR\" {\n    touch \"$TEST_DIR/file.txt\"\n    [ -f \"$TEST_DIR/file.txt\" ]\n}\n```\n\n### Setup with Resources\n\n```bash\n#!/usr/bin/env bats\n\nsetup() {\n    # Create directory structure\n    mkdir -p \"$TMPDIR/data/input\"\n    mkdir -p \"$TMPDIR/data/output\"\n\n    # Create test fixtures\n    echo \"line1\" > \"$TMPDIR/data/input/file1.txt\"\n    echo \"line2\" > \"$TMPDIR/data/input/file2.txt\"\n\n    # Initialize environment\n    export DATA_DIR=\"$TMPDIR/data\"\n    export INPUT_DIR=\"$DATA_DIR/input\"\n    export OUTPUT_DIR=\"$DATA_DIR/output\"\n}\n\nteardown() {\n    rm -rf \"$TMPDIR/data\"\n}\n\n@test \"Processes input files\" {\n    run my_process_script \"$INPUT_DIR\" \"$OUTPUT_DIR\"\n    [ \"$status\" -eq 0 ]\n    [ -f \"$OUTPUT_DIR/file1.txt\" ]\n}\n```\n\n### Global Setup/Teardown\n\n```bash\n#!/usr/bin/env bats\n\n# Load shared setup from test_helper.sh\nload test_helper\n\n# setup_file runs once before all tests\nsetup_file() {\n    export SHARED_RESOURCE=$(mktemp -d)\n    echo \"Expensive setup\" > \"$SHARED_RESOURCE/data.txt\"\n}\n\n# teardown_file runs once after all tests\nteardown_file() {\n    rm -rf \"$SHARED_RESOURCE\"\n}\n\n@test \"First test uses shared resource\" {\n    [ -f \"$SHARED_RESOURCE/data.txt\" ]\n}\n\n@test \"Second test uses shared resource\" {\n    [ -d \"$SHARED_RESOURCE\" ]\n}\n```\n\n## Mocking and Stubbing Patterns\n\n### Function Mocking\n\n```bash\n#!/usr/bin/env bats\n\n# Mock external command\nmy_external_tool() {\n    echo \"mocked output\"\n    return 0\n}\n\n@test \"Function uses mocked tool\" {\n    export -f my_external_tool\n    run my_function\n    [[ \"$output\" == *\"mocked output\"* ]]\n}\n```\n\n### Command Stubbing\n\n```bash\n#!/usr/bin/env bats\n\nsetup() {\n    # Create stub directory\n    STUBS_DIR=\"$TMPDIR/stubs\"\n    mkdir -p \"$STUBS_DIR\"\n\n    # Add to PATH\n    export PATH=\"$STUBS_DIR:$PATH\"\n}\n\ncreate_stub() {\n    local cmd=\"$1\"\n    local output=\"$2\"\n    local code=\"${3:-0}\"\n\n    cat > \"$STUBS_DIR/$cmd\" <<EOF\n#!/bin/bash\necho \"$output\"\nexit $code\nEOF\n    chmod +x \"$STUBS_DIR/$cmd\"\n}\n\n@test \"Function works with stubbed curl\" {\n    create_stub curl \"{ \\\"status\\\": \\\"ok\\\" }\" 0\n    run my_api_function\n    [ \"$status\" -eq 0 ]\n}\n```\n\n### Variable Stubbing\n\n```bash\n#!/usr/bin/env bats\n\n@test \"Function handles environment override\" {\n    export MY_SETTING=\"override_value\"\n    run my_function\n    [ \"$status\" -eq 0 ]\n    [[ \"$output\" == *\"override_value\"* ]]\n}\n\n@test \"Function uses default when var unset\" {\n    unset MY_SETTING\n    run my_function\n    [ \"$status\" -eq 0 ]\n    [[ \"$output\" == *\"default\"* ]]\n}\n```\n\n## Fixture Management\n\n### Using Fixture Files\n\n```bash\n#!/usr/bin/env bats\n\n# Fixture directory: tests/fixtures/\n\nsetup() {\n    FIXTURES_DIR=\"${BATS_TEST_DIRNAME}/fixtures\"\n    WORK_DIR=$(mktemp -d)\n    export WORK_DIR\n}\n\nteardown() {\n    rm -rf \"$WORK_DIR\"\n}\n\n@test \"Process fixture file\" {\n    # Copy fixture to work directory\n    cp \"$FIXTURES_DIR/input.txt\" \"$WORK_DIR/input.txt\"\n\n    # Run function\n    run my_process_function \"$WORK_DIR/input.txt\"\n\n    # Compare output\n    diff \"$WORK_DIR/output.txt\" \"$FIXTURES_DIR/expected_output.txt\"\n}\n```\n\n### Dynamic Fixture Generation\n\n```bash\n#!/usr/bin/env bats\n\ngenerate_fixture() {\n    local lines=\"$1\"\n    local file=\"$2\"\n\n    for i in $(seq 1 \"$lines\"); do\n        echo \"Line $i content\" >> \"$file\"\n    done\n}\n\n@test \"Handle large input file\" {\n    generate_fixture 1000 \"$TMPDIR/large.txt\"\n    run my_function \"$TMPDIR/large.txt\"\n    [ \"$status\" -eq 0 ]\n    [ \"$(wc -l < \"$TMPDIR/large.txt\")\" -eq 1000 ]\n}\n```\n\n## Advanced Patterns\n\n### Testing Error Conditions\n\n```bash\n#!/usr/bin/env bats\n\n@test \"Function fails with missing file\" {\n    run my_function \"/nonexistent/file.txt\"\n    [ \"$status\" -ne 0 ]\n    [[ \"$output\" == *\"not found\"* ]]\n}\n\n@test \"Function fails with invalid input\" {\n    run my_function \"\"\n    [ \"$status\" -ne 0 ]\n}\n\n@test \"Function fails with permission denied\" {\n    touch \"$TMPDIR/readonly.txt\"\n    chmod 000 \"$TMPDIR/readonly.txt\"\n    run my_function \"$TMPDIR/readonly.txt\"\n    [ \"$status\" -ne 0 ]\n    chmod 644 \"$TMPDIR/readonly.txt\"  # Cleanup\n}\n\n@test \"Function provides helpful error message\" {\n    run my_function --invalid-option\n    [ \"$status\" -ne 0 ]\n    [[ \"$output\" == *\"Usage:\"* ]]\n}\n```\n\n### Testing with Dependencies\n\n```bash\n#!/usr/bin/env bats\n\nsetup() {\n    # Check for required tools\n    if ! command -v jq &>/dev/null; then\n        skip \"jq is not installed\"\n    fi\n\n    export SCRIPT=\"${BATS_TEST_DIRNAME}/../bin/script.sh\"\n}\n\n@test \"JSON parsing works\" {\n    skip_if ! command -v jq &>/dev/null\n    run my_json_parser '{\"key\": \"value\"}'\n    [ \"$status\" -eq 0 ]\n}\n```\n\n### Testing Shell Compatibility\n\n```bash\n#!/usr/bin/env bats\n\n@test \"Script works in bash\" {\n    bash \"${BATS_TEST_DIRNAME}/../bin/script.sh\" arg1\n}\n\n@test \"Script works in sh (POSIX)\" {\n    sh \"${BATS_TEST_DIRNAME}/../bin/script.sh\" arg1\n}\n\n@test \"Script works in dash\" {\n    if command -v dash &>/dev/null; then\n        dash \"${BATS_TEST_DIRNAME}/../bin/script.sh\" arg1\n    else\n        skip \"dash not installed\"\n    fi\n}\n```\n\n### Parallel Execution\n\n```bash\n#!/usr/bin/env bats\n\n@test \"Multiple independent operations\" {\n    run bash -c 'for i in {1..10}; do\n        my_operation \"$i\" &\n    done\n    wait'\n    [ \"$status\" -eq 0 ]\n}\n\n@test \"Concurrent file operations\" {\n    for i in {1..5}; do\n        my_function \"$TMPDIR/file$i\" &\n    done\n    wait\n    [ -f \"$TMPDIR/file1\" ]\n    [ -f \"$TMPDIR/file5\" ]\n}\n```\n\n## Test Helper Pattern\n\n### test_helper.sh\n\n```bash\n#!/usr/bin/env bash\n\n# Source script under test\nexport SCRIPT_DIR=\"${BATS_TEST_DIRNAME%/*}/bin\"\n\n# Common test utilities\nassert_file_exists() {\n    if [ ! -f \"$1\" ]; then\n        echo \"Expected file to exist: $1\"\n        return 1\n    fi\n}\n\nassert_file_equals() {\n    local file=\"$1\"\n    local expected=\"$2\"\n\n    if [ ! -f \"$file\" ]; then\n        echo \"File does not exist: $file\"\n        return 1\n    fi\n\n    local actual=$(cat \"$file\")\n    if [ \"$actual\" != \"$expected\" ]; then\n        echo \"File contents do not match\"\n        echo \"Expected: $expected\"\n        echo \"Actual: $actual\"\n        return 1\n    fi\n}\n\n# Create temporary test directory\nsetup_test_dir() {\n    export TEST_DIR=$(mktemp -d)\n}\n\ncleanup_test_dir() {\n    rm -rf \"$TEST_DIR\"\n}\n```\n\n## Integration with CI/CD\n\n### GitHub Actions Workflow\n\n```yaml\nname: Tests\n\non: [push, pull_request]\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n\n    steps:\n      - uses: actions/checkout@v3\n\n      - name: Install Bats\n        run: |\n          npm install --global bats\n\n      - name: Run Tests\n        run: |\n          bats tests/*.bats\n\n      - name: Run Tests with Tap Reporter\n        run: |\n          bats tests/*.bats --tap | tee test_output.tap\n```\n\n### Makefile Integration\n\n```makefile\n.PHONY: test test-verbose test-tap\n\ntest:\n\tbats tests/*.bats\n\ntest-verbose:\n\tbats tests/*.bats --verbose\n\ntest-tap:\n\tbats tests/*.bats --tap\n\ntest-parallel:\n\tbats tests/*.bats --parallel 4\n\ncoverage: test\n\t# Optional: Generate coverage reports\n```\n\n## Best Practices\n\n1. **Test one thing per test** - Single responsibility principle\n2. **Use descriptive test names** - Clearly states what is being tested\n3. **Clean up after tests** - Always remove temporary files in teardown\n4. **Test both success and failure paths** - Don't just test happy path\n5. **Mock external dependencies** - Isolate unit under test\n6. **Use fixtures for complex data** - Makes tests more readable\n7. **Run tests in CI/CD** - Catch regressions early\n8. **Test across shell dialects** - Ensure portability\n9. **Keep tests fast** - Run in parallel when possible\n10. **Document complex test setup** - Explain unusual patterns\n\n## Resources\n\n- **Bats GitHub**: https://github.com/bats-core/bats-core\n- **Bats Documentation**: https://bats-core.readthedocs.io/\n- **TAP Protocol**: https://testanything.org/\n- **Test-Driven Development**: https://en.wikipedia.org/wiki/Test-driven_development\n"
}