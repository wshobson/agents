{
  "id": "shell_scripting_bash_defensive_patterns",
  "name": "bash-defensive-patterns",
  "source": "shell-scripting",
  "originalPath": "plugins/shell-scripting/skills/bash-defensive-patterns/SKILL.md",
  "activationCriteria": "Master defensive Bash programming techniques for production-grade scripts. Use when writing robust shell scripts, CI/CD pipelines, or system utilities requiring fault tolerance and safety.",
  "tier1_metadata": "bash-defensive-patterns: Master defensive Bash programming techniques for production-grade scripts. Use when writing robust s",
  "tier2_instructions": "# Bash Defensive Patterns\n\nComprehensive guidance for writing production-ready Bash scripts using defensive programming techniques, error handling, and safety best practices to prevent common pitfalls and ensure reliability.\n\n## When to Use This Skill\n\n- Writing production automation scripts\n- Building CI/CD pipeline scripts\n- Creating system administration utilities\n- Developing error-resilient deployment automation\n- Writing scripts that must handle edge cases safely\n- Building maintainable shell script libraries\n- Implementing comprehensive logging and monitoring\n- Creating scripts that must work across different platforms\n\n## Core Defensive Principles\n\n### 1. Strict Mode\nEnable bash strict mode at the start of every script to catch errors early.\n\n```bash\n#!/bin/bash\nset -Eeuo pipefail  # Exit on error, unset variables, pipe failures\n```\n\n**Key flags:**\n- `set -E`: Inherit ERR trap in functions\n- `set -e`: Exit on any error (command returns non-zero)\n- `set -u`: Exit on undefined variable reference\n- `set -o pipefail`: Pipe fails if any command fails (not just last)\n\n### 2. Error Trapping and Cleanup\nImplement proper cleanup on script exit or error.\n\n```bash\n#!/bin/bash\nset -Eeuo pipefail\n\ntrap 'echo \"Error on line $LINENO\"' ERR\ntrap 'echo \"Cleaning up...\"; rm -rf \"$TMPDIR\"' EXIT\n\nTMPDIR=$(mktemp -d)\n# Script code here\n```\n\n### 3. Variable Safety\nAlways quote variables to prevent word splitting and globbing issues.\n\n```bash\n# Wrong - unsafe\ncp $source $dest\n\n# Correct - safe\ncp \"$source\" \"$dest\"\n\n# Required variables - fail with message if unset\n: \"${REQUIRED_VAR:?REQUIRED_VAR is not set}\"\n```\n\n### 4. Array Handling\nUse arrays safely for complex data handling.\n\n```bash\n# Safe array iteration\ndeclare -a items=(\"item 1\" \"item 2\" \"item 3\")\n\nfor item in \"${items[@]}\"; do\n    echo \"Processing: $item\"\ndone\n\n# Reading output into array safely\nmapfile -t lines < <(some_command)\nreadarray -t numbers < <(seq 1 10)\n```\n\n### 5. Conditional Safety\nUse `[[ ]]` for Bash-specifi",
  "tier3_resources": "c features, `[ ]` for POSIX.\n\n```bash\n# Bash - safer\nif [[ -f \"$file\" && -r \"$file\" ]]; then\n    content=$(<\"$file\")\nfi\n\n# POSIX - portable\nif [ -f \"$file\" ] && [ -r \"$file\" ]; then\n    content=$(cat \"$file\")\nfi\n\n# Test for existence before operations\nif [[ -z \"${VAR:-}\" ]]; then\n    echo \"VAR is not set or is empty\"\nfi\n```\n\n## Fundamental Patterns\n\n### Pattern 1: Safe Script Directory Detection\n\n```bash\n#!/bin/bash\nset -Eeuo pipefail\n\n# Correctly determine script directory\nSCRIPT_DIR=\"$(cd -- \"$(dirname -- \"${BASH_SOURCE[0]}\")\" && pwd -P)\"\nSCRIPT_NAME=\"$(basename -- \"${BASH_SOURCE[0]}\")\"\n\necho \"Script location: $SCRIPT_DIR/$SCRIPT_NAME\"\n```\n\n### Pattern 2: Comprehensive Function Templat\n\n```bash\n#!/bin/bash\nset -Eeuo pipefail\n\n# Prefix for functions: handle_*, process_*, check_*, validate_*\n# Include documentation and error handling\n\nvalidate_file() {\n    local -r file=\"$1\"\n    local -r message=\"${2:-File not found: $file}\"\n\n    if [[ ! -f \"$file\" ]]; then\n        echo \"ERROR: $message\" >&2\n        return 1\n    fi\n    return 0\n}\n\nprocess_files() {\n    local -r input_dir=\"$1\"\n    local -r output_dir=\"$2\"\n\n    # Validate inputs\n    [[ -d \"$input_dir\" ]] || { echo \"ERROR: input_dir not a directory\" >&2; return 1; }\n\n    # Create output directory if needed\n    mkdir -p \"$output_dir\" || { echo \"ERROR: Cannot create output_dir\" >&2; return 1; }\n\n    # Process files safely\n    while IFS= read -r -d '' file; do\n        echo \"Processing: $file\"\n        # Do work\n    done < <(find \"$input_dir\" -maxdepth 1 -type f -print0)\n\n    return 0\n}\n```\n\n### Pattern 3: Safe Temporary File Handling\n\n```bash\n#!/bin/bash\nset -Eeuo pipefail\n\ntrap 'rm -rf -- \"$TMPDIR\"' EXIT\n\n# Create temporary directory\nTMPDIR=$(mktemp -d) || { echo \"ERROR: Failed to create temp directory\" >&2; exit 1; }\n\n# Create temporary files in directory\nTMPFILE1=\"$TMPDIR/temp1.txt\"\nTMPFILE2=\"$TMPDIR/temp2.txt\"\n\n# Use temporary files\ntouch \"$TMPFILE1\" \"$TMPFILE2\"\n\necho \"Temp files created in: $TMPDIR\"\n```\n\n### Pattern 4: Robust Argument Parsing\n\n```bash\n#!/bin/bash\nset -Eeuo pipefail\n\n# Default values\nVERBOSE=false\nDRY_RUN=false\nOUTPUT_FILE=\"\"\nTHREADS=4\n\nusage() {\n    cat <<EOF\nUsage: $0 [OPTIONS]\n\nOptions:\n    -v, --verbose       Enable verbose output\n    -d, --dry-run       Run without making changes\n    -o, --output FILE   Output file path\n    -j, --jobs NUM      Number of parallel jobs\n    -h, --help          Show this help message\nEOF\n    exit \"${1:-0}\"\n}\n\n# Parse arguments\nwhile [[ $# -gt 0 ]]; do\n    case \"$1\" in\n        -v|--verbose)\n            VERBOSE=true\n            shift\n            ;;\n        -d|--dry-run)\n            DRY_RUN=true\n            shift\n            ;;\n        -o|--output)\n            OUTPUT_FILE=\"$2\"\n            shift 2\n            ;;\n        -j|--jobs)\n            THREADS=\"$2\"\n            shift 2\n            ;;\n        -h|--help)\n            usage 0\n            ;;\n        --)\n            shift\n            break\n            ;;\n        *)\n            echo \"ERROR: Unknown opti",
  "tokenEstimate": {
    "tier1": 18.2,
    "tier2": 399.1,
    "tier3": 1634.1000000000001
  },
  "fullDefinition": "---\nname: bash-defensive-patterns\ndescription: Master defensive Bash programming techniques for production-grade scripts. Use when writing robust shell scripts, CI/CD pipelines, or system utilities requiring fault tolerance and safety.\n---\n\n# Bash Defensive Patterns\n\nComprehensive guidance for writing production-ready Bash scripts using defensive programming techniques, error handling, and safety best practices to prevent common pitfalls and ensure reliability.\n\n## When to Use This Skill\n\n- Writing production automation scripts\n- Building CI/CD pipeline scripts\n- Creating system administration utilities\n- Developing error-resilient deployment automation\n- Writing scripts that must handle edge cases safely\n- Building maintainable shell script libraries\n- Implementing comprehensive logging and monitoring\n- Creating scripts that must work across different platforms\n\n## Core Defensive Principles\n\n### 1. Strict Mode\nEnable bash strict mode at the start of every script to catch errors early.\n\n```bash\n#!/bin/bash\nset -Eeuo pipefail  # Exit on error, unset variables, pipe failures\n```\n\n**Key flags:**\n- `set -E`: Inherit ERR trap in functions\n- `set -e`: Exit on any error (command returns non-zero)\n- `set -u`: Exit on undefined variable reference\n- `set -o pipefail`: Pipe fails if any command fails (not just last)\n\n### 2. Error Trapping and Cleanup\nImplement proper cleanup on script exit or error.\n\n```bash\n#!/bin/bash\nset -Eeuo pipefail\n\ntrap 'echo \"Error on line $LINENO\"' ERR\ntrap 'echo \"Cleaning up...\"; rm -rf \"$TMPDIR\"' EXIT\n\nTMPDIR=$(mktemp -d)\n# Script code here\n```\n\n### 3. Variable Safety\nAlways quote variables to prevent word splitting and globbing issues.\n\n```bash\n# Wrong - unsafe\ncp $source $dest\n\n# Correct - safe\ncp \"$source\" \"$dest\"\n\n# Required variables - fail with message if unset\n: \"${REQUIRED_VAR:?REQUIRED_VAR is not set}\"\n```\n\n### 4. Array Handling\nUse arrays safely for complex data handling.\n\n```bash\n# Safe array iteration\ndeclare -a items=(\"item 1\" \"item 2\" \"item 3\")\n\nfor item in \"${items[@]}\"; do\n    echo \"Processing: $item\"\ndone\n\n# Reading output into array safely\nmapfile -t lines < <(some_command)\nreadarray -t numbers < <(seq 1 10)\n```\n\n### 5. Conditional Safety\nUse `[[ ]]` for Bash-specific features, `[ ]` for POSIX.\n\n```bash\n# Bash - safer\nif [[ -f \"$file\" && -r \"$file\" ]]; then\n    content=$(<\"$file\")\nfi\n\n# POSIX - portable\nif [ -f \"$file\" ] && [ -r \"$file\" ]; then\n    content=$(cat \"$file\")\nfi\n\n# Test for existence before operations\nif [[ -z \"${VAR:-}\" ]]; then\n    echo \"VAR is not set or is empty\"\nfi\n```\n\n## Fundamental Patterns\n\n### Pattern 1: Safe Script Directory Detection\n\n```bash\n#!/bin/bash\nset -Eeuo pipefail\n\n# Correctly determine script directory\nSCRIPT_DIR=\"$(cd -- \"$(dirname -- \"${BASH_SOURCE[0]}\")\" && pwd -P)\"\nSCRIPT_NAME=\"$(basename -- \"${BASH_SOURCE[0]}\")\"\n\necho \"Script location: $SCRIPT_DIR/$SCRIPT_NAME\"\n```\n\n### Pattern 2: Comprehensive Function Templat\n\n```bash\n#!/bin/bash\nset -Eeuo pipefail\n\n# Prefix for functions: handle_*, process_*, check_*, validate_*\n# Include documentation and error handling\n\nvalidate_file() {\n    local -r file=\"$1\"\n    local -r message=\"${2:-File not found: $file}\"\n\n    if [[ ! -f \"$file\" ]]; then\n        echo \"ERROR: $message\" >&2\n        return 1\n    fi\n    return 0\n}\n\nprocess_files() {\n    local -r input_dir=\"$1\"\n    local -r output_dir=\"$2\"\n\n    # Validate inputs\n    [[ -d \"$input_dir\" ]] || { echo \"ERROR: input_dir not a directory\" >&2; return 1; }\n\n    # Create output directory if needed\n    mkdir -p \"$output_dir\" || { echo \"ERROR: Cannot create output_dir\" >&2; return 1; }\n\n    # Process files safely\n    while IFS= read -r -d '' file; do\n        echo \"Processing: $file\"\n        # Do work\n    done < <(find \"$input_dir\" -maxdepth 1 -type f -print0)\n\n    return 0\n}\n```\n\n### Pattern 3: Safe Temporary File Handling\n\n```bash\n#!/bin/bash\nset -Eeuo pipefail\n\ntrap 'rm -rf -- \"$TMPDIR\"' EXIT\n\n# Create temporary directory\nTMPDIR=$(mktemp -d) || { echo \"ERROR: Failed to create temp directory\" >&2; exit 1; }\n\n# Create temporary files in directory\nTMPFILE1=\"$TMPDIR/temp1.txt\"\nTMPFILE2=\"$TMPDIR/temp2.txt\"\n\n# Use temporary files\ntouch \"$TMPFILE1\" \"$TMPFILE2\"\n\necho \"Temp files created in: $TMPDIR\"\n```\n\n### Pattern 4: Robust Argument Parsing\n\n```bash\n#!/bin/bash\nset -Eeuo pipefail\n\n# Default values\nVERBOSE=false\nDRY_RUN=false\nOUTPUT_FILE=\"\"\nTHREADS=4\n\nusage() {\n    cat <<EOF\nUsage: $0 [OPTIONS]\n\nOptions:\n    -v, --verbose       Enable verbose output\n    -d, --dry-run       Run without making changes\n    -o, --output FILE   Output file path\n    -j, --jobs NUM      Number of parallel jobs\n    -h, --help          Show this help message\nEOF\n    exit \"${1:-0}\"\n}\n\n# Parse arguments\nwhile [[ $# -gt 0 ]]; do\n    case \"$1\" in\n        -v|--verbose)\n            VERBOSE=true\n            shift\n            ;;\n        -d|--dry-run)\n            DRY_RUN=true\n            shift\n            ;;\n        -o|--output)\n            OUTPUT_FILE=\"$2\"\n            shift 2\n            ;;\n        -j|--jobs)\n            THREADS=\"$2\"\n            shift 2\n            ;;\n        -h|--help)\n            usage 0\n            ;;\n        --)\n            shift\n            break\n            ;;\n        *)\n            echo \"ERROR: Unknown option: $1\" >&2\n            usage 1\n            ;;\n    esac\ndone\n\n# Validate required arguments\n[[ -n \"$OUTPUT_FILE\" ]] || { echo \"ERROR: -o/--output is required\" >&2; usage 1; }\n```\n\n### Pattern 5: Structured Logging\n\n```bash\n#!/bin/bash\nset -Eeuo pipefail\n\n# Logging functions\nlog_info() {\n    echo \"[$(date +'%Y-%m-%d %H:%M:%S')] INFO: $*\" >&2\n}\n\nlog_warn() {\n    echo \"[$(date +'%Y-%m-%d %H:%M:%S')] WARN: $*\" >&2\n}\n\nlog_error() {\n    echo \"[$(date +'%Y-%m-%d %H:%M:%S')] ERROR: $*\" >&2\n}\n\nlog_debug() {\n    if [[ \"${DEBUG:-0}\" == \"1\" ]]; then\n        echo \"[$(date +'%Y-%m-%d %H:%M:%S')] DEBUG: $*\" >&2\n    fi\n}\n\n# Usage\nlog_info \"Starting script\"\nlog_debug \"Debug information\"\nlog_warn \"Warning message\"\nlog_error \"Error occurred\"\n```\n\n### Pattern 6: Process Orchestration with Signals\n\n```bash\n#!/bin/bash\nset -Eeuo pipefail\n\n# Track background processes\nPIDS=()\n\ncleanup() {\n    log_info \"Shutting down...\"\n\n    # Terminate all background processes\n    for pid in \"${PIDS[@]}\"; do\n        if kill -0 \"$pid\" 2>/dev/null; then\n            kill -TERM \"$pid\" 2>/dev/null || true\n        fi\n    done\n\n    # Wait for graceful shutdown\n    for pid in \"${PIDS[@]}\"; do\n        wait \"$pid\" 2>/dev/null || true\n    done\n}\n\ntrap cleanup SIGTERM SIGINT\n\n# Start background tasks\nbackground_task &\nPIDS+=($!)\n\nanother_task &\nPIDS+=($!)\n\n# Wait for all background processes\nwait\n```\n\n### Pattern 7: Safe File Operations\n\n```bash\n#!/bin/bash\nset -Eeuo pipefail\n\n# Use -i flag to move safely without overwriting\nsafe_move() {\n    local -r source=\"$1\"\n    local -r dest=\"$2\"\n\n    if [[ ! -e \"$source\" ]]; then\n        echo \"ERROR: Source does not exist: $source\" >&2\n        return 1\n    fi\n\n    if [[ -e \"$dest\" ]]; then\n        echo \"ERROR: Destination already exists: $dest\" >&2\n        return 1\n    fi\n\n    mv \"$source\" \"$dest\"\n}\n\n# Safe directory cleanup\nsafe_rmdir() {\n    local -r dir=\"$1\"\n\n    if [[ ! -d \"$dir\" ]]; then\n        echo \"ERROR: Not a directory: $dir\" >&2\n        return 1\n    fi\n\n    # Use -I flag to prompt before rm (BSD/GNU compatible)\n    rm -rI -- \"$dir\"\n}\n\n# Atomic file writes\natomic_write() {\n    local -r target=\"$1\"\n    local -r tmpfile\n    tmpfile=$(mktemp) || return 1\n\n    # Write to temp file first\n    cat > \"$tmpfile\"\n\n    # Atomic rename\n    mv \"$tmpfile\" \"$target\"\n}\n```\n\n### Pattern 8: Idempotent Script Design\n\n```bash\n#!/bin/bash\nset -Eeuo pipefail\n\n# Check if resource already exists\nensure_directory() {\n    local -r dir=\"$1\"\n\n    if [[ -d \"$dir\" ]]; then\n        log_info \"Directory already exists: $dir\"\n        return 0\n    fi\n\n    mkdir -p \"$dir\" || {\n        log_error \"Failed to create directory: $dir\"\n        return 1\n    }\n\n    log_info \"Created directory: $dir\"\n}\n\n# Ensure configuration state\nensure_config() {\n    local -r config_file=\"$1\"\n    local -r default_value=\"$2\"\n\n    if [[ ! -f \"$config_file\" ]]; then\n        echo \"$default_value\" > \"$config_file\"\n        log_info \"Created config: $config_file\"\n    fi\n}\n\n# Rerunning script multiple times should be safe\nensure_directory \"/var/cache/myapp\"\nensure_config \"/etc/myapp/config\" \"DEBUG=false\"\n```\n\n### Pattern 9: Safe Command Substitution\n\n```bash\n#!/bin/bash\nset -Eeuo pipefail\n\n# Use $() instead of backticks\nname=$(<\"$file\")  # Modern, safe variable assignment from file\noutput=$(command -v python3)  # Get command location safely\n\n# Handle command substitution with error checking\nresult=$(command -v node) || {\n    log_error \"node command not found\"\n    return 1\n}\n\n# For multiple lines\nmapfile -t lines < <(grep \"pattern\" \"$file\")\n\n# NUL-safe iteration\nwhile IFS= read -r -d '' file; do\n    echo \"Processing: $file\"\ndone < <(find /path -type f -print0)\n```\n\n### Pattern 10: Dry-Run Support\n\n```bash\n#!/bin/bash\nset -Eeuo pipefail\n\nDRY_RUN=\"${DRY_RUN:-false}\"\n\nrun_cmd() {\n    if [[ \"$DRY_RUN\" == \"true\" ]]; then\n        echo \"[DRY RUN] Would execute: $*\"\n        return 0\n    fi\n\n    \"$@\"\n}\n\n# Usage\nrun_cmd cp \"$source\" \"$dest\"\nrun_cmd rm \"$file\"\nrun_cmd chown \"$owner\" \"$target\"\n```\n\n## Advanced Defensive Techniques\n\n### Named Parameters Pattern\n\n```bash\n#!/bin/bash\nset -Eeuo pipefail\n\nprocess_data() {\n    local input_file=\"\"\n    local output_dir=\"\"\n    local format=\"json\"\n\n    # Parse named parameters\n    while [[ $# -gt 0 ]]; do\n        case \"$1\" in\n            --input=*)\n                input_file=\"${1#*=}\"\n                ;;\n            --output=*)\n                output_dir=\"${1#*=}\"\n                ;;\n            --format=*)\n                format=\"${1#*=}\"\n                ;;\n            *)\n                echo \"ERROR: Unknown parameter: $1\" >&2\n                return 1\n                ;;\n        esac\n        shift\n    done\n\n    # Validate required parameters\n    [[ -n \"$input_file\" ]] || { echo \"ERROR: --input is required\" >&2; return 1; }\n    [[ -n \"$output_dir\" ]] || { echo \"ERROR: --output is required\" >&2; return 1; }\n}\n```\n\n### Dependency Checking\n\n```bash\n#!/bin/bash\nset -Eeuo pipefail\n\ncheck_dependencies() {\n    local -a missing_deps=()\n    local -a required=(\"jq\" \"curl\" \"git\")\n\n    for cmd in \"${required[@]}\"; do\n        if ! command -v \"$cmd\" &>/dev/null; then\n            missing_deps+=(\"$cmd\")\n        fi\n    done\n\n    if [[ ${#missing_deps[@]} -gt 0 ]]; then\n        echo \"ERROR: Missing required commands: ${missing_deps[*]}\" >&2\n        return 1\n    fi\n}\n\ncheck_dependencies\n```\n\n## Best Practices Summary\n\n1. **Always use strict mode** - `set -Eeuo pipefail`\n2. **Quote all variables** - `\"$variable\"` prevents word splitting\n3. **Use [[ ]] conditionals** - More robust than [ ]\n4. **Implement error trapping** - Catch and handle errors gracefully\n5. **Validate all inputs** - Check file existence, permissions, formats\n6. **Use functions for reusability** - Prefix with meaningful names\n7. **Implement structured logging** - Include timestamps and levels\n8. **Support dry-run mode** - Allow users to preview changes\n9. **Handle temporary files safely** - Use mktemp, cleanup with trap\n10. **Design for idempotency** - Scripts should be safe to rerun\n11. **Document requirements** - List dependencies and minimum versions\n12. **Test error paths** - Ensure error handling works correctly\n13. **Use `command -v`** - Safer than `which` for checking executables\n14. **Prefer printf over echo** - More predictable across systems\n\n## Resources\n\n- **Bash Strict Mode**: http://redsymbol.net/articles/unofficial-bash-strict-mode/\n- **Google Shell Style Guide**: https://google.github.io/styleguide/shellguide.html\n- **Defensive BASH Programming**: https://www.lifepipe.net/\n"
}