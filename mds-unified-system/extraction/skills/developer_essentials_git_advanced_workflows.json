{
  "id": "developer_essentials_git_advanced_workflows",
  "name": "git-advanced-workflows",
  "source": "developer-essentials",
  "originalPath": "plugins/developer-essentials/skills/git-advanced-workflows/SKILL.md",
  "activationCriteria": "Master advanced Git workflows including rebasing, cherry-picking, bisect, worktrees, and reflog to maintain clean history and recover from any situation. Use when managing complex Git histories, colla",
  "tier1_metadata": "git-advanced-workflows: Master advanced Git workflows including rebasing, cherry-picking, bisect, worktrees, and reflog to m",
  "tier2_instructions": "# Git Advanced Workflows\n\nMaster advanced Git techniques to maintain clean history, collaborate effectively, and recover from any situation with confidence.\n\n## When to Use This Skill\n\n- Cleaning up commit history before merging\n- Applying specific commits across branches\n- Finding commits that introduced bugs\n- Working on multiple features simultaneously\n- Recovering from Git mistakes or lost commits\n- Managing complex branch workflows\n- Preparing clean PRs for review\n- Synchronizing diverged branches\n\n## Core Concepts\n\n### 1. Interactive Rebase\n\nInteractive rebase is the Swiss Army knife of Git history editing.\n\n**Common Operations:**\n- `pick`: Keep commit as-is\n- `reword`: Change commit message\n- `edit`: Amend commit content\n- `squash`: Combine with previous commit\n- `fixup`: Like squash but discard message\n- `drop`: Remove commit entirely\n\n**Basic Usage:**\n```bash\n# Rebase last 5 commits\ngit rebase -i HEAD~5\n\n# Rebase all commits on current branch\ngit rebase -i $(git merge-base HEAD main)\n\n# Rebase onto specific commit\ngit rebase -i abc123\n```\n\n### 2. Cherry-Picking\n\nApply specific commits from one branch to another without merging entire branches.\n\n```bash\n# Cherry-pick single commit\ngit cherry-pick abc123\n\n# Cherry-pick range of commits (exclusive start)\ngit cherry-pick abc123..def456\n\n# Cherry-pick without committing (stage changes only)\ngit cherry-pick -n abc123\n\n# Cherry-pick and edit commit message\ngit cherry-pick -e abc123\n```\n\n### 3. Git Bisect\n\nBinary search through commit history to find the commit that introduced a bug.\n\n```bash\n# Start bisect\ngit bisect start\n\n# Mark current commit as bad\ngit bisect bad\n\n# Mark known good commit\ngit bisect good v1.0.0\n\n# Git will checkout middle commit - test it\n# Then mark as good or bad\ngit bisect good  # or: git bisect bad\n\n# Continue until bug found\n# When done\ngit bisect reset\n```\n\n**Automated Bisect:**\n```bash\n# Use script to test automatically\ngit bisect start HEAD v1.0.0\ngit bisect run ./test.sh\n\n# test.sh sh",
  "tier3_resources": "ould exit 0 for good, 1-127 (except 125) for bad\n```\n\n### 4. Worktrees\n\nWork on multiple branches simultaneously without stashing or switching.\n\n```bash\n# List existing worktrees\ngit worktree list\n\n# Add new worktree for feature branch\ngit worktree add ../project-feature feature/new-feature\n\n# Add worktree and create new branch\ngit worktree add -b bugfix/urgent ../project-hotfix main\n\n# Remove worktree\ngit worktree remove ../project-feature\n\n# Prune stale worktrees\ngit worktree prune\n```\n\n### 5. Reflog\n\nYour safety net - tracks all ref movements, even deleted commits.\n\n```bash\n# View reflog\ngit reflog\n\n# View reflog for specific branch\ngit reflog show feature/branch\n\n# Restore deleted commit\ngit reflog\n# Find commit hash\ngit checkout abc123\ngit branch recovered-branch\n\n# Restore deleted branch\ngit reflog\ngit branch deleted-branch abc123\n```\n\n## Practical Workflows\n\n### Workflow 1: Clean Up Feature Branch Before PR\n\n```bash\n# Start with feature branch\ngit checkout feature/user-auth\n\n# Interactive rebase to clean history\ngit rebase -i main\n\n# Example rebase operations:\n# - Squash \"fix typo\" commits\n# - Reword commit messages for clarity\n# - Reorder commits logically\n# - Drop unnecessary commits\n\n# Force push cleaned branch (safe if no one else is using it)\ngit push --force-with-lease origin feature/user-auth\n```\n\n### Workflow 2: Apply Hotfix to Multiple Releases\n\n```bash\n# Create fix on main\ngit checkout main\ngit commit -m \"fix: critical security patch\"\n\n# Apply to release branches\ngit checkout release/2.0\ngit cherry-pick abc123\n\ngit checkout release/1.9\ngit cherry-pick abc123\n\n# Handle conflicts if they arise\ngit cherry-pick --continue\n# or\ngit cherry-pick --abort\n```\n\n### Workflow 3: Find Bug Introduction\n\n```bash\n# Start bisect\ngit bisect start\ngit bisect bad HEAD\ngit bisect good v2.1.0\n\n# Git checks out middle commit - run tests\nnpm test\n\n# If tests fail\ngit bisect bad\n\n# If tests pass\ngit bisect good\n\n# Git will automatically checkout next commit to test\n# Repeat until bug found\n\n# Automated version\ngit bisect start HEAD v2.1.0\ngit bisect run npm test\n```\n\n### Workflow 4: Multi-Branch Development\n\n```bash\n# Main project directory\ncd ~/projects/myapp\n\n# Create worktree for urgent bugfix\ngit worktree add ../myapp-hotfix hotfix/critical-bug\n\n# Work on hotfix in separate directory\ncd ../myapp-hotfix\n# Make changes, commit\ngit commit -m \"fix: resolve critical bug\"\ngit push origin hotfix/critical-bug\n\n# Return to main work without interruption\ncd ~/projects/myapp\ngit fetch origin\ngit cherry-pick hotfix/critical-bug\n\n# Clean up when done\ngit worktree remove ../myapp-hotfix\n```\n\n### Workflow 5: Recover from Mistakes\n\n```bash\n# Accidentally reset to wrong commit\ngit reset --hard HEAD~5  # Oh no!\n\n# Use reflog to find lost commits\ngit reflog\n# Output shows:\n# abc123 HEAD@{0}: reset: moving to HEAD~5\n# def456 HEAD@{1}: commit: my important changes\n\n# Recover lost commits\ngit reset --hard def456\n\n# Or create branch from lost commit\ngit branch recovery def",
  "tokenEstimate": {
    "tier1": 18.2,
    "tier2": 413.40000000000003,
    "tier3": 1357.2
  },
  "fullDefinition": "---\nname: git-advanced-workflows\ndescription: Master advanced Git workflows including rebasing, cherry-picking, bisect, worktrees, and reflog to maintain clean history and recover from any situation. Use when managing complex Git histories, collaborating on feature branches, or troubleshooting repository issues.\n---\n\n# Git Advanced Workflows\n\nMaster advanced Git techniques to maintain clean history, collaborate effectively, and recover from any situation with confidence.\n\n## When to Use This Skill\n\n- Cleaning up commit history before merging\n- Applying specific commits across branches\n- Finding commits that introduced bugs\n- Working on multiple features simultaneously\n- Recovering from Git mistakes or lost commits\n- Managing complex branch workflows\n- Preparing clean PRs for review\n- Synchronizing diverged branches\n\n## Core Concepts\n\n### 1. Interactive Rebase\n\nInteractive rebase is the Swiss Army knife of Git history editing.\n\n**Common Operations:**\n- `pick`: Keep commit as-is\n- `reword`: Change commit message\n- `edit`: Amend commit content\n- `squash`: Combine with previous commit\n- `fixup`: Like squash but discard message\n- `drop`: Remove commit entirely\n\n**Basic Usage:**\n```bash\n# Rebase last 5 commits\ngit rebase -i HEAD~5\n\n# Rebase all commits on current branch\ngit rebase -i $(git merge-base HEAD main)\n\n# Rebase onto specific commit\ngit rebase -i abc123\n```\n\n### 2. Cherry-Picking\n\nApply specific commits from one branch to another without merging entire branches.\n\n```bash\n# Cherry-pick single commit\ngit cherry-pick abc123\n\n# Cherry-pick range of commits (exclusive start)\ngit cherry-pick abc123..def456\n\n# Cherry-pick without committing (stage changes only)\ngit cherry-pick -n abc123\n\n# Cherry-pick and edit commit message\ngit cherry-pick -e abc123\n```\n\n### 3. Git Bisect\n\nBinary search through commit history to find the commit that introduced a bug.\n\n```bash\n# Start bisect\ngit bisect start\n\n# Mark current commit as bad\ngit bisect bad\n\n# Mark known good commit\ngit bisect good v1.0.0\n\n# Git will checkout middle commit - test it\n# Then mark as good or bad\ngit bisect good  # or: git bisect bad\n\n# Continue until bug found\n# When done\ngit bisect reset\n```\n\n**Automated Bisect:**\n```bash\n# Use script to test automatically\ngit bisect start HEAD v1.0.0\ngit bisect run ./test.sh\n\n# test.sh should exit 0 for good, 1-127 (except 125) for bad\n```\n\n### 4. Worktrees\n\nWork on multiple branches simultaneously without stashing or switching.\n\n```bash\n# List existing worktrees\ngit worktree list\n\n# Add new worktree for feature branch\ngit worktree add ../project-feature feature/new-feature\n\n# Add worktree and create new branch\ngit worktree add -b bugfix/urgent ../project-hotfix main\n\n# Remove worktree\ngit worktree remove ../project-feature\n\n# Prune stale worktrees\ngit worktree prune\n```\n\n### 5. Reflog\n\nYour safety net - tracks all ref movements, even deleted commits.\n\n```bash\n# View reflog\ngit reflog\n\n# View reflog for specific branch\ngit reflog show feature/branch\n\n# Restore deleted commit\ngit reflog\n# Find commit hash\ngit checkout abc123\ngit branch recovered-branch\n\n# Restore deleted branch\ngit reflog\ngit branch deleted-branch abc123\n```\n\n## Practical Workflows\n\n### Workflow 1: Clean Up Feature Branch Before PR\n\n```bash\n# Start with feature branch\ngit checkout feature/user-auth\n\n# Interactive rebase to clean history\ngit rebase -i main\n\n# Example rebase operations:\n# - Squash \"fix typo\" commits\n# - Reword commit messages for clarity\n# - Reorder commits logically\n# - Drop unnecessary commits\n\n# Force push cleaned branch (safe if no one else is using it)\ngit push --force-with-lease origin feature/user-auth\n```\n\n### Workflow 2: Apply Hotfix to Multiple Releases\n\n```bash\n# Create fix on main\ngit checkout main\ngit commit -m \"fix: critical security patch\"\n\n# Apply to release branches\ngit checkout release/2.0\ngit cherry-pick abc123\n\ngit checkout release/1.9\ngit cherry-pick abc123\n\n# Handle conflicts if they arise\ngit cherry-pick --continue\n# or\ngit cherry-pick --abort\n```\n\n### Workflow 3: Find Bug Introduction\n\n```bash\n# Start bisect\ngit bisect start\ngit bisect bad HEAD\ngit bisect good v2.1.0\n\n# Git checks out middle commit - run tests\nnpm test\n\n# If tests fail\ngit bisect bad\n\n# If tests pass\ngit bisect good\n\n# Git will automatically checkout next commit to test\n# Repeat until bug found\n\n# Automated version\ngit bisect start HEAD v2.1.0\ngit bisect run npm test\n```\n\n### Workflow 4: Multi-Branch Development\n\n```bash\n# Main project directory\ncd ~/projects/myapp\n\n# Create worktree for urgent bugfix\ngit worktree add ../myapp-hotfix hotfix/critical-bug\n\n# Work on hotfix in separate directory\ncd ../myapp-hotfix\n# Make changes, commit\ngit commit -m \"fix: resolve critical bug\"\ngit push origin hotfix/critical-bug\n\n# Return to main work without interruption\ncd ~/projects/myapp\ngit fetch origin\ngit cherry-pick hotfix/critical-bug\n\n# Clean up when done\ngit worktree remove ../myapp-hotfix\n```\n\n### Workflow 5: Recover from Mistakes\n\n```bash\n# Accidentally reset to wrong commit\ngit reset --hard HEAD~5  # Oh no!\n\n# Use reflog to find lost commits\ngit reflog\n# Output shows:\n# abc123 HEAD@{0}: reset: moving to HEAD~5\n# def456 HEAD@{1}: commit: my important changes\n\n# Recover lost commits\ngit reset --hard def456\n\n# Or create branch from lost commit\ngit branch recovery def456\n```\n\n## Advanced Techniques\n\n### Rebase vs Merge Strategy\n\n**When to Rebase:**\n- Cleaning up local commits before pushing\n- Keeping feature branch up-to-date with main\n- Creating linear history for easier review\n\n**When to Merge:**\n- Integrating completed features into main\n- Preserving exact history of collaboration\n- Public branches used by others\n\n```bash\n# Update feature branch with main changes (rebase)\ngit checkout feature/my-feature\ngit fetch origin\ngit rebase origin/main\n\n# Handle conflicts\ngit status\n# Fix conflicts in files\ngit add .\ngit rebase --continue\n\n# Or merge instead\ngit merge origin/main\n```\n\n### Autosquash Workflow\n\nAutomatically squash fixup commits during rebase.\n\n```bash\n# Make initial commit\ngit commit -m \"feat: add user authentication\"\n\n# Later, fix something in that commit\n# Stage changes\ngit commit --fixup HEAD  # or specify commit hash\n\n# Make more changes\ngit commit --fixup abc123\n\n# Rebase with autosquash\ngit rebase -i --autosquash main\n\n# Git automatically marks fixup commits\n```\n\n### Split Commit\n\nBreak one commit into multiple logical commits.\n\n```bash\n# Start interactive rebase\ngit rebase -i HEAD~3\n\n# Mark commit to split with 'edit'\n# Git will stop at that commit\n\n# Reset commit but keep changes\ngit reset HEAD^\n\n# Stage and commit in logical chunks\ngit add file1.py\ngit commit -m \"feat: add validation\"\n\ngit add file2.py\ngit commit -m \"feat: add error handling\"\n\n# Continue rebase\ngit rebase --continue\n```\n\n### Partial Cherry-Pick\n\nCherry-pick only specific files from a commit.\n\n```bash\n# Show files in commit\ngit show --name-only abc123\n\n# Checkout specific files from commit\ngit checkout abc123 -- path/to/file1.py path/to/file2.py\n\n# Stage and commit\ngit commit -m \"cherry-pick: apply specific changes from abc123\"\n```\n\n## Best Practices\n\n1. **Always Use --force-with-lease**: Safer than --force, prevents overwriting others' work\n2. **Rebase Only Local Commits**: Don't rebase commits that have been pushed and shared\n3. **Descriptive Commit Messages**: Future you will thank present you\n4. **Atomic Commits**: Each commit should be a single logical change\n5. **Test Before Force Push**: Ensure history rewrite didn't break anything\n6. **Keep Reflog Aware**: Remember reflog is your safety net for 90 days\n7. **Branch Before Risky Operations**: Create backup branch before complex rebases\n\n```bash\n# Safe force push\ngit push --force-with-lease origin feature/branch\n\n# Create backup before risky operation\ngit branch backup-branch\ngit rebase -i main\n# If something goes wrong\ngit reset --hard backup-branch\n```\n\n## Common Pitfalls\n\n- **Rebasing Public Branches**: Causes history conflicts for collaborators\n- **Force Pushing Without Lease**: Can overwrite teammate's work\n- **Losing Work in Rebase**: Resolve conflicts carefully, test after rebase\n- **Forgetting Worktree Cleanup**: Orphaned worktrees consume disk space\n- **Not Backing Up Before Experiment**: Always create safety branch\n- **Bisect on Dirty Working Directory**: Commit or stash before bisecting\n\n## Recovery Commands\n\n```bash\n# Abort operations in progress\ngit rebase --abort\ngit merge --abort\ngit cherry-pick --abort\ngit bisect reset\n\n# Restore file to version from specific commit\ngit restore --source=abc123 path/to/file\n\n# Undo last commit but keep changes\ngit reset --soft HEAD^\n\n# Undo last commit and discard changes\ngit reset --hard HEAD^\n\n# Recover deleted branch (within 90 days)\ngit reflog\ngit branch recovered-branch abc123\n```\n\n## Resources\n\n- **references/git-rebase-guide.md**: Deep dive into interactive rebase\n- **references/git-conflict-resolution.md**: Advanced conflict resolution strategies\n- **references/git-history-rewriting.md**: Safely rewriting Git history\n- **assets/git-workflow-checklist.md**: Pre-PR cleanup checklist\n- **assets/git-aliases.md**: Useful Git aliases for advanced workflows\n- **scripts/git-clean-branches.sh**: Clean up merged and stale branches\n"
}