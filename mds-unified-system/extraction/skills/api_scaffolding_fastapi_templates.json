{
  "id": "api_scaffolding_fastapi_templates",
  "name": "fastapi-templates",
  "source": "api-scaffolding",
  "originalPath": "plugins/api-scaffolding/skills/fastapi-templates/SKILL.md",
  "activationCriteria": "Create production-ready FastAPI projects with async patterns, dependency injection, and comprehensive error handling. Use when building new FastAPI applications or setting up backend API projects.",
  "tier1_metadata": "fastapi-templates: Create production-ready FastAPI projects with async patterns, dependency injection, and comprehensiv",
  "tier2_instructions": "# FastAPI Project Templates\n\nProduction-ready FastAPI project structures with async patterns, dependency injection, middleware, and best practices for building high-performance APIs.\n\n## When to Use This Skill\n\n- Starting new FastAPI projects from scratch\n- Implementing async REST APIs with Python\n- Building high-performance web services and microservices\n- Creating async applications with PostgreSQL, MongoDB\n- Setting up API projects with proper structure and testing\n\n## Core Concepts\n\n### 1. Project Structure\n\n**Recommended Layout:**\n```\napp/\n\u251c\u2500\u2500 api/                    # API routes\n\u2502   \u251c\u2500\u2500 v1/\n\u2502   \u2502   \u251c\u2500\u2500 endpoints/\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 users.py\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 auth.py\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 items.py\n\u2502   \u2502   \u2514\u2500\u2500 router.py\n\u2502   \u2514\u2500\u2500 dependencies.py     # Shared dependencies\n\u251c\u2500\u2500 core/                   # Core configuration\n\u2502   \u251c\u2500\u2500 config.py\n\u2502   \u251c\u2500\u2500 security.py\n\u2502   \u2514\u2500\u2500 database.py\n\u251c\u2500\u2500 models/                 # Database models\n\u2502   \u251c\u2500\u2500 user.py\n\u2502   \u2514\u2500\u2500 item.py\n\u251c\u2500\u2500 schemas/                # Pydantic schemas\n\u2502   \u251c\u2500\u2500 user.py\n\u2502   \u2514\u2500\u2500 item.py\n\u251c\u2500\u2500 services/               # Business logic\n\u2502   \u251c\u2500\u2500 user_service.py\n\u2502   \u2514\u2500\u2500 auth_service.py\n\u251c\u2500\u2500 repositories/           # Data access\n\u2502   \u251c\u2500\u2500 user_repository.py\n\u2502   \u2514\u2500\u2500 item_repository.py\n\u2514\u2500\u2500 main.py                 # Application entry\n```\n\n### 2. Dependency Injection\n\nFastAPI's built-in DI system using `Depends`:\n- Database session management\n- Authentication/authorization\n- Shared business logic\n- Configuration injection\n\n### 3. Async Patterns\n\nProper async/await usage:\n- Async route handlers\n- Async database operations\n- Async background tasks\n- Async middleware\n\n## Implementation Patterns\n\n### Pattern 1: Complete FastAPI Application\n\n```python\n# main.py\nfrom fastapi import FastAPI, Depends\nfrom fastapi.middleware.cors import CORSMiddleware\nfrom contextlib import asynccontextmanager\n\n@asynccontextmanager\nasync def lifespan(app: FastAPI):\n    \"\"\"Application lifespan events.\"\"\"\n    # Startup\n    await database.connect()\n    yield\n    # Shutdown\n  ",
  "tier3_resources": "  await database.disconnect()\n\napp = FastAPI(\n    title=\"API Template\",\n    version=\"1.0.0\",\n    lifespan=lifespan\n)\n\n# CORS middleware\napp.add_middleware(\n    CORSMiddleware,\n    allow_origins=[\"*\"],\n    allow_credentials=True,\n    allow_methods=[\"*\"],\n    allow_headers=[\"*\"],\n)\n\n# Include routers\nfrom app.api.v1.router import api_router\napp.include_router(api_router, prefix=\"/api/v1\")\n\n# core/config.py\nfrom pydantic_settings import BaseSettings\nfrom functools import lru_cache\n\nclass Settings(BaseSettings):\n    \"\"\"Application settings.\"\"\"\n    DATABASE_URL: str\n    SECRET_KEY: str\n    ACCESS_TOKEN_EXPIRE_MINUTES: int = 30\n    API_V1_STR: str = \"/api/v1\"\n\n    class Config:\n        env_file = \".env\"\n\n@lru_cache()\ndef get_settings() -> Settings:\n    return Settings()\n\n# core/database.py\nfrom sqlalchemy.ext.asyncio import create_async_engine, AsyncSession\nfrom sqlalchemy.ext.declarative import declarative_base\nfrom sqlalchemy.orm import sessionmaker\nfrom app.core.config import get_settings\n\nsettings = get_settings()\n\nengine = create_async_engine(\n    settings.DATABASE_URL,\n    echo=True,\n    future=True\n)\n\nAsyncSessionLocal = sessionmaker(\n    engine,\n    class_=AsyncSession,\n    expire_on_commit=False\n)\n\nBase = declarative_base()\n\nasync def get_db() -> AsyncSession:\n    \"\"\"Dependency for database session.\"\"\"\n    async with AsyncSessionLocal() as session:\n        try:\n            yield session\n            await session.commit()\n        except Exception:\n            await session.rollback()\n            raise\n        finally:\n            await session.close()\n```\n\n### Pattern 2: CRUD Repository Pattern\n\n```python\n# repositories/base_repository.py\nfrom typing import Generic, TypeVar, Type, Optional, List\nfrom sqlalchemy.ext.asyncio import AsyncSession\nfrom sqlalchemy import select\nfrom pydantic import BaseModel\n\nModelType = TypeVar(\"ModelType\")\nCreateSchemaType = TypeVar(\"CreateSchemaType\", bound=BaseModel)\nUpdateSchemaType = TypeVar(\"UpdateSchemaType\", bound=BaseModel)\n\nclass BaseRepository(Generic[ModelType, CreateSchemaType, UpdateSchemaType]):\n    \"\"\"Base repository for CRUD operations.\"\"\"\n\n    def __init__(self, model: Type[ModelType]):\n        self.model = model\n\n    async def get(self, db: AsyncSession, id: int) -> Optional[ModelType]:\n        \"\"\"Get by ID.\"\"\"\n        result = await db.execute(\n            select(self.model).where(self.model.id == id)\n        )\n        return result.scalars().first()\n\n    async def get_multi(\n        self,\n        db: AsyncSession,\n        skip: int = 0,\n        limit: int = 100\n    ) -> List[ModelType]:\n        \"\"\"Get multiple records.\"\"\"\n        result = await db.execute(\n            select(self.model).offset(skip).limit(limit)\n        )\n        return result.scalars().all()\n\n    async def create(\n        self,\n        db: AsyncSession,\n        obj_in: CreateSchemaType\n    ) -> ModelType:\n        \"\"\"Create new record.\"\"\"\n        db_obj = self.model(**obj_in.dict())\n        db.add(db_obj)\n        await db.flush(",
  "tokenEstimate": {
    "tier1": 15.600000000000001,
    "tier2": 340.6,
    "tier3": 1617.2
  },
  "fullDefinition": "---\nname: fastapi-templates\ndescription: Create production-ready FastAPI projects with async patterns, dependency injection, and comprehensive error handling. Use when building new FastAPI applications or setting up backend API projects.\n---\n\n# FastAPI Project Templates\n\nProduction-ready FastAPI project structures with async patterns, dependency injection, middleware, and best practices for building high-performance APIs.\n\n## When to Use This Skill\n\n- Starting new FastAPI projects from scratch\n- Implementing async REST APIs with Python\n- Building high-performance web services and microservices\n- Creating async applications with PostgreSQL, MongoDB\n- Setting up API projects with proper structure and testing\n\n## Core Concepts\n\n### 1. Project Structure\n\n**Recommended Layout:**\n```\napp/\n\u251c\u2500\u2500 api/                    # API routes\n\u2502   \u251c\u2500\u2500 v1/\n\u2502   \u2502   \u251c\u2500\u2500 endpoints/\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 users.py\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 auth.py\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 items.py\n\u2502   \u2502   \u2514\u2500\u2500 router.py\n\u2502   \u2514\u2500\u2500 dependencies.py     # Shared dependencies\n\u251c\u2500\u2500 core/                   # Core configuration\n\u2502   \u251c\u2500\u2500 config.py\n\u2502   \u251c\u2500\u2500 security.py\n\u2502   \u2514\u2500\u2500 database.py\n\u251c\u2500\u2500 models/                 # Database models\n\u2502   \u251c\u2500\u2500 user.py\n\u2502   \u2514\u2500\u2500 item.py\n\u251c\u2500\u2500 schemas/                # Pydantic schemas\n\u2502   \u251c\u2500\u2500 user.py\n\u2502   \u2514\u2500\u2500 item.py\n\u251c\u2500\u2500 services/               # Business logic\n\u2502   \u251c\u2500\u2500 user_service.py\n\u2502   \u2514\u2500\u2500 auth_service.py\n\u251c\u2500\u2500 repositories/           # Data access\n\u2502   \u251c\u2500\u2500 user_repository.py\n\u2502   \u2514\u2500\u2500 item_repository.py\n\u2514\u2500\u2500 main.py                 # Application entry\n```\n\n### 2. Dependency Injection\n\nFastAPI's built-in DI system using `Depends`:\n- Database session management\n- Authentication/authorization\n- Shared business logic\n- Configuration injection\n\n### 3. Async Patterns\n\nProper async/await usage:\n- Async route handlers\n- Async database operations\n- Async background tasks\n- Async middleware\n\n## Implementation Patterns\n\n### Pattern 1: Complete FastAPI Application\n\n```python\n# main.py\nfrom fastapi import FastAPI, Depends\nfrom fastapi.middleware.cors import CORSMiddleware\nfrom contextlib import asynccontextmanager\n\n@asynccontextmanager\nasync def lifespan(app: FastAPI):\n    \"\"\"Application lifespan events.\"\"\"\n    # Startup\n    await database.connect()\n    yield\n    # Shutdown\n    await database.disconnect()\n\napp = FastAPI(\n    title=\"API Template\",\n    version=\"1.0.0\",\n    lifespan=lifespan\n)\n\n# CORS middleware\napp.add_middleware(\n    CORSMiddleware,\n    allow_origins=[\"*\"],\n    allow_credentials=True,\n    allow_methods=[\"*\"],\n    allow_headers=[\"*\"],\n)\n\n# Include routers\nfrom app.api.v1.router import api_router\napp.include_router(api_router, prefix=\"/api/v1\")\n\n# core/config.py\nfrom pydantic_settings import BaseSettings\nfrom functools import lru_cache\n\nclass Settings(BaseSettings):\n    \"\"\"Application settings.\"\"\"\n    DATABASE_URL: str\n    SECRET_KEY: str\n    ACCESS_TOKEN_EXPIRE_MINUTES: int = 30\n    API_V1_STR: str = \"/api/v1\"\n\n    class Config:\n        env_file = \".env\"\n\n@lru_cache()\ndef get_settings() -> Settings:\n    return Settings()\n\n# core/database.py\nfrom sqlalchemy.ext.asyncio import create_async_engine, AsyncSession\nfrom sqlalchemy.ext.declarative import declarative_base\nfrom sqlalchemy.orm import sessionmaker\nfrom app.core.config import get_settings\n\nsettings = get_settings()\n\nengine = create_async_engine(\n    settings.DATABASE_URL,\n    echo=True,\n    future=True\n)\n\nAsyncSessionLocal = sessionmaker(\n    engine,\n    class_=AsyncSession,\n    expire_on_commit=False\n)\n\nBase = declarative_base()\n\nasync def get_db() -> AsyncSession:\n    \"\"\"Dependency for database session.\"\"\"\n    async with AsyncSessionLocal() as session:\n        try:\n            yield session\n            await session.commit()\n        except Exception:\n            await session.rollback()\n            raise\n        finally:\n            await session.close()\n```\n\n### Pattern 2: CRUD Repository Pattern\n\n```python\n# repositories/base_repository.py\nfrom typing import Generic, TypeVar, Type, Optional, List\nfrom sqlalchemy.ext.asyncio import AsyncSession\nfrom sqlalchemy import select\nfrom pydantic import BaseModel\n\nModelType = TypeVar(\"ModelType\")\nCreateSchemaType = TypeVar(\"CreateSchemaType\", bound=BaseModel)\nUpdateSchemaType = TypeVar(\"UpdateSchemaType\", bound=BaseModel)\n\nclass BaseRepository(Generic[ModelType, CreateSchemaType, UpdateSchemaType]):\n    \"\"\"Base repository for CRUD operations.\"\"\"\n\n    def __init__(self, model: Type[ModelType]):\n        self.model = model\n\n    async def get(self, db: AsyncSession, id: int) -> Optional[ModelType]:\n        \"\"\"Get by ID.\"\"\"\n        result = await db.execute(\n            select(self.model).where(self.model.id == id)\n        )\n        return result.scalars().first()\n\n    async def get_multi(\n        self,\n        db: AsyncSession,\n        skip: int = 0,\n        limit: int = 100\n    ) -> List[ModelType]:\n        \"\"\"Get multiple records.\"\"\"\n        result = await db.execute(\n            select(self.model).offset(skip).limit(limit)\n        )\n        return result.scalars().all()\n\n    async def create(\n        self,\n        db: AsyncSession,\n        obj_in: CreateSchemaType\n    ) -> ModelType:\n        \"\"\"Create new record.\"\"\"\n        db_obj = self.model(**obj_in.dict())\n        db.add(db_obj)\n        await db.flush()\n        await db.refresh(db_obj)\n        return db_obj\n\n    async def update(\n        self,\n        db: AsyncSession,\n        db_obj: ModelType,\n        obj_in: UpdateSchemaType\n    ) -> ModelType:\n        \"\"\"Update record.\"\"\"\n        update_data = obj_in.dict(exclude_unset=True)\n        for field, value in update_data.items():\n            setattr(db_obj, field, value)\n        await db.flush()\n        await db.refresh(db_obj)\n        return db_obj\n\n    async def delete(self, db: AsyncSession, id: int) -> bool:\n        \"\"\"Delete record.\"\"\"\n        obj = await self.get(db, id)\n        if obj:\n            await db.delete(obj)\n            return True\n        return False\n\n# repositories/user_repository.py\nfrom app.repositories.base_repository import BaseRepository\nfrom app.models.user import User\nfrom app.schemas.user import UserCreate, UserUpdate\n\nclass UserRepository(BaseRepository[User, UserCreate, UserUpdate]):\n    \"\"\"User-specific repository.\"\"\"\n\n    async def get_by_email(self, db: AsyncSession, email: str) -> Optional[User]:\n        \"\"\"Get user by email.\"\"\"\n        result = await db.execute(\n            select(User).where(User.email == email)\n        )\n        return result.scalars().first()\n\n    async def is_active(self, db: AsyncSession, user_id: int) -> bool:\n        \"\"\"Check if user is active.\"\"\"\n        user = await self.get(db, user_id)\n        return user.is_active if user else False\n\nuser_repository = UserRepository(User)\n```\n\n### Pattern 3: Service Layer\n\n```python\n# services/user_service.py\nfrom typing import Optional\nfrom sqlalchemy.ext.asyncio import AsyncSession\nfrom app.repositories.user_repository import user_repository\nfrom app.schemas.user import UserCreate, UserUpdate, User\nfrom app.core.security import get_password_hash, verify_password\n\nclass UserService:\n    \"\"\"Business logic for users.\"\"\"\n\n    def __init__(self):\n        self.repository = user_repository\n\n    async def create_user(\n        self,\n        db: AsyncSession,\n        user_in: UserCreate\n    ) -> User:\n        \"\"\"Create new user with hashed password.\"\"\"\n        # Check if email exists\n        existing = await self.repository.get_by_email(db, user_in.email)\n        if existing:\n            raise ValueError(\"Email already registered\")\n\n        # Hash password\n        user_in_dict = user_in.dict()\n        user_in_dict[\"hashed_password\"] = get_password_hash(user_in_dict.pop(\"password\"))\n\n        # Create user\n        user = await self.repository.create(db, UserCreate(**user_in_dict))\n        return user\n\n    async def authenticate(\n        self,\n        db: AsyncSession,\n        email: str,\n        password: str\n    ) -> Optional[User]:\n        \"\"\"Authenticate user.\"\"\"\n        user = await self.repository.get_by_email(db, email)\n        if not user:\n            return None\n        if not verify_password(password, user.hashed_password):\n            return None\n        return user\n\n    async def update_user(\n        self,\n        db: AsyncSession,\n        user_id: int,\n        user_in: UserUpdate\n    ) -> Optional[User]:\n        \"\"\"Update user.\"\"\"\n        user = await self.repository.get(db, user_id)\n        if not user:\n            return None\n\n        if user_in.password:\n            user_in_dict = user_in.dict(exclude_unset=True)\n            user_in_dict[\"hashed_password\"] = get_password_hash(\n                user_in_dict.pop(\"password\")\n            )\n            user_in = UserUpdate(**user_in_dict)\n\n        return await self.repository.update(db, user, user_in)\n\nuser_service = UserService()\n```\n\n### Pattern 4: API Endpoints with Dependencies\n\n```python\n# api/v1/endpoints/users.py\nfrom fastapi import APIRouter, Depends, HTTPException, status\nfrom sqlalchemy.ext.asyncio import AsyncSession\nfrom typing import List\n\nfrom app.core.database import get_db\nfrom app.schemas.user import User, UserCreate, UserUpdate\nfrom app.services.user_service import user_service\nfrom app.api.dependencies import get_current_user\n\nrouter = APIRouter()\n\n@router.post(\"/\", response_model=User, status_code=status.HTTP_201_CREATED)\nasync def create_user(\n    user_in: UserCreate,\n    db: AsyncSession = Depends(get_db)\n):\n    \"\"\"Create new user.\"\"\"\n    try:\n        user = await user_service.create_user(db, user_in)\n        return user\n    except ValueError as e:\n        raise HTTPException(status_code=400, detail=str(e))\n\n@router.get(\"/me\", response_model=User)\nasync def read_current_user(\n    current_user: User = Depends(get_current_user)\n):\n    \"\"\"Get current user.\"\"\"\n    return current_user\n\n@router.get(\"/{user_id}\", response_model=User)\nasync def read_user(\n    user_id: int,\n    db: AsyncSession = Depends(get_db),\n    current_user: User = Depends(get_current_user)\n):\n    \"\"\"Get user by ID.\"\"\"\n    user = await user_service.repository.get(db, user_id)\n    if not user:\n        raise HTTPException(status_code=404, detail=\"User not found\")\n    return user\n\n@router.patch(\"/{user_id}\", response_model=User)\nasync def update_user(\n    user_id: int,\n    user_in: UserUpdate,\n    db: AsyncSession = Depends(get_db),\n    current_user: User = Depends(get_current_user)\n):\n    \"\"\"Update user.\"\"\"\n    if current_user.id != user_id:\n        raise HTTPException(status_code=403, detail=\"Not authorized\")\n\n    user = await user_service.update_user(db, user_id, user_in)\n    if not user:\n        raise HTTPException(status_code=404, detail=\"User not found\")\n    return user\n\n@router.delete(\"/{user_id}\", status_code=status.HTTP_204_NO_CONTENT)\nasync def delete_user(\n    user_id: int,\n    db: AsyncSession = Depends(get_db),\n    current_user: User = Depends(get_current_user)\n):\n    \"\"\"Delete user.\"\"\"\n    if current_user.id != user_id:\n        raise HTTPException(status_code=403, detail=\"Not authorized\")\n\n    deleted = await user_service.repository.delete(db, user_id)\n    if not deleted:\n        raise HTTPException(status_code=404, detail=\"User not found\")\n```\n\n### Pattern 5: Authentication & Authorization\n\n```python\n# core/security.py\nfrom datetime import datetime, timedelta\nfrom typing import Optional\nfrom jose import JWTError, jwt\nfrom passlib.context import CryptContext\nfrom app.core.config import get_settings\n\nsettings = get_settings()\npwd_context = CryptContext(schemes=[\"bcrypt\"], deprecated=\"auto\")\n\nALGORITHM = \"HS256\"\n\ndef create_access_token(data: dict, expires_delta: Optional[timedelta] = None):\n    \"\"\"Create JWT access token.\"\"\"\n    to_encode = data.copy()\n    if expires_delta:\n        expire = datetime.utcnow() + expires_delta\n    else:\n        expire = datetime.utcnow() + timedelta(minutes=15)\n    to_encode.update({\"exp\": expire})\n    encoded_jwt = jwt.encode(to_encode, settings.SECRET_KEY, algorithm=ALGORITHM)\n    return encoded_jwt\n\ndef verify_password(plain_password: str, hashed_password: str) -> bool:\n    \"\"\"Verify password against hash.\"\"\"\n    return pwd_context.verify(plain_password, hashed_password)\n\ndef get_password_hash(password: str) -> str:\n    \"\"\"Hash password.\"\"\"\n    return pwd_context.hash(password)\n\n# api/dependencies.py\nfrom fastapi import Depends, HTTPException, status\nfrom fastapi.security import OAuth2PasswordBearer\nfrom jose import JWTError, jwt\nfrom sqlalchemy.ext.asyncio import AsyncSession\n\nfrom app.core.database import get_db\nfrom app.core.security import ALGORITHM\nfrom app.core.config import get_settings\nfrom app.repositories.user_repository import user_repository\n\noauth2_scheme = OAuth2PasswordBearer(tokenUrl=f\"{settings.API_V1_STR}/auth/login\")\n\nasync def get_current_user(\n    db: AsyncSession = Depends(get_db),\n    token: str = Depends(oauth2_scheme)\n):\n    \"\"\"Get current authenticated user.\"\"\"\n    credentials_exception = HTTPException(\n        status_code=status.HTTP_401_UNAUTHORIZED,\n        detail=\"Could not validate credentials\",\n        headers={\"WWW-Authenticate\": \"Bearer\"},\n    )\n\n    try:\n        payload = jwt.decode(token, settings.SECRET_KEY, algorithms=[ALGORITHM])\n        user_id: int = payload.get(\"sub\")\n        if user_id is None:\n            raise credentials_exception\n    except JWTError:\n        raise credentials_exception\n\n    user = await user_repository.get(db, user_id)\n    if user is None:\n        raise credentials_exception\n\n    return user\n```\n\n## Testing\n\n```python\n# tests/conftest.py\nimport pytest\nimport asyncio\nfrom httpx import AsyncClient\nfrom sqlalchemy.ext.asyncio import create_async_engine, AsyncSession\nfrom sqlalchemy.orm import sessionmaker\n\nfrom app.main import app\nfrom app.core.database import get_db, Base\n\nTEST_DATABASE_URL = \"sqlite+aiosqlite:///:memory:\"\n\n@pytest.fixture(scope=\"session\")\ndef event_loop():\n    loop = asyncio.get_event_loop_policy().new_event_loop()\n    yield loop\n    loop.close()\n\n@pytest.fixture\nasync def db_session():\n    engine = create_async_engine(TEST_DATABASE_URL, echo=True)\n    async with engine.begin() as conn:\n        await conn.run_sync(Base.metadata.create_all)\n\n    AsyncSessionLocal = sessionmaker(\n        engine, class_=AsyncSession, expire_on_commit=False\n    )\n\n    async with AsyncSessionLocal() as session:\n        yield session\n\n@pytest.fixture\nasync def client(db_session):\n    async def override_get_db():\n        yield db_session\n\n    app.dependency_overrides[get_db] = override_get_db\n\n    async with AsyncClient(app=app, base_url=\"http://test\") as client:\n        yield client\n\n# tests/test_users.py\nimport pytest\n\n@pytest.mark.asyncio\nasync def test_create_user(client):\n    response = await client.post(\n        \"/api/v1/users/\",\n        json={\n            \"email\": \"test@example.com\",\n            \"password\": \"testpass123\",\n            \"name\": \"Test User\"\n        }\n    )\n    assert response.status_code == 201\n    data = response.json()\n    assert data[\"email\"] == \"test@example.com\"\n    assert \"id\" in data\n```\n\n## Resources\n\n- **references/fastapi-architecture.md**: Detailed architecture guide\n- **references/async-best-practices.md**: Async/await patterns\n- **references/testing-strategies.md**: Comprehensive testing guide\n- **assets/project-template/**: Complete FastAPI project\n- **assets/docker-compose.yml**: Development environment setup\n\n## Best Practices\n\n1. **Async All The Way**: Use async for database, external APIs\n2. **Dependency Injection**: Leverage FastAPI's DI system\n3. **Repository Pattern**: Separate data access from business logic\n4. **Service Layer**: Keep business logic out of routes\n5. **Pydantic Schemas**: Strong typing for request/response\n6. **Error Handling**: Consistent error responses\n7. **Testing**: Test all layers independently\n\n## Common Pitfalls\n\n- **Blocking Code in Async**: Using synchronous database drivers\n- **No Service Layer**: Business logic in route handlers\n- **Missing Type Hints**: Loses FastAPI's benefits\n- **Ignoring Sessions**: Not properly managing database sessions\n- **No Testing**: Skipping integration tests\n- **Tight Coupling**: Direct database access in routes\n"
}