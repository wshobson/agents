{
  "id": "framework_migration_react_modernization",
  "name": "react-modernization",
  "source": "framework-migration",
  "originalPath": "plugins/framework-migration/skills/react-modernization/SKILL.md",
  "activationCriteria": "Upgrade React applications to latest versions, migrate from class components to hooks, and adopt concurrent features. Use when modernizing React codebases, migrating to React Hooks, or upgrading to la",
  "tier1_metadata": "react-modernization: Upgrade React applications to latest versions, migrate from class components to hooks, and adopt con",
  "tier2_instructions": "# React Modernization\n\nMaster React version upgrades, class to hooks migration, concurrent features adoption, and codemods for automated transformation.\n\n## When to Use This Skill\n\n- Upgrading React applications to latest versions\n- Migrating class components to functional components with hooks\n- Adopting concurrent React features (Suspense, transitions)\n- Applying codemods for automated refactoring\n- Modernizing state management patterns\n- Updating to TypeScript\n- Improving performance with React 18+ features\n\n## Version Upgrade Path\n\n### React 16 \u2192 17 \u2192 18\n\n**Breaking Changes by Version:**\n\n**React 17:**\n- Event delegation changes\n- No event pooling\n- Effect cleanup timing\n- JSX transform (no React import needed)\n\n**React 18:**\n- Automatic batching\n- Concurrent rendering\n- Strict Mode changes (double invocation)\n- New root API\n- Suspense on server\n\n## Class to Hooks Migration\n\n### State Management\n```javascript\n// Before: Class component\nclass Counter extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      count: 0,\n      name: ''\n    };\n  }\n\n  increment = () => {\n    this.setState({ count: this.state.count + 1 });\n  }\n\n  render() {\n    return (\n      <div>\n        <p>Count: {this.state.count}</p>\n        <button onClick={this.increment}>Increment</button>\n      </div>\n    );\n  }\n}\n\n// After: Functional component with hooks\nfunction Counter() {\n  const [count, setCount] = useState(0);\n  const [name, setName] = useState('');\n\n  const increment = () => {\n    setCount(count + 1);\n  };\n\n  return (\n    <div>\n      <p>Count: {count}</p>\n      <button onClick={increment}>Increment</button>\n    </div>\n  );\n}\n```\n\n### Lifecycle Methods to Hooks\n```javascript\n// Before: Lifecycle methods\nclass DataFetcher extends React.Component {\n  state = { data: null, loading: true };\n\n  componentDidMount() {\n    this.fetchData();\n  }\n\n  componentDidUpdate(prevProps) {\n    if (prevProps.id !== this.props.id) {\n      this.fetchData();\n    }\n  }\n\n  compo",
  "tier3_resources": "nentWillUnmount() {\n    this.cancelRequest();\n  }\n\n  fetchData = async () => {\n    const data = await fetch(`/api/${this.props.id}`);\n    this.setState({ data, loading: false });\n  };\n\n  cancelRequest = () => {\n    // Cleanup\n  };\n\n  render() {\n    if (this.state.loading) return <div>Loading...</div>;\n    return <div>{this.state.data}</div>;\n  }\n}\n\n// After: useEffect hook\nfunction DataFetcher({ id }) {\n  const [data, setData] = useState(null);\n  const [loading, setLoading] = useState(true);\n\n  useEffect(() => {\n    let cancelled = false;\n\n    const fetchData = async () => {\n      try {\n        const response = await fetch(`/api/${id}`);\n        const result = await response.json();\n\n        if (!cancelled) {\n          setData(result);\n          setLoading(false);\n        }\n      } catch (error) {\n        if (!cancelled) {\n          console.error(error);\n        }\n      }\n    };\n\n    fetchData();\n\n    // Cleanup function\n    return () => {\n      cancelled = true;\n    };\n  }, [id]); // Re-run when id changes\n\n  if (loading) return <div>Loading...</div>;\n  return <div>{data}</div>;\n}\n```\n\n### Context and HOCs to Hooks\n```javascript\n// Before: Context consumer and HOC\nconst ThemeContext = React.createContext();\n\nclass ThemedButton extends React.Component {\n  static contextType = ThemeContext;\n\n  render() {\n    return (\n      <button style={{ background: this.context.theme }}>\n        {this.props.children}\n      </button>\n    );\n  }\n}\n\n// After: useContext hook\nfunction ThemedButton({ children }) {\n  const { theme } = useContext(ThemeContext);\n\n  return (\n    <button style={{ background: theme }}>\n      {children}\n    </button>\n  );\n}\n\n// Before: HOC for data fetching\nfunction withUser(Component) {\n  return class extends React.Component {\n    state = { user: null };\n\n    componentDidMount() {\n      fetchUser().then(user => this.setState({ user }));\n    }\n\n    render() {\n      return <Component {...this.props} user={this.state.user} />;\n    }\n  };\n}\n\n// After: Custom hook\nfunction useUser() {\n  const [user, setUser] = useState(null);\n\n  useEffect(() => {\n    fetchUser().then(setUser);\n  }, []);\n\n  return user;\n}\n\nfunction UserProfile() {\n  const user = useUser();\n  if (!user) return <div>Loading...</div>;\n  return <div>{user.name}</div>;\n}\n```\n\n## React 18 Concurrent Features\n\n### New Root API\n```javascript\n// Before: React 17\nimport ReactDOM from 'react-dom';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// After: React 18\nimport { createRoot } from 'react-dom/client';\n\nconst root = createRoot(document.getElementById('root'));\nroot.render(<App />);\n```\n\n### Automatic Batching\n```javascript\n// React 18: All updates are batched\nfunction handleClick() {\n  setCount(c => c + 1);\n  setFlag(f => !f);\n  // Only one re-render (batched)\n}\n\n// Even in async:\nsetTimeout(() => {\n  setCount(c => c + 1);\n  setFlag(f => !f);\n  // Still batched in React 18!\n}, 1000);\n\n// Opt out if needed\nimport { flushSync } from 'react-dom';\n\nflushSync(() => {\n  setC",
  "tokenEstimate": {
    "tier1": 20.8,
    "tier2": 339.3,
    "tier3": 1556.1000000000001
  },
  "fullDefinition": "---\nname: react-modernization\ndescription: Upgrade React applications to latest versions, migrate from class components to hooks, and adopt concurrent features. Use when modernizing React codebases, migrating to React Hooks, or upgrading to latest React versions.\n---\n\n# React Modernization\n\nMaster React version upgrades, class to hooks migration, concurrent features adoption, and codemods for automated transformation.\n\n## When to Use This Skill\n\n- Upgrading React applications to latest versions\n- Migrating class components to functional components with hooks\n- Adopting concurrent React features (Suspense, transitions)\n- Applying codemods for automated refactoring\n- Modernizing state management patterns\n- Updating to TypeScript\n- Improving performance with React 18+ features\n\n## Version Upgrade Path\n\n### React 16 \u2192 17 \u2192 18\n\n**Breaking Changes by Version:**\n\n**React 17:**\n- Event delegation changes\n- No event pooling\n- Effect cleanup timing\n- JSX transform (no React import needed)\n\n**React 18:**\n- Automatic batching\n- Concurrent rendering\n- Strict Mode changes (double invocation)\n- New root API\n- Suspense on server\n\n## Class to Hooks Migration\n\n### State Management\n```javascript\n// Before: Class component\nclass Counter extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      count: 0,\n      name: ''\n    };\n  }\n\n  increment = () => {\n    this.setState({ count: this.state.count + 1 });\n  }\n\n  render() {\n    return (\n      <div>\n        <p>Count: {this.state.count}</p>\n        <button onClick={this.increment}>Increment</button>\n      </div>\n    );\n  }\n}\n\n// After: Functional component with hooks\nfunction Counter() {\n  const [count, setCount] = useState(0);\n  const [name, setName] = useState('');\n\n  const increment = () => {\n    setCount(count + 1);\n  };\n\n  return (\n    <div>\n      <p>Count: {count}</p>\n      <button onClick={increment}>Increment</button>\n    </div>\n  );\n}\n```\n\n### Lifecycle Methods to Hooks\n```javascript\n// Before: Lifecycle methods\nclass DataFetcher extends React.Component {\n  state = { data: null, loading: true };\n\n  componentDidMount() {\n    this.fetchData();\n  }\n\n  componentDidUpdate(prevProps) {\n    if (prevProps.id !== this.props.id) {\n      this.fetchData();\n    }\n  }\n\n  componentWillUnmount() {\n    this.cancelRequest();\n  }\n\n  fetchData = async () => {\n    const data = await fetch(`/api/${this.props.id}`);\n    this.setState({ data, loading: false });\n  };\n\n  cancelRequest = () => {\n    // Cleanup\n  };\n\n  render() {\n    if (this.state.loading) return <div>Loading...</div>;\n    return <div>{this.state.data}</div>;\n  }\n}\n\n// After: useEffect hook\nfunction DataFetcher({ id }) {\n  const [data, setData] = useState(null);\n  const [loading, setLoading] = useState(true);\n\n  useEffect(() => {\n    let cancelled = false;\n\n    const fetchData = async () => {\n      try {\n        const response = await fetch(`/api/${id}`);\n        const result = await response.json();\n\n        if (!cancelled) {\n          setData(result);\n          setLoading(false);\n        }\n      } catch (error) {\n        if (!cancelled) {\n          console.error(error);\n        }\n      }\n    };\n\n    fetchData();\n\n    // Cleanup function\n    return () => {\n      cancelled = true;\n    };\n  }, [id]); // Re-run when id changes\n\n  if (loading) return <div>Loading...</div>;\n  return <div>{data}</div>;\n}\n```\n\n### Context and HOCs to Hooks\n```javascript\n// Before: Context consumer and HOC\nconst ThemeContext = React.createContext();\n\nclass ThemedButton extends React.Component {\n  static contextType = ThemeContext;\n\n  render() {\n    return (\n      <button style={{ background: this.context.theme }}>\n        {this.props.children}\n      </button>\n    );\n  }\n}\n\n// After: useContext hook\nfunction ThemedButton({ children }) {\n  const { theme } = useContext(ThemeContext);\n\n  return (\n    <button style={{ background: theme }}>\n      {children}\n    </button>\n  );\n}\n\n// Before: HOC for data fetching\nfunction withUser(Component) {\n  return class extends React.Component {\n    state = { user: null };\n\n    componentDidMount() {\n      fetchUser().then(user => this.setState({ user }));\n    }\n\n    render() {\n      return <Component {...this.props} user={this.state.user} />;\n    }\n  };\n}\n\n// After: Custom hook\nfunction useUser() {\n  const [user, setUser] = useState(null);\n\n  useEffect(() => {\n    fetchUser().then(setUser);\n  }, []);\n\n  return user;\n}\n\nfunction UserProfile() {\n  const user = useUser();\n  if (!user) return <div>Loading...</div>;\n  return <div>{user.name}</div>;\n}\n```\n\n## React 18 Concurrent Features\n\n### New Root API\n```javascript\n// Before: React 17\nimport ReactDOM from 'react-dom';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// After: React 18\nimport { createRoot } from 'react-dom/client';\n\nconst root = createRoot(document.getElementById('root'));\nroot.render(<App />);\n```\n\n### Automatic Batching\n```javascript\n// React 18: All updates are batched\nfunction handleClick() {\n  setCount(c => c + 1);\n  setFlag(f => !f);\n  // Only one re-render (batched)\n}\n\n// Even in async:\nsetTimeout(() => {\n  setCount(c => c + 1);\n  setFlag(f => !f);\n  // Still batched in React 18!\n}, 1000);\n\n// Opt out if needed\nimport { flushSync } from 'react-dom';\n\nflushSync(() => {\n  setCount(c => c + 1);\n});\n// Re-render happens here\nsetFlag(f => !f);\n// Another re-render\n```\n\n### Transitions\n```javascript\nimport { useState, useTransition } from 'react';\n\nfunction SearchResults() {\n  const [query, setQuery] = useState('');\n  const [results, setResults] = useState([]);\n  const [isPending, startTransition] = useTransition();\n\n  const handleChange = (e) => {\n    // Urgent: Update input immediately\n    setQuery(e.target.value);\n\n    // Non-urgent: Update results (can be interrupted)\n    startTransition(() => {\n      setResults(searchResults(e.target.value));\n    });\n  };\n\n  return (\n    <>\n      <input value={query} onChange={handleChange} />\n      {isPending && <Spinner />}\n      <Results data={results} />\n    </>\n  );\n}\n```\n\n### Suspense for Data Fetching\n```javascript\nimport { Suspense } from 'react';\n\n// Resource-based data fetching (with React 18)\nconst resource = fetchProfileData();\n\nfunction ProfilePage() {\n  return (\n    <Suspense fallback={<Loading />}>\n      <ProfileDetails />\n      <Suspense fallback={<Loading />}>\n        <ProfileTimeline />\n      </Suspense>\n    </Suspense>\n  );\n}\n\nfunction ProfileDetails() {\n  // This will suspend if data not ready\n  const user = resource.user.read();\n  return <h1>{user.name}</h1>;\n}\n\nfunction ProfileTimeline() {\n  const posts = resource.posts.read();\n  return <Timeline posts={posts} />;\n}\n```\n\n## Codemods for Automation\n\n### Run React Codemods\n```bash\n# Install jscodeshift\nnpm install -g jscodeshift\n\n# React 16.9 codemod (rename unsafe lifecycle methods)\nnpx react-codeshift <transform> <path>\n\n# Example: Rename UNSAFE_ methods\nnpx react-codeshift --parser=tsx \\\n  --transform=react-codeshift/transforms/rename-unsafe-lifecycles.js \\\n  src/\n\n# Update to new JSX Transform (React 17+)\nnpx react-codeshift --parser=tsx \\\n  --transform=react-codeshift/transforms/new-jsx-transform.js \\\n  src/\n\n# Class to Hooks (third-party)\nnpx codemod react/hooks/convert-class-to-function src/\n```\n\n### Custom Codemod Example\n```javascript\n// custom-codemod.js\nmodule.exports = function(file, api) {\n  const j = api.jscodeshift;\n  const root = j(file.source);\n\n  // Find setState calls\n  root.find(j.CallExpression, {\n    callee: {\n      type: 'MemberExpression',\n      property: { name: 'setState' }\n    }\n  }).forEach(path => {\n    // Transform to useState\n    // ... transformation logic\n  });\n\n  return root.toSource();\n};\n\n// Run: jscodeshift -t custom-codemod.js src/\n```\n\n## Performance Optimization\n\n### useMemo and useCallback\n```javascript\nfunction ExpensiveComponent({ items, filter }) {\n  // Memoize expensive calculation\n  const filteredItems = useMemo(() => {\n    return items.filter(item => item.category === filter);\n  }, [items, filter]);\n\n  // Memoize callback to prevent child re-renders\n  const handleClick = useCallback((id) => {\n    console.log('Clicked:', id);\n  }, []); // No dependencies, never changes\n\n  return (\n    <List items={filteredItems} onClick={handleClick} />\n  );\n}\n\n// Child component with memo\nconst List = React.memo(({ items, onClick }) => {\n  return items.map(item => (\n    <Item key={item.id} item={item} onClick={onClick} />\n  ));\n});\n```\n\n### Code Splitting\n```javascript\nimport { lazy, Suspense } from 'react';\n\n// Lazy load components\nconst Dashboard = lazy(() => import('./Dashboard'));\nconst Settings = lazy(() => import('./Settings'));\n\nfunction App() {\n  return (\n    <Suspense fallback={<Loading />}>\n      <Routes>\n        <Route path=\"/dashboard\" element={<Dashboard />} />\n        <Route path=\"/settings\" element={<Settings />} />\n      </Routes>\n    </Suspense>\n  );\n}\n```\n\n## TypeScript Migration\n\n```typescript\n// Before: JavaScript\nfunction Button({ onClick, children }) {\n  return <button onClick={onClick}>{children}</button>;\n}\n\n// After: TypeScript\ninterface ButtonProps {\n  onClick: () => void;\n  children: React.ReactNode;\n}\n\nfunction Button({ onClick, children }: ButtonProps) {\n  return <button onClick={onClick}>{children}</button>;\n}\n\n// Generic components\ninterface ListProps<T> {\n  items: T[];\n  renderItem: (item: T) => React.ReactNode;\n}\n\nfunction List<T>({ items, renderItem }: ListProps<T>) {\n  return <>{items.map(renderItem)}</>;\n}\n```\n\n## Migration Checklist\n\n```markdown\n### Pre-Migration\n- [ ] Update dependencies incrementally (not all at once)\n- [ ] Review breaking changes in release notes\n- [ ] Set up testing suite\n- [ ] Create feature branch\n\n### Class \u2192 Hooks Migration\n- [ ] Identify class components to migrate\n- [ ] Start with leaf components (no children)\n- [ ] Convert state to useState\n- [ ] Convert lifecycle to useEffect\n- [ ] Convert context to useContext\n- [ ] Extract custom hooks\n- [ ] Test thoroughly\n\n### React 18 Upgrade\n- [ ] Update to React 17 first (if needed)\n- [ ] Update react and react-dom to 18\n- [ ] Update @types/react if using TypeScript\n- [ ] Change to createRoot API\n- [ ] Test with StrictMode (double invocation)\n- [ ] Address concurrent rendering issues\n- [ ] Adopt Suspense/Transitions where beneficial\n\n### Performance\n- [ ] Identify performance bottlenecks\n- [ ] Add React.memo where appropriate\n- [ ] Use useMemo/useCallback for expensive operations\n- [ ] Implement code splitting\n- [ ] Optimize re-renders\n\n### Testing\n- [ ] Update test utilities (React Testing Library)\n- [ ] Test with React 18 features\n- [ ] Check for warnings in console\n- [ ] Performance testing\n```\n\n## Resources\n\n- **references/breaking-changes.md**: Version-specific breaking changes\n- **references/codemods.md**: Codemod usage guide\n- **references/hooks-migration.md**: Comprehensive hooks patterns\n- **references/concurrent-features.md**: React 18 concurrent features\n- **assets/codemod-config.json**: Codemod configurations\n- **assets/migration-checklist.md**: Step-by-step checklist\n- **scripts/apply-codemods.sh**: Automated codemod script\n\n## Best Practices\n\n1. **Incremental Migration**: Don't migrate everything at once\n2. **Test Thoroughly**: Comprehensive testing at each step\n3. **Use Codemods**: Automate repetitive transformations\n4. **Start Simple**: Begin with leaf components\n5. **Leverage StrictMode**: Catch issues early\n6. **Monitor Performance**: Measure before and after\n7. **Document Changes**: Keep migration log\n\n## Common Pitfalls\n\n- Forgetting useEffect dependencies\n- Over-using useMemo/useCallback\n- Not handling cleanup in useEffect\n- Mixing class and functional patterns\n- Ignoring StrictMode warnings\n- Breaking change assumptions\n"
}