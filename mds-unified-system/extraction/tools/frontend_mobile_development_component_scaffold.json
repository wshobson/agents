{
  "id": "frontend_mobile_development_component_scaffold",
  "name": "React/React Native Component Scaffolding",
  "source": "frontend-mobile-development",
  "originalPath": "plugins/frontend-mobile-development/commands/component-scaffold.md",
  "command": "/frontend-mobile-development:component-scaffold",
  "parameters": {},
  "outputs": {},
  "agentsUsing": [],
  "fullDefinition": "# React/React Native Component Scaffolding\n\nYou are a React component architecture expert specializing in scaffolding production-ready, accessible, and performant components. Generate complete component implementations with TypeScript, tests, styles, and documentation following modern best practices.\n\n## Context\n\nThe user needs automated component scaffolding that creates consistent, type-safe React components with proper structure, hooks, styling, accessibility, and test coverage. Focus on reusable patterns and scalable architecture.\n\n## Requirements\n\n$ARGUMENTS\n\n## Instructions\n\n### 1. Analyze Component Requirements\n\n```typescript\ninterface ComponentSpec {\n  name: string;\n  type: 'functional' | 'page' | 'layout' | 'form' | 'data-display';\n  props: PropDefinition[];\n  state?: StateDefinition[];\n  hooks?: string[];\n  styling: 'css-modules' | 'styled-components' | 'tailwind';\n  platform: 'web' | 'native' | 'universal';\n}\n\ninterface PropDefinition {\n  name: string;\n  type: string;\n  required: boolean;\n  defaultValue?: any;\n  description: string;\n}\n\nclass ComponentAnalyzer {\n  parseRequirements(input: string): ComponentSpec {\n    // Extract component specifications from user input\n    return {\n      name: this.extractName(input),\n      type: this.inferType(input),\n      props: this.extractProps(input),\n      state: this.extractState(input),\n      hooks: this.identifyHooks(input),\n      styling: this.detectStylingApproach(),\n      platform: this.detectPlatform()\n    };\n  }\n}\n```\n\n### 2. Generate React Component\n\n```typescript\ninterface GeneratorOptions {\n  typescript: boolean;\n  testing: boolean;\n  storybook: boolean;\n  accessibility: boolean;\n}\n\nclass ReactComponentGenerator {\n  generate(spec: ComponentSpec, options: GeneratorOptions): ComponentFiles {\n    return {\n      component: this.generateComponent(spec, options),\n      types: options.typescript ? this.generateTypes(spec) : null,\n      styles: this.generateStyles(spec),\n      tests: options.testing ? this.generateTests(spec) : null,\n      stories: options.storybook ? this.generateStories(spec) : null,\n      index: this.generateIndex(spec)\n    };\n  }\n\n  generateComponent(spec: ComponentSpec, options: GeneratorOptions): string {\n    const imports = this.generateImports(spec, options);\n    const types = options.typescript ? this.generatePropTypes(spec) : '';\n    const component = this.generateComponentBody(spec, options);\n    const exports = this.generateExports(spec);\n\n    return `${imports}\\n\\n${types}\\n\\n${component}\\n\\n${exports}`;\n  }\n\n  generateImports(spec: ComponentSpec, options: GeneratorOptions): string {\n    const imports = [\"import React, { useState, useEffect } from 'react';\"];\n\n    if (spec.styling === 'css-modules') {\n      imports.push(`import styles from './${spec.name}.module.css';`);\n    } else if (spec.styling === 'styled-components') {\n      imports.push(\"import styled from 'styled-components';\");\n    }\n\n    if (options.accessibility) {\n      imports.push(\"import { useA11y } from '@/hooks/useA11y';\");\n    }\n\n    return imports.join('\\n');\n  }\n\n  generatePropTypes(spec: ComponentSpec): string {\n    const props = spec.props.map(p => {\n      const optional = p.required ? '' : '?';\n      const comment = p.description ? `  /** ${p.description} */\\n` : '';\n      return `${comment}  ${p.name}${optional}: ${p.type};`;\n    }).join('\\n');\n\n    return `export interface ${spec.name}Props {\\n${props}\\n}`;\n  }\n\n  generateComponentBody(spec: ComponentSpec, options: GeneratorOptions): string {\n    const propsType = options.typescript ? `: React.FC<${spec.name}Props>` : '';\n    const destructuredProps = spec.props.map(p => p.name).join(', ');\n\n    let body = `export const ${spec.name}${propsType} = ({ ${destructuredProps} }) => {\\n`;\n\n    // Add state hooks\n    if (spec.state) {\n      body += spec.state.map(s =>\n        `  const [${s.name}, set${this.capitalize(s.name)}] = useState${options.typescript ? `<${s.type}>` : ''}(${s.initial});\\n`\n      ).join('');\n      body += '\\n';\n    }\n\n    // Add effects\n    if (spec.hooks?.includes('useEffect')) {\n      body += `  useEffect(() => {\\n`;\n      body += `    // TODO: Add effect logic\\n`;\n      body += `  }, [${destructuredProps}]);\\n\\n`;\n    }\n\n    // Add accessibility\n    if (options.accessibility) {\n      body += `  const a11yProps = useA11y({\\n`;\n      body += `    role: '${this.inferAriaRole(spec.type)}',\\n`;\n      body += `    label: ${spec.props.find(p => p.name === 'label')?.name || `'${spec.name}'`}\\n`;\n      body += `  });\\n\\n`;\n    }\n\n    // JSX return\n    body += `  return (\\n`;\n    body += this.generateJSX(spec, options);\n    body += `  );\\n`;\n    body += `};`;\n\n    return body;\n  }\n\n  generateJSX(spec: ComponentSpec, options: GeneratorOptions): string {\n    const className = spec.styling === 'css-modules' ? `className={styles.${this.camelCase(spec.name)}}` : '';\n    const a11y = options.accessibility ? '{...a11yProps}' : '';\n\n    return `    <div ${className} ${a11y}>\\n` +\n           `      {/* TODO: Add component content */}\\n` +\n           `    </div>\\n`;\n  }\n}\n```\n\n### 3. Generate React Native Component\n\n```typescript\nclass ReactNativeGenerator {\n  generateComponent(spec: ComponentSpec): string {\n    return `\nimport React, { useState } from 'react';\nimport {\n  View,\n  Text,\n  StyleSheet,\n  TouchableOpacity,\n  AccessibilityInfo\n} from 'react-native';\n\ninterface ${spec.name}Props {\n${spec.props.map(p => `  ${p.name}${p.required ? '' : '?'}: ${this.mapNativeType(p.type)};`).join('\\n')}\n}\n\nexport const ${spec.name}: React.FC<${spec.name}Props> = ({\n  ${spec.props.map(p => p.name).join(',\\n  ')}\n}) => {\n  return (\n    <View\n      style={styles.container}\n      accessible={true}\n      accessibilityLabel=\"${spec.name} component\"\n    >\n      <Text style={styles.text}>\n        {/* Component content */}\n      </Text>\n    </View>\n  );\n};\n\nconst styles = StyleSheet.create({\n  container: {\n    flex: 1,\n    padding: 16,\n    backgroundColor: '#fff',\n  },\n  text: {\n    fontSize: 16,\n    color: '#333',\n  },\n});\n`;\n  }\n\n  mapNativeType(webType: string): string {\n    const typeMap: Record<string, string> = {\n      'string': 'string',\n      'number': 'number',\n      'boolean': 'boolean',\n      'React.ReactNode': 'React.ReactNode',\n      'Function': '() => void'\n    };\n    return typeMap[webType] || webType;\n  }\n}\n```\n\n### 4. Generate Component Tests\n\n```typescript\nclass ComponentTestGenerator {\n  generateTests(spec: ComponentSpec): string {\n    return `\nimport { render, screen, fireEvent } from '@testing-library/react';\nimport { ${spec.name} } from './${spec.name}';\n\ndescribe('${spec.name}', () => {\n  const defaultProps = {\n${spec.props.filter(p => p.required).map(p => `    ${p.name}: ${this.getMockValue(p.type)},`).join('\\n')}\n  };\n\n  it('renders without crashing', () => {\n    render(<${spec.name} {...defaultProps} />);\n    expect(screen.getByRole('${this.inferAriaRole(spec.type)}')).toBeInTheDocument();\n  });\n\n  it('displays correct content', () => {\n    render(<${spec.name} {...defaultProps} />);\n    expect(screen.getByText(/content/i)).toBeVisible();\n  });\n\n${spec.props.filter(p => p.type.includes('()') || p.name.startsWith('on')).map(p => `\n  it('calls ${p.name} when triggered', () => {\n    const mock${this.capitalize(p.name)} = jest.fn();\n    render(<${spec.name} {...defaultProps} ${p.name}={mock${this.capitalize(p.name)}} />);\n\n    const trigger = screen.getByRole('button');\n    fireEvent.click(trigger);\n\n    expect(mock${this.capitalize(p.name)}).toHaveBeenCalledTimes(1);\n  });`).join('\\n')}\n\n  it('meets accessibility standards', async () => {\n    const { container } = render(<${spec.name} {...defaultProps} />);\n    const results = await axe(container);\n    expect(results).toHaveNoViolations();\n  });\n});\n`;\n  }\n\n  getMockValue(type: string): string {\n    if (type === 'string') return \"'test value'\";\n    if (type === 'number') return '42';\n    if (type === 'boolean') return 'true';\n    if (type.includes('[]')) return '[]';\n    if (type.includes('()')) return 'jest.fn()';\n    return '{}';\n  }\n}\n```\n\n### 5. Generate Styles\n\n```typescript\nclass StyleGenerator {\n  generateCSSModule(spec: ComponentSpec): string {\n    const className = this.camelCase(spec.name);\n    return `\n.${className} {\n  display: flex;\n  flex-direction: column;\n  padding: 1rem;\n  background-color: var(--bg-primary);\n}\n\n.${className}Title {\n  font-size: 1.5rem;\n  font-weight: 600;\n  color: var(--text-primary);\n  margin-bottom: 0.5rem;\n}\n\n.${className}Content {\n  flex: 1;\n  color: var(--text-secondary);\n}\n`;\n  }\n\n  generateStyledComponents(spec: ComponentSpec): string {\n    return `\nimport styled from 'styled-components';\n\nexport const ${spec.name}Container = styled.div\\`\n  display: flex;\n  flex-direction: column;\n  padding: \\${({ theme }) => theme.spacing.md};\n  background-color: \\${({ theme }) => theme.colors.background};\n\\`;\n\nexport const ${spec.name}Title = styled.h2\\`\n  font-size: \\${({ theme }) => theme.fontSize.lg};\n  font-weight: 600;\n  color: \\${({ theme }) => theme.colors.text.primary};\n  margin-bottom: \\${({ theme }) => theme.spacing.sm};\n\\`;\n`;\n  }\n\n  generateTailwind(spec: ComponentSpec): string {\n    return `\n// Use these Tailwind classes in your component:\n// Container: \"flex flex-col p-4 bg-white rounded-lg shadow\"\n// Title: \"text-xl font-semibold text-gray-900 mb-2\"\n// Content: \"flex-1 text-gray-700\"\n`;\n  }\n}\n```\n\n### 6. Generate Storybook Stories\n\n```typescript\nclass StorybookGenerator {\n  generateStories(spec: ComponentSpec): string {\n    return `\nimport type { Meta, StoryObj } from '@storybook/react';\nimport { ${spec.name} } from './${spec.name}';\n\nconst meta: Meta<typeof ${spec.name}> = {\n  title: 'Components/${spec.name}',\n  component: ${spec.name},\n  tags: ['autodocs'],\n  argTypes: {\n${spec.props.map(p => `    ${p.name}: { control: '${this.inferControl(p.type)}', description: '${p.description}' },`).join('\\n')}\n  },\n};\n\nexport default meta;\ntype Story = StoryObj<typeof ${spec.name}>;\n\nexport const Default: Story = {\n  args: {\n${spec.props.map(p => `    ${p.name}: ${p.defaultValue || this.getMockValue(p.type)},`).join('\\n')}\n  },\n};\n\nexport const Interactive: Story = {\n  args: {\n    ...Default.args,\n  },\n};\n`;\n  }\n\n  inferControl(type: string): string {\n    if (type === 'string') return 'text';\n    if (type === 'number') return 'number';\n    if (type === 'boolean') return 'boolean';\n    if (type.includes('[]')) return 'object';\n    return 'text';\n  }\n}\n```\n\n## Output Format\n\n1. **Component File**: Fully implemented React/React Native component\n2. **Type Definitions**: TypeScript interfaces and types\n3. **Styles**: CSS modules, styled-components, or Tailwind config\n4. **Tests**: Complete test suite with coverage\n5. **Stories**: Storybook stories for documentation\n6. **Index File**: Barrel exports for clean imports\n\nFocus on creating production-ready, accessible, and maintainable components that follow modern React patterns and best practices.\n"
}