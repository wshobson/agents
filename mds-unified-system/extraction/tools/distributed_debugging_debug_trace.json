{
  "id": "distributed_debugging_debug_trace",
  "name": "Debug and Trace Configuration",
  "source": "distributed-debugging",
  "originalPath": "plugins/distributed-debugging/commands/debug-trace.md",
  "command": "/distributed-debugging:debug-trace",
  "parameters": {},
  "outputs": {},
  "agentsUsing": [],
  "fullDefinition": "# Debug and Trace Configuration\n\nYou are a debugging expert specializing in setting up comprehensive debugging environments, distributed tracing, and diagnostic tools. Configure debugging workflows, implement tracing solutions, and establish troubleshooting practices for development and production environments.\n\n## Context\nThe user needs to set up debugging and tracing capabilities to efficiently diagnose issues, track down bugs, and understand system behavior. Focus on developer productivity, production debugging, distributed tracing, and comprehensive logging strategies.\n\n## Requirements\n$ARGUMENTS\n\n## Instructions\n\n### 1. Development Environment Debugging\n\nSet up comprehensive debugging environments:\n\n**VS Code Debug Configuration**\n```json\n// .vscode/launch.json\n{\n    \"version\": \"0.2.0\",\n    \"configurations\": [\n        {\n            \"name\": \"Debug Node.js App\",\n            \"type\": \"node\",\n            \"request\": \"launch\",\n            \"runtimeExecutable\": \"node\",\n            \"runtimeArgs\": [\"--inspect-brk\", \"--enable-source-maps\"],\n            \"program\": \"${workspaceFolder}/src/index.js\",\n            \"env\": {\n                \"NODE_ENV\": \"development\",\n                \"DEBUG\": \"*\",\n                \"NODE_OPTIONS\": \"--max-old-space-size=4096\"\n            },\n            \"sourceMaps\": true,\n            \"resolveSourceMapLocations\": [\n                \"${workspaceFolder}/**\",\n                \"!**/node_modules/**\"\n            ],\n            \"skipFiles\": [\n                \"<node_internals>/**\",\n                \"node_modules/**\"\n            ],\n            \"console\": \"integratedTerminal\",\n            \"outputCapture\": \"std\"\n        },\n        {\n            \"name\": \"Debug TypeScript\",\n            \"type\": \"node\",\n            \"request\": \"launch\",\n            \"program\": \"${workspaceFolder}/src/index.ts\",\n            \"preLaunchTask\": \"tsc: build - tsconfig.json\",\n            \"outFiles\": [\"${workspaceFolder}/dist/**/*.js\"],\n            \"sourceMaps\": true,\n            \"smartStep\": true,\n            \"internalConsoleOptions\": \"openOnSessionStart\"\n        },\n        {\n            \"name\": \"Debug Jest Tests\",\n            \"type\": \"node\",\n            \"request\": \"launch\",\n            \"program\": \"${workspaceFolder}/node_modules/.bin/jest\",\n            \"args\": [\n                \"--runInBand\",\n                \"--no-cache\",\n                \"--watchAll=false\",\n                \"--detectOpenHandles\"\n            ],\n            \"console\": \"integratedTerminal\",\n            \"internalConsoleOptions\": \"neverOpen\",\n            \"env\": {\n                \"NODE_ENV\": \"test\"\n            }\n        },\n        {\n            \"name\": \"Attach to Process\",\n            \"type\": \"node\",\n            \"request\": \"attach\",\n            \"processId\": \"${command:PickProcess}\",\n            \"protocol\": \"inspector\",\n            \"restart\": true,\n            \"sourceMaps\": true\n        }\n    ],\n    \"compounds\": [\n        {\n            \"name\": \"Full Stack Debug\",\n            \"configurations\": [\"Debug Backend\", \"Debug Frontend\"],\n            \"stopAll\": true\n        }\n    ]\n}\n```\n\n**Chrome DevTools Configuration**\n```javascript\n// debug-helpers.js\nclass DebugHelper {\n    constructor() {\n        this.setupDevTools();\n        this.setupConsoleHelpers();\n        this.setupPerformanceMarkers();\n    }\n    \n    setupDevTools() {\n        if (typeof window !== 'undefined') {\n            // Add debug namespace\n            window.DEBUG = window.DEBUG || {};\n            \n            // Store references to important objects\n            window.DEBUG.store = () => window.__REDUX_STORE__;\n            window.DEBUG.router = () => window.__ROUTER__;\n            window.DEBUG.components = new Map();\n            \n            // Performance debugging\n            window.DEBUG.measureRender = (componentName) => {\n                performance.mark(`${componentName}-start`);\n                return () => {\n                    performance.mark(`${componentName}-end`);\n                    performance.measure(\n                        componentName,\n                        `${componentName}-start`,\n                        `${componentName}-end`\n                    );\n                };\n            };\n            \n            // Memory debugging\n            window.DEBUG.heapSnapshot = async () => {\n                if ('memory' in performance) {\n                    const snapshot = await performance.measureUserAgentSpecificMemory();\n                    console.table(snapshot);\n                    return snapshot;\n                }\n            };\n        }\n    }\n    \n    setupConsoleHelpers() {\n        // Enhanced console logging\n        const styles = {\n            error: 'color: #ff0000; font-weight: bold;',\n            warn: 'color: #ff9800; font-weight: bold;',\n            info: 'color: #2196f3; font-weight: bold;',\n            debug: 'color: #4caf50; font-weight: bold;',\n            trace: 'color: #9c27b0; font-weight: bold;'\n        };\n        \n        Object.entries(styles).forEach(([level, style]) => {\n            const original = console[level];\n            console[level] = function(...args) {\n                if (process.env.NODE_ENV === 'development') {\n                    const timestamp = new Date().toISOString();\n                    original.call(console, `%c[${timestamp}] ${level.toUpperCase()}:`, style, ...args);\n                }\n            };\n        });\n    }\n}\n\n// React DevTools integration\nif (process.env.NODE_ENV === 'development') {\n    // Expose React internals\n    window.__REACT_DEVTOOLS_GLOBAL_HOOK__ = {\n        ...window.__REACT_DEVTOOLS_GLOBAL_HOOK__,\n        onCommitFiberRoot: (id, root) => {\n            // Custom commit logging\n            console.debug('React commit:', root);\n        }\n    };\n}\n```\n\n### 2. Remote Debugging Setup\n\nConfigure remote debugging capabilities:\n\n**Remote Debug Server**\n```javascript\n// remote-debug-server.js\nconst inspector = require('inspector');\nconst WebSocket = require('ws');\nconst http = require('http');\n\nclass RemoteDebugServer {\n    constructor(options = {}) {\n        this.port = options.port || 9229;\n        this.host = options.host || '0.0.0.0';\n        this.wsPort = options.wsPort || 9230;\n        this.sessions = new Map();\n    }\n    \n    start() {\n        // Open inspector\n        inspector.open(this.port, this.host, true);\n        \n        // Create WebSocket server for remote connections\n        this.wss = new WebSocket.Server({ port: this.wsPort });\n        \n        this.wss.on('connection', (ws) => {\n            const sessionId = this.generateSessionId();\n            this.sessions.set(sessionId, ws);\n            \n            ws.on('message', (message) => {\n                this.handleDebugCommand(sessionId, message);\n            });\n            \n            ws.on('close', () => {\n                this.sessions.delete(sessionId);\n            });\n            \n            // Send initial session info\n            ws.send(JSON.stringify({\n                type: 'session',\n                sessionId,\n                debugUrl: `chrome-devtools://devtools/bundled/inspector.html?ws=${this.host}:${this.port}`\n            }));\n        });\n        \n        console.log(`Remote debug server listening on ws://${this.host}:${this.wsPort}`);\n    }\n    \n    handleDebugCommand(sessionId, message) {\n        const command = JSON.parse(message);\n        \n        switch (command.type) {\n            case 'evaluate':\n                this.evaluateExpression(sessionId, command.expression);\n                break;\n            case 'setBreakpoint':\n                this.setBreakpoint(command.file, command.line);\n                break;\n            case 'heapSnapshot':\n                this.takeHeapSnapshot(sessionId);\n                break;\n            case 'profile':\n                this.startProfiling(sessionId, command.duration);\n                break;\n        }\n    }\n    \n    evaluateExpression(sessionId, expression) {\n        const session = new inspector.Session();\n        session.connect();\n        \n        session.post('Runtime.evaluate', {\n            expression,\n            generatePreview: true,\n            includeCommandLineAPI: true\n        }, (error, result) => {\n            const ws = this.sessions.get(sessionId);\n            if (ws) {\n                ws.send(JSON.stringify({\n                    type: 'evaluateResult',\n                    result: result || error\n                }));\n            }\n        });\n        \n        session.disconnect();\n    }\n}\n\n// Docker remote debugging setup\nFROM node:18\nRUN apt-get update && apt-get install -y \\\n    chromium \\\n    gdb \\\n    strace \\\n    tcpdump \\\n    vim\n    \nEXPOSE 9229 9230\nENV NODE_OPTIONS=\"--inspect=0.0.0.0:9229\"\nCMD [\"node\", \"--inspect-brk=0.0.0.0:9229\", \"index.js\"]\n```\n\n### 3. Distributed Tracing\n\nImplement comprehensive distributed tracing:\n\n**OpenTelemetry Setup**\n```javascript\n// tracing.js\nconst { NodeSDK } = require('@opentelemetry/sdk-node');\nconst { getNodeAutoInstrumentations } = require('@opentelemetry/auto-instrumentations-node');\nconst { Resource } = require('@opentelemetry/resources');\nconst { SemanticResourceAttributes } = require('@opentelemetry/semantic-conventions');\nconst { JaegerExporter } = require('@opentelemetry/exporter-jaeger');\nconst { BatchSpanProcessor } = require('@opentelemetry/sdk-trace-base');\n\nclass TracingSystem {\n    constructor(serviceName) {\n        this.serviceName = serviceName;\n        this.sdk = null;\n    }\n    \n    initialize() {\n        const jaegerExporter = new JaegerExporter({\n            endpoint: process.env.JAEGER_ENDPOINT || 'http://localhost:14268/api/traces',\n        });\n        \n        const resource = Resource.default().merge(\n            new Resource({\n                [SemanticResourceAttributes.SERVICE_NAME]: this.serviceName,\n                [SemanticResourceAttributes.SERVICE_VERSION]: process.env.SERVICE_VERSION || '1.0.0',\n                [SemanticResourceAttributes.DEPLOYMENT_ENVIRONMENT]: process.env.NODE_ENV || 'development',\n            })\n        );\n        \n        this.sdk = new NodeSDK({\n            resource,\n            spanProcessor: new BatchSpanProcessor(jaegerExporter),\n            instrumentations: [\n                getNodeAutoInstrumentations({\n                    '@opentelemetry/instrumentation-fs': {\n                        enabled: false, // Too noisy\n                    },\n                    '@opentelemetry/instrumentation-http': {\n                        requestHook: (span, request) => {\n                            span.setAttribute('http.request.body', JSON.stringify(request.body));\n                        },\n                        responseHook: (span, response) => {\n                            span.setAttribute('http.response.size', response.length);\n                        },\n                    },\n                    '@opentelemetry/instrumentation-express': {\n                        requestHook: (span, req) => {\n                            span.setAttribute('user.id', req.user?.id);\n                            span.setAttribute('session.id', req.session?.id);\n                        },\n                    },\n                }),\n            ],\n        });\n        \n        this.sdk.start();\n        \n        // Graceful shutdown\n        process.on('SIGTERM', () => {\n            this.sdk.shutdown()\n                .then(() => console.log('Tracing terminated'))\n                .catch((error) => console.error('Error terminating tracing', error))\n                .finally(() => process.exit(0));\n        });\n    }\n    \n    // Custom span creation\n    createSpan(name, fn, attributes = {}) {\n        const tracer = trace.getTracer(this.serviceName);\n        return tracer.startActiveSpan(name, async (span) => {\n            try {\n                // Add custom attributes\n                Object.entries(attributes).forEach(([key, value]) => {\n                    span.setAttribute(key, value);\n                });\n                \n                // Execute function\n                const result = await fn(span);\n                \n                span.setStatus({ code: SpanStatusCode.OK });\n                return result;\n            } catch (error) {\n                span.recordException(error);\n                span.setStatus({\n                    code: SpanStatusCode.ERROR,\n                    message: error.message,\n                });\n                throw error;\n            } finally {\n                span.end();\n            }\n        });\n    }\n}\n\n// Distributed tracing middleware\nclass TracingMiddleware {\n    constructor() {\n        this.tracer = trace.getTracer('http-middleware');\n    }\n    \n    express() {\n        return (req, res, next) => {\n            const span = this.tracer.startSpan(`${req.method} ${req.path}`, {\n                kind: SpanKind.SERVER,\n                attributes: {\n                    'http.method': req.method,\n                    'http.url': req.url,\n                    'http.target': req.path,\n                    'http.host': req.hostname,\n                    'http.scheme': req.protocol,\n                    'http.user_agent': req.get('user-agent'),\n                    'http.request_content_length': req.get('content-length'),\n                },\n            });\n            \n            // Inject trace context into request\n            req.span = span;\n            req.traceId = span.spanContext().traceId;\n            \n            // Add trace ID to response headers\n            res.setHeader('X-Trace-Id', req.traceId);\n            \n            // Override res.end to capture response data\n            const originalEnd = res.end;\n            res.end = function(...args) {\n                span.setAttribute('http.status_code', res.statusCode);\n                span.setAttribute('http.response_content_length', res.get('content-length'));\n                \n                if (res.statusCode >= 400) {\n                    span.setStatus({\n                        code: SpanStatusCode.ERROR,\n                        message: `HTTP ${res.statusCode}`,\n                    });\n                }\n                \n                span.end();\n                originalEnd.apply(res, args);\n            };\n            \n            next();\n        };\n    }\n}\n```\n\n### 4. Debug Logging Framework\n\nImplement structured debug logging:\n\n**Advanced Logger**\n```javascript\n// debug-logger.js\nconst winston = require('winston');\nconst { ElasticsearchTransport } = require('winston-elasticsearch');\n\nclass DebugLogger {\n    constructor(options = {}) {\n        this.service = options.service || 'app';\n        this.level = process.env.LOG_LEVEL || 'debug';\n        this.logger = this.createLogger();\n    }\n    \n    createLogger() {\n        const formats = [\n            winston.format.timestamp(),\n            winston.format.errors({ stack: true }),\n            winston.format.splat(),\n            winston.format.json(),\n        ];\n        \n        if (process.env.NODE_ENV === 'development') {\n            formats.push(winston.format.colorize());\n            formats.push(winston.format.printf(this.devFormat));\n        }\n        \n        const transports = [\n            new winston.transports.Console({\n                level: this.level,\n                handleExceptions: true,\n                handleRejections: true,\n            }),\n        ];\n        \n        // Add file transport for debugging\n        if (process.env.DEBUG_LOG_FILE) {\n            transports.push(\n                new winston.transports.File({\n                    filename: process.env.DEBUG_LOG_FILE,\n                    level: 'debug',\n                    maxsize: 10485760, // 10MB\n                    maxFiles: 5,\n                })\n            );\n        }\n        \n        // Add Elasticsearch for production\n        if (process.env.ELASTICSEARCH_URL) {\n            transports.push(\n                new ElasticsearchTransport({\n                    level: 'info',\n                    clientOpts: {\n                        node: process.env.ELASTICSEARCH_URL,\n                    },\n                    index: `logs-${this.service}`,\n                })\n            );\n        }\n        \n        return winston.createLogger({\n            level: this.level,\n            format: winston.format.combine(...formats),\n            defaultMeta: {\n                service: this.service,\n                environment: process.env.NODE_ENV,\n                hostname: require('os').hostname(),\n                pid: process.pid,\n            },\n            transports,\n        });\n    }\n    \n    devFormat(info) {\n        const { timestamp, level, message, ...meta } = info;\n        const metaString = Object.keys(meta).length ? \n            '\\n' + JSON.stringify(meta, null, 2) : '';\n        \n        return `${timestamp} [${level}]: ${message}${metaString}`;\n    }\n    \n    // Debug-specific methods\n    trace(message, meta = {}) {\n        const stack = new Error().stack;\n        this.logger.debug(message, {\n            ...meta,\n            trace: stack,\n            timestamp: Date.now(),\n        });\n    }\n    \n    timing(label, fn) {\n        const start = process.hrtime.bigint();\n        const result = fn();\n        const end = process.hrtime.bigint();\n        const duration = Number(end - start) / 1000000; // Convert to ms\n        \n        this.logger.debug(`Timing: ${label}`, {\n            duration,\n            unit: 'ms',\n        });\n        \n        return result;\n    }\n    \n    memory() {\n        const usage = process.memoryUsage();\n        this.logger.debug('Memory usage', {\n            rss: `${Math.round(usage.rss / 1024 / 1024)}MB`,\n            heapTotal: `${Math.round(usage.heapTotal / 1024 / 1024)}MB`,\n            heapUsed: `${Math.round(usage.heapUsed / 1024 / 1024)}MB`,\n            external: `${Math.round(usage.external / 1024 / 1024)}MB`,\n        });\n    }\n}\n\n// Debug context manager\nclass DebugContext {\n    constructor() {\n        this.contexts = new Map();\n    }\n    \n    create(id, metadata = {}) {\n        const context = {\n            id,\n            startTime: Date.now(),\n            metadata,\n            logs: [],\n            spans: [],\n        };\n        \n        this.contexts.set(id, context);\n        return context;\n    }\n    \n    log(contextId, level, message, data = {}) {\n        const context = this.contexts.get(contextId);\n        if (context) {\n            context.logs.push({\n                timestamp: Date.now(),\n                level,\n                message,\n                data,\n            });\n        }\n    }\n    \n    export(contextId) {\n        const context = this.contexts.get(contextId);\n        if (!context) return null;\n        \n        return {\n            ...context,\n            duration: Date.now() - context.startTime,\n            logCount: context.logs.length,\n        };\n    }\n}\n```\n\n### 5. Source Map Configuration\n\nSet up source map support for production debugging:\n\n**Source Map Setup**\n```javascript\n// webpack.config.js\nmodule.exports = {\n    mode: 'production',\n    devtool: 'hidden-source-map', // Generate source maps but don't reference them\n    \n    output: {\n        filename: '[name].[contenthash].js',\n        sourceMapFilename: 'sourcemaps/[name].[contenthash].js.map',\n    },\n    \n    plugins: [\n        // Upload source maps to error tracking service\n        new SentryWebpackPlugin({\n            authToken: process.env.SENTRY_AUTH_TOKEN,\n            org: 'your-org',\n            project: 'your-project',\n            include: './dist',\n            ignore: ['node_modules'],\n            urlPrefix: '~/',\n            release: process.env.RELEASE_VERSION,\n            deleteAfterCompile: true,\n        }),\n    ],\n};\n\n// Runtime source map support\nrequire('source-map-support').install({\n    environment: 'node',\n    handleUncaughtExceptions: false,\n    retrieveSourceMap(source) {\n        // Custom source map retrieval for production\n        if (process.env.NODE_ENV === 'production') {\n            const sourceMapUrl = getSourceMapUrl(source);\n            if (sourceMapUrl) {\n                const map = fetchSourceMap(sourceMapUrl);\n                return {\n                    url: source,\n                    map: map,\n                };\n            }\n        }\n        return null;\n    },\n});\n\n// Stack trace enhancement\nError.prepareStackTrace = (error, stack) => {\n    const mapped = stack.map(frame => {\n        const fileName = frame.getFileName();\n        const lineNumber = frame.getLineNumber();\n        const columnNumber = frame.getColumnNumber();\n        \n        // Try to get original position\n        const original = getOriginalPosition(fileName, lineNumber, columnNumber);\n        \n        return {\n            function: frame.getFunctionName() || '<anonymous>',\n            file: original?.source || fileName,\n            line: original?.line || lineNumber,\n            column: original?.column || columnNumber,\n            native: frame.isNative(),\n            async: frame.isAsync(),\n        };\n    });\n    \n    return {\n        message: error.message,\n        stack: mapped,\n    };\n};\n```\n\n### 6. Performance Profiling\n\nImplement performance profiling tools:\n\n**Performance Profiler**\n```javascript\n// performance-profiler.js\nconst v8Profiler = require('v8-profiler-next');\nconst fs = require('fs');\nconst path = require('path');\n\nclass PerformanceProfiler {\n    constructor(options = {}) {\n        this.outputDir = options.outputDir || './profiles';\n        this.profiles = new Map();\n        \n        // Ensure output directory exists\n        if (!fs.existsSync(this.outputDir)) {\n            fs.mkdirSync(this.outputDir, { recursive: true });\n        }\n    }\n    \n    startCPUProfile(id, options = {}) {\n        const title = options.title || `cpu-profile-${id}`;\n        v8Profiler.startProfiling(title, true);\n        \n        this.profiles.set(id, {\n            type: 'cpu',\n            title,\n            startTime: Date.now(),\n        });\n        \n        return id;\n    }\n    \n    stopCPUProfile(id) {\n        const profileInfo = this.profiles.get(id);\n        if (!profileInfo || profileInfo.type !== 'cpu') {\n            throw new Error(`CPU profile ${id} not found`);\n        }\n        \n        const profile = v8Profiler.stopProfiling(profileInfo.title);\n        const duration = Date.now() - profileInfo.startTime;\n        \n        // Export profile\n        const fileName = `${profileInfo.title}-${Date.now()}.cpuprofile`;\n        const filePath = path.join(this.outputDir, fileName);\n        \n        profile.export((error, result) => {\n            if (!error) {\n                fs.writeFileSync(filePath, result);\n                console.log(`CPU profile saved to ${filePath}`);\n            }\n            profile.delete();\n        });\n        \n        this.profiles.delete(id);\n        \n        return {\n            id,\n            duration,\n            filePath,\n        };\n    }\n    \n    takeHeapSnapshot(tag = '') {\n        const fileName = `heap-${tag}-${Date.now()}.heapsnapshot`;\n        const filePath = path.join(this.outputDir, fileName);\n        \n        const snapshot = v8Profiler.takeSnapshot();\n        \n        // Export snapshot\n        snapshot.export((error, result) => {\n            if (!error) {\n                fs.writeFileSync(filePath, result);\n                console.log(`Heap snapshot saved to ${filePath}`);\n            }\n            snapshot.delete();\n        });\n        \n        return filePath;\n    }\n    \n    measureFunction(fn, name = 'anonymous') {\n        const measurements = {\n            name,\n            executions: 0,\n            totalTime: 0,\n            minTime: Infinity,\n            maxTime: 0,\n            avgTime: 0,\n            lastExecution: null,\n        };\n        \n        return new Proxy(fn, {\n            apply(target, thisArg, args) {\n                const start = process.hrtime.bigint();\n                \n                try {\n                    const result = target.apply(thisArg, args);\n                    \n                    if (result instanceof Promise) {\n                        return result.finally(() => {\n                            this.recordExecution(start);\n                        });\n                    }\n                    \n                    this.recordExecution(start);\n                    return result;\n                } catch (error) {\n                    this.recordExecution(start);\n                    throw error;\n                }\n            },\n            \n            recordExecution(start) {\n                const end = process.hrtime.bigint();\n                const duration = Number(end - start) / 1000000; // Convert to ms\n                \n                measurements.executions++;\n                measurements.totalTime += duration;\n                measurements.minTime = Math.min(measurements.minTime, duration);\n                measurements.maxTime = Math.max(measurements.maxTime, duration);\n                measurements.avgTime = measurements.totalTime / measurements.executions;\n                measurements.lastExecution = new Date();\n                \n                // Log slow executions\n                if (duration > 100) {\n                    console.warn(`Slow function execution: ${name} took ${duration}ms`);\n                }\n            },\n            \n            get(target, prop) {\n                if (prop === 'measurements') {\n                    return measurements;\n                }\n                return target[prop];\n            },\n        });\n    }\n}\n\n// Memory leak detector\nclass MemoryLeakDetector {\n    constructor() {\n        this.snapshots = [];\n        this.threshold = 50 * 1024 * 1024; // 50MB\n    }\n    \n    start(interval = 60000) {\n        this.interval = setInterval(() => {\n            this.checkMemory();\n        }, interval);\n    }\n    \n    checkMemory() {\n        const usage = process.memoryUsage();\n        const snapshot = {\n            timestamp: Date.now(),\n            heapUsed: usage.heapUsed,\n            external: usage.external,\n            rss: usage.rss,\n        };\n        \n        this.snapshots.push(snapshot);\n        \n        // Keep only last 10 snapshots\n        if (this.snapshots.length > 10) {\n            this.snapshots.shift();\n        }\n        \n        // Check for memory leak pattern\n        if (this.snapshots.length >= 5) {\n            const trend = this.calculateTrend();\n            if (trend.increasing && trend.delta > this.threshold) {\n                console.error('Potential memory leak detected!', {\n                    trend,\n                    current: snapshot,\n                });\n                \n                // Take heap snapshot for analysis\n                const profiler = new PerformanceProfiler();\n                profiler.takeHeapSnapshot('leak-detection');\n            }\n        }\n    }\n    \n    calculateTrend() {\n        const recent = this.snapshots.slice(-5);\n        const first = recent[0];\n        const last = recent[recent.length - 1];\n        \n        const delta = last.heapUsed - first.heapUsed;\n        const increasing = recent.every((s, i) => \n            i === 0 || s.heapUsed > recent[i - 1].heapUsed\n        );\n        \n        return {\n            increasing,\n            delta,\n            rate: delta / (last.timestamp - first.timestamp) * 1000 * 60, // MB per minute\n        };\n    }\n}\n```\n\n### 7. Debug Configuration Management\n\nCentralize debug configurations:\n\n**Debug Configuration**\n```javascript\n// debug-config.js\nclass DebugConfiguration {\n    constructor() {\n        this.config = {\n            // Debug levels\n            levels: {\n                error: 0,\n                warn: 1,\n                info: 2,\n                debug: 3,\n                trace: 4,\n            },\n            \n            // Feature flags\n            features: {\n                remoteDebugging: process.env.ENABLE_REMOTE_DEBUG === 'true',\n                tracing: process.env.ENABLE_TRACING === 'true',\n                profiling: process.env.ENABLE_PROFILING === 'true',\n                memoryMonitoring: process.env.ENABLE_MEMORY_MONITORING === 'true',\n            },\n            \n            // Debug endpoints\n            endpoints: {\n                jaeger: process.env.JAEGER_ENDPOINT || 'http://localhost:14268',\n                elasticsearch: process.env.ELASTICSEARCH_URL || 'http://localhost:9200',\n                sentry: process.env.SENTRY_DSN,\n            },\n            \n            // Sampling rates\n            sampling: {\n                traces: parseFloat(process.env.TRACE_SAMPLING_RATE || '0.1'),\n                profiles: parseFloat(process.env.PROFILE_SAMPLING_RATE || '0.01'),\n                logs: parseFloat(process.env.LOG_SAMPLING_RATE || '1.0'),\n            },\n        };\n    }\n    \n    isEnabled(feature) {\n        return this.config.features[feature] || false;\n    }\n    \n    getLevel() {\n        const level = process.env.DEBUG_LEVEL || 'info';\n        return this.config.levels[level] || 2;\n    }\n    \n    shouldSample(type) {\n        const rate = this.config.sampling[type] || 1.0;\n        return Math.random() < rate;\n    }\n}\n\n// Debug middleware factory\nclass DebugMiddlewareFactory {\n    static create(app, config) {\n        const middlewares = [];\n        \n        if (config.isEnabled('tracing')) {\n            const tracingMiddleware = new TracingMiddleware();\n            middlewares.push(tracingMiddleware.express());\n        }\n        \n        if (config.isEnabled('profiling')) {\n            middlewares.push(this.profilingMiddleware());\n        }\n        \n        if (config.isEnabled('memoryMonitoring')) {\n            const detector = new MemoryLeakDetector();\n            detector.start();\n        }\n        \n        // Debug routes\n        if (process.env.NODE_ENV === 'development') {\n            app.get('/debug/heap', (req, res) => {\n                const profiler = new PerformanceProfiler();\n                const path = profiler.takeHeapSnapshot('manual');\n                res.json({ heapSnapshot: path });\n            });\n            \n            app.get('/debug/profile', async (req, res) => {\n                const profiler = new PerformanceProfiler();\n                const id = profiler.startCPUProfile('manual');\n                \n                setTimeout(() => {\n                    const result = profiler.stopCPUProfile(id);\n                    res.json(result);\n                }, 10000);\n            });\n            \n            app.get('/debug/metrics', (req, res) => {\n                res.json({\n                    memory: process.memoryUsage(),\n                    cpu: process.cpuUsage(),\n                    uptime: process.uptime(),\n                });\n            });\n        }\n        \n        return middlewares;\n    }\n    \n    static profilingMiddleware() {\n        const profiler = new PerformanceProfiler();\n        \n        return (req, res, next) => {\n            if (Math.random() < 0.01) { // 1% sampling\n                const id = profiler.startCPUProfile(`request-${Date.now()}`);\n                \n                res.on('finish', () => {\n                    profiler.stopCPUProfile(id);\n                });\n            }\n            \n            next();\n        };\n    }\n}\n```\n\n### 8. Production Debugging\n\nEnable safe production debugging:\n\n**Production Debug Tools**\n```javascript\n// production-debug.js\nclass ProductionDebugger {\n    constructor(options = {}) {\n        this.enabled = process.env.PRODUCTION_DEBUG === 'true';\n        this.authToken = process.env.DEBUG_AUTH_TOKEN;\n        this.allowedIPs = (process.env.DEBUG_ALLOWED_IPS || '').split(',');\n    }\n    \n    middleware() {\n        return (req, res, next) => {\n            if (!this.enabled) {\n                return next();\n            }\n            \n            // Check authorization\n            const token = req.headers['x-debug-token'];\n            const ip = req.ip || req.connection.remoteAddress;\n            \n            if (token !== this.authToken || !this.allowedIPs.includes(ip)) {\n                return next();\n            }\n            \n            // Add debug headers\n            res.setHeader('X-Debug-Enabled', 'true');\n            \n            // Enable debug mode for this request\n            req.debugMode = true;\n            req.debugContext = new DebugContext().create(req.id);\n            \n            // Override console for this request\n            const originalConsole = { ...console };\n            ['log', 'debug', 'info', 'warn', 'error'].forEach(method => {\n                console[method] = (...args) => {\n                    req.debugContext.log(req.id, method, args[0], args.slice(1));\n                    originalConsole[method](...args);\n                };\n            });\n            \n            // Restore console on response\n            res.on('finish', () => {\n                Object.assign(console, originalConsole);\n                \n                // Send debug info if requested\n                if (req.headers['x-debug-response'] === 'true') {\n                    const debugInfo = req.debugContext.export(req.id);\n                    res.setHeader('X-Debug-Info', JSON.stringify(debugInfo));\n                }\n            });\n            \n            next();\n        };\n    }\n}\n\n// Conditional breakpoints in production\nclass ConditionalBreakpoint {\n    constructor(condition, callback) {\n        this.condition = condition;\n        this.callback = callback;\n        this.hits = 0;\n    }\n    \n    check(context) {\n        if (this.condition(context)) {\n            this.hits++;\n            \n            // Log breakpoint hit\n            console.debug('Conditional breakpoint hit', {\n                condition: this.condition.toString(),\n                hits: this.hits,\n                context,\n            });\n            \n            // Execute callback\n            if (this.callback) {\n                this.callback(context);\n            }\n            \n            // In production, don't actually break\n            if (process.env.NODE_ENV === 'production') {\n                // Take snapshot instead\n                const profiler = new PerformanceProfiler();\n                profiler.takeHeapSnapshot(`breakpoint-${Date.now()}`);\n            } else {\n                // In development, use debugger\n                debugger;\n            }\n        }\n    }\n}\n\n// Usage\nconst breakpoints = new Map();\n\n// Set conditional breakpoint\nbreakpoints.set('high-memory', new ConditionalBreakpoint(\n    (context) => context.memoryUsage > 500 * 1024 * 1024, // 500MB\n    (context) => {\n        console.error('High memory usage detected', context);\n        // Send alert\n        alerting.send('high-memory', context);\n    }\n));\n\n// Check breakpoints in code\nfunction checkBreakpoints(context) {\n    breakpoints.forEach(breakpoint => {\n        breakpoint.check(context);\n    });\n}\n```\n\n### 9. Debug Dashboard\n\nCreate a debug dashboard for monitoring:\n\n**Debug Dashboard**\n```html\n<!-- debug-dashboard.html -->\n<!DOCTYPE html>\n<html>\n<head>\n    <title>Debug Dashboard</title>\n    <style>\n        body { font-family: monospace; background: #1e1e1e; color: #d4d4d4; }\n        .container { max-width: 1200px; margin: 0 auto; padding: 20px; }\n        .metric { background: #252526; padding: 15px; margin: 10px 0; border-radius: 5px; }\n        .metric h3 { margin: 0 0 10px 0; color: #569cd6; }\n        .chart { height: 200px; background: #1e1e1e; margin: 10px 0; }\n        .log-entry { padding: 5px; border-bottom: 1px solid #3e3e3e; }\n        .error { color: #f44747; }\n        .warn { color: #ff9800; }\n        .info { color: #4fc3f7; }\n        .debug { color: #4caf50; }\n    </style>\n</head>\n<body>\n    <div class=\"container\">\n        <h1>Debug Dashboard</h1>\n        \n        <div class=\"metric\">\n            <h3>System Metrics</h3>\n            <div id=\"metrics\"></div>\n        </div>\n        \n        <div class=\"metric\">\n            <h3>Memory Usage</h3>\n            <canvas id=\"memoryChart\" class=\"chart\"></canvas>\n        </div>\n        \n        <div class=\"metric\">\n            <h3>Request Traces</h3>\n            <div id=\"traces\"></div>\n        </div>\n        \n        <div class=\"metric\">\n            <h3>Debug Logs</h3>\n            <div id=\"logs\"></div>\n        </div>\n    </div>\n    \n    <script>\n        // WebSocket connection for real-time updates\n        const ws = new WebSocket('ws://localhost:9231/debug');\n        \n        ws.onmessage = (event) => {\n            const data = JSON.parse(event.data);\n            \n            switch (data.type) {\n                case 'metrics':\n                    updateMetrics(data.payload);\n                    break;\n                case 'trace':\n                    addTrace(data.payload);\n                    break;\n                case 'log':\n                    addLog(data.payload);\n                    break;\n            }\n        };\n        \n        function updateMetrics(metrics) {\n            const container = document.getElementById('metrics');\n            container.innerHTML = `\n                <div>CPU: ${metrics.cpu.percent}%</div>\n                <div>Memory: ${metrics.memory.used}MB / ${metrics.memory.total}MB</div>\n                <div>Uptime: ${metrics.uptime}s</div>\n                <div>Active Requests: ${metrics.activeRequests}</div>\n            `;\n        }\n        \n        function addTrace(trace) {\n            const container = document.getElementById('traces');\n            const entry = document.createElement('div');\n            entry.className = 'log-entry';\n            entry.innerHTML = `\n                <span>${trace.timestamp}</span>\n                <span>${trace.method} ${trace.path}</span>\n                <span>${trace.duration}ms</span>\n                <span>${trace.status}</span>\n            `;\n            container.insertBefore(entry, container.firstChild);\n        }\n        \n        function addLog(log) {\n            const container = document.getElementById('logs');\n            const entry = document.createElement('div');\n            entry.className = `log-entry ${log.level}`;\n            entry.innerHTML = `\n                <span>${log.timestamp}</span>\n                <span>[${log.level.toUpperCase()}]</span>\n                <span>${log.message}</span>\n            `;\n            container.insertBefore(entry, container.firstChild);\n            \n            // Keep only last 100 logs\n            while (container.children.length > 100) {\n                container.removeChild(container.lastChild);\n            }\n        }\n        \n        // Memory usage chart\n        const memoryChart = document.getElementById('memoryChart').getContext('2d');\n        const memoryData = [];\n        \n        function updateMemoryChart(usage) {\n            memoryData.push({\n                time: new Date(),\n                value: usage,\n            });\n            \n            // Keep last 50 points\n            if (memoryData.length > 50) {\n                memoryData.shift();\n            }\n            \n            // Draw chart\n            // ... chart drawing logic\n        }\n    </script>\n</body>\n</html>\n```\n\n### 10. IDE Integration\n\nConfigure IDE debugging features:\n\n**IDE Debug Extensions**\n```json\n// .vscode/extensions.json\n{\n    \"recommendations\": [\n        \"ms-vscode.vscode-js-debug\",\n        \"msjsdiag.debugger-for-chrome\",\n        \"ms-vscode.vscode-typescript-tslint-plugin\",\n        \"dbaeumer.vscode-eslint\",\n        \"ms-azuretools.vscode-docker\",\n        \"humao.rest-client\",\n        \"eamodio.gitlens\",\n        \"usernamehw.errorlens\",\n        \"wayou.vscode-todo-highlight\",\n        \"formulahendry.code-runner\"\n    ]\n}\n\n// .vscode/tasks.json\n{\n    \"version\": \"2.0.0\",\n    \"tasks\": [\n        {\n            \"label\": \"Start Debug Server\",\n            \"type\": \"npm\",\n            \"script\": \"debug\",\n            \"problemMatcher\": [],\n            \"presentation\": {\n                \"reveal\": \"always\",\n                \"panel\": \"dedicated\"\n            }\n        },\n        {\n            \"label\": \"Profile Application\",\n            \"type\": \"shell\",\n            \"command\": \"node --inspect-brk --cpu-prof --cpu-prof-dir=./profiles ${workspaceFolder}/src/index.js\",\n            \"problemMatcher\": []\n        },\n        {\n            \"label\": \"Memory Snapshot\",\n            \"type\": \"shell\",\n            \"command\": \"node --inspect --expose-gc ${workspaceFolder}/scripts/heap-snapshot.js\",\n            \"problemMatcher\": []\n        }\n    ]\n}\n```\n\n## Output Format\n\n1. **Debug Configuration**: Complete setup for all debugging tools\n2. **Integration Guide**: Step-by-step integration instructions\n3. **Troubleshooting Playbook**: Common debugging scenarios and solutions\n4. **Performance Baselines**: Metrics for comparison\n5. **Debug Scripts**: Automated debugging utilities\n6. **Dashboard Setup**: Real-time debugging interface\n7. **Documentation**: Team debugging guidelines\n8. **Emergency Procedures**: Production debugging protocols\n\nFocus on creating a comprehensive debugging environment that enhances developer productivity and enables rapid issue resolution in all environments."
}