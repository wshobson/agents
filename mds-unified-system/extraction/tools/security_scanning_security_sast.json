{
  "id": "security_scanning_security_sast",
  "name": "SAST Security Plugin",
  "source": "security-scanning",
  "originalPath": "plugins/security-scanning/commands/security-sast.md",
  "command": "/security-scanning:security-sast",
  "parameters": {},
  "outputs": {},
  "agentsUsing": [],
  "fullDefinition": "---\ndescription: Static Application Security Testing (SAST) for code vulnerability analysis across multiple languages and frameworks\nglobs: ['**/*.py', '**/*.js', '**/*.ts', '**/*.java', '**/*.rb', '**/*.go', '**/*.rs', '**/*.php']\nkeywords: [sast, static analysis, code security, vulnerability scanning, bandit, semgrep, eslint, sonarqube, codeql, security patterns, code review, ast analysis]\n---\n\n# SAST Security Plugin\n\nStatic Application Security Testing (SAST) for comprehensive code vulnerability detection across multiple languages, frameworks, and security patterns.\n\n## Capabilities\n\n- **Multi-language SAST**: Python, JavaScript/TypeScript, Java, Ruby, PHP, Go, Rust\n- **Tool integration**: Bandit, Semgrep, ESLint Security, SonarQube, CodeQL, PMD, SpotBugs, Brakeman, gosec, cargo-clippy\n- **Vulnerability patterns**: SQL injection, XSS, hardcoded secrets, path traversal, IDOR, CSRF, insecure deserialization\n- **Framework analysis**: Django, Flask, React, Express, Spring Boot, Rails, Laravel\n- **Custom rule authoring**: Semgrep pattern development for organization-specific security policies\n\n## When to Use This Tool\n\nUse for code review security analysis, injection vulnerabilities, hardcoded secrets, framework-specific patterns, custom security policy enforcement, pre-deployment validation, legacy code assessment, and compliance (OWASP, PCI-DSS, SOC2).\n\n**Specialized tools**: Use `security-secrets.md` for advanced credential scanning, `security-owasp.md` for Top 10 mapping, `security-api.md` for REST/GraphQL endpoints.\n\n## SAST Tool Selection\n\n### Python: Bandit\n\n```bash\n# Installation & scan\npip install bandit\nbandit -r . -f json -o bandit-report.json\nbandit -r . -ll -ii -f json  # High/Critical only\n```\n\n**Configuration**: `.bandit`\n```yaml\nexclude_dirs: ['/tests/', '/venv/', '/.tox/', '/build/']\ntests: [B201, B301, B302, B303, B304, B305, B307, B308, B312, B323, B324, B501, B502, B506, B602, B608]\nskips: [B101]\n```\n\n### JavaScript/TypeScript: ESLint Security\n\n```bash\nnpm install --save-dev eslint @eslint/plugin-security eslint-plugin-no-secrets\neslint . --ext .js,.jsx,.ts,.tsx --format json > eslint-security.json\n```\n\n**Configuration**: `.eslintrc-security.json`\n```json\n{\n  \"plugins\": [\"@eslint/plugin-security\", \"eslint-plugin-no-secrets\"],\n  \"extends\": [\"plugin:security/recommended\"],\n  \"rules\": {\n    \"security/detect-object-injection\": \"error\",\n    \"security/detect-non-literal-fs-filename\": \"error\",\n    \"security/detect-eval-with-expression\": \"error\",\n    \"security/detect-pseudo-random-prng\": \"error\",\n    \"no-secrets/no-secrets\": \"error\"\n  }\n}\n```\n\n### Multi-Language: Semgrep\n\n```bash\npip install semgrep\nsemgrep --config=auto --json --output=semgrep-report.json\nsemgrep --config=p/security-audit --json\nsemgrep --config=p/owasp-top-ten --json\nsemgrep ci --config=auto  # CI mode\n```\n\n**Custom Rules**: `.semgrep.yml`\n```yaml\nrules:\n  - id: sql-injection-format-string\n    pattern: cursor.execute(\"... %s ...\" % $VAR)\n    message: SQL injection via string formatting\n    severity: ERROR\n    languages: [python]\n    metadata:\n      cwe: \"CWE-89\"\n      owasp: \"A03:2021-Injection\"\n\n  - id: dangerous-innerHTML\n    pattern: $ELEM.innerHTML = $VAR\n    message: XSS via innerHTML assignment\n    severity: ERROR\n    languages: [javascript, typescript]\n    metadata:\n      cwe: \"CWE-79\"\n\n  - id: hardcoded-aws-credentials\n    patterns:\n      - pattern: $KEY = \"AKIA...\"\n      - metavariable-regex:\n          metavariable: $KEY\n          regex: \"(aws_access_key_id|AWS_ACCESS_KEY_ID)\"\n    message: Hardcoded AWS credentials detected\n    severity: ERROR\n    languages: [python, javascript, java]\n\n  - id: path-traversal-open\n    patterns:\n      - pattern: open($PATH, ...)\n      - pattern-not: open(os.path.join(SAFE_DIR, ...), ...)\n      - metavariable-pattern:\n          metavariable: $PATH\n          patterns:\n            - pattern: $REQ.get(...)\n    message: Path traversal via user input\n    severity: ERROR\n    languages: [python]\n\n  - id: command-injection\n    patterns:\n      - pattern-either:\n          - pattern: os.system($CMD)\n          - pattern: subprocess.call($CMD, shell=True)\n      - metavariable-pattern:\n          metavariable: $CMD\n          patterns:\n            - pattern-either:\n                - pattern: $X + $Y\n                - pattern: f\"...{$VAR}...\"\n    message: Command injection via shell=True\n    severity: ERROR\n    languages: [python]\n```\n\n### Other Language Tools\n\n**Java**: `mvn spotbugs:check`\n**Ruby**: `brakeman -o report.json -f json`\n**Go**: `gosec -fmt=json -out=gosec.json ./...`\n**Rust**: `cargo clippy -- -W clippy::unwrap_used`\n\n## Vulnerability Patterns\n\n### SQL Injection\n\n**VULNERABLE**: String formatting/concatenation with user input in SQL queries\n\n**SECURE**:\n```python\n# Parameterized queries\ncursor.execute(\"SELECT * FROM users WHERE id = %s\", (user_id,))\nUser.objects.filter(id=user_id)  # ORM\n```\n\n### Cross-Site Scripting (XSS)\n\n**VULNERABLE**: Direct HTML manipulation with unsanitized user input (innerHTML, outerHTML, document.write)\n\n**SECURE**:\n```javascript\n// Use textContent for plain text\nelement.textContent = userInput;\n\n// React auto-escapes\n<div>{userInput}</div>\n\n// Sanitize when HTML required\nimport DOMPurify from 'dompurify';\nelement.innerHTML = DOMPurify.sanitize(userInput);\n```\n\n### Hardcoded Secrets\n\n**VULNERABLE**: Hardcoded API keys, passwords, tokens in source code\n\n**SECURE**:\n```python\nimport os\nAPI_KEY = os.environ.get('API_KEY')\nPASSWORD = os.getenv('DB_PASSWORD')\n```\n\n### Path Traversal\n\n**VULNERABLE**: Opening files using unsanitized user input\n\n**SECURE**:\n```python\nimport os\nALLOWED_DIR = '/var/www/uploads'\nfile_name = request.args.get('file')\nfile_path = os.path.join(ALLOWED_DIR, file_name)\nfile_path = os.path.realpath(file_path)\nif not file_path.startswith(os.path.realpath(ALLOWED_DIR)):\n    raise ValueError(\"Invalid file path\")\nwith open(file_path, 'r') as f:\n    content = f.read()\n```\n\n### Insecure Deserialization\n\n**VULNERABLE**: pickle.loads(), yaml.load() with untrusted data\n\n**SECURE**:\n```python\nimport json\ndata = json.loads(user_input)  # SECURE\nimport yaml\nconfig = yaml.safe_load(user_input)  # SECURE\n```\n\n### Command Injection\n\n**VULNERABLE**: os.system() or subprocess with shell=True and user input\n\n**SECURE**:\n```python\nsubprocess.run(['ping', '-c', '4', user_input])  # Array args\nimport shlex\nsafe_input = shlex.quote(user_input)  # Input validation\n```\n\n### Insecure Random\n\n**VULNERABLE**: random module for security-critical operations\n\n**SECURE**:\n```python\nimport secrets\ntoken = secrets.token_hex(16)\nsession_id = secrets.token_urlsafe(32)\n```\n\n## Framework Security\n\n### Django\n\n**VULNERABLE**: @csrf_exempt, DEBUG=True, weak SECRET_KEY, missing security middleware\n\n**SECURE**:\n```python\n# settings.py\nDEBUG = False\nSECRET_KEY = os.environ.get('DJANGO_SECRET_KEY')\n\nMIDDLEWARE = [\n    'django.middleware.security.SecurityMiddleware',\n    'django.middleware.csrf.CsrfViewMiddleware',\n    'django.middleware.clickjacking.XFrameOptionsMiddleware',\n]\n\nSECURE_SSL_REDIRECT = True\nSESSION_COOKIE_SECURE = True\nCSRF_COOKIE_SECURE = True\nX_FRAME_OPTIONS = 'DENY'\n```\n\n### Flask\n\n**VULNERABLE**: debug=True, weak secret_key, CORS wildcard\n\n**SECURE**:\n```python\nimport os\nfrom flask_talisman import Talisman\n\napp.secret_key = os.environ.get('FLASK_SECRET_KEY')\nTalisman(app, force_https=True)\nCORS(app, origins=['https://example.com'])\n```\n\n### Express.js\n\n**VULNERABLE**: Missing helmet, CORS wildcard, no rate limiting\n\n**SECURE**:\n```javascript\nconst helmet = require('helmet');\nconst rateLimit = require('express-rate-limit');\n\napp.use(helmet());\napp.use(cors({ origin: 'https://example.com' }));\napp.use(rateLimit({ windowMs: 15 * 60 * 1000, max: 100 }));\n```\n\n## Multi-Language Scanner Implementation\n\n```python\nimport json\nimport subprocess\nfrom pathlib import Path\nfrom typing import Dict, List, Any\nfrom dataclasses import dataclass\nfrom datetime import datetime\n\n@dataclass\nclass SASTFinding:\n    tool: str\n    severity: str\n    category: str\n    title: str\n    description: str\n    file_path: str\n    line_number: int\n    cwe: str\n    owasp: str\n    confidence: str\n\nclass MultiLanguageSASTScanner:\n    def __init__(self, project_path: str):\n        self.project_path = Path(project_path)\n        self.findings: List[SASTFinding] = []\n\n    def detect_languages(self) -> List[str]:\n        \"\"\"Auto-detect languages\"\"\"\n        languages = []\n        indicators = {\n            'python': ['*.py', 'requirements.txt'],\n            'javascript': ['*.js', 'package.json'],\n            'typescript': ['*.ts', 'tsconfig.json'],\n            'java': ['*.java', 'pom.xml'],\n            'ruby': ['*.rb', 'Gemfile'],\n            'go': ['*.go', 'go.mod'],\n            'rust': ['*.rs', 'Cargo.toml'],\n        }\n        for lang, patterns in indicators.items():\n            for pattern in patterns:\n                if list(self.project_path.glob(f'**/{pattern}')):\n                    languages.append(lang)\n                    break\n        return languages\n\n    def run_comprehensive_sast(self) -> Dict[str, Any]:\n        \"\"\"Execute all applicable SAST tools\"\"\"\n        languages = self.detect_languages()\n\n        scan_results = {\n            'timestamp': datetime.now().isoformat(),\n            'languages': languages,\n            'tools_executed': [],\n            'findings': []\n        }\n\n        self.run_semgrep_scan()\n        scan_results['tools_executed'].append('semgrep')\n\n        if 'python' in languages:\n            self.run_bandit_scan()\n            scan_results['tools_executed'].append('bandit')\n        if 'javascript' in languages or 'typescript' in languages:\n            self.run_eslint_security_scan()\n            scan_results['tools_executed'].append('eslint-security')\n\n        scan_results['findings'] = [vars(f) for f in self.findings]\n        scan_results['summary'] = self.generate_summary()\n        return scan_results\n\n    def run_semgrep_scan(self):\n        \"\"\"Run Semgrep\"\"\"\n        for ruleset in ['auto', 'p/security-audit', 'p/owasp-top-ten']:\n            try:\n                result = subprocess.run([\n                    'semgrep', '--config', ruleset, '--json', '--quiet',\n                    str(self.project_path)\n                ], capture_output=True, text=True, timeout=300)\n\n                if result.stdout:\n                    data = json.loads(result.stdout)\n                    for f in data.get('results', []):\n                        self.findings.append(SASTFinding(\n                            tool='semgrep',\n                            severity=f.get('extra', {}).get('severity', 'MEDIUM').upper(),\n                            category='sast',\n                            title=f.get('check_id', ''),\n                            description=f.get('extra', {}).get('message', ''),\n                            file_path=f.get('path', ''),\n                            line_number=f.get('start', {}).get('line', 0),\n                            cwe=f.get('extra', {}).get('metadata', {}).get('cwe', ''),\n                            owasp=f.get('extra', {}).get('metadata', {}).get('owasp', ''),\n                            confidence=f.get('extra', {}).get('metadata', {}).get('confidence', 'MEDIUM')\n                        ))\n            except Exception as e:\n                print(f\"Semgrep {ruleset} failed: {e}\")\n\n    def generate_summary(self) -> Dict[str, Any]:\n        \"\"\"Generate statistics\"\"\"\n        severity_counts = {'CRITICAL': 0, 'HIGH': 0, 'MEDIUM': 0, 'LOW': 0}\n        for f in self.findings:\n            severity_counts[f.severity] = severity_counts.get(f.severity, 0) + 1\n\n        return {\n            'total_findings': len(self.findings),\n            'severity_breakdown': severity_counts,\n            'risk_score': self.calculate_risk_score(severity_counts)\n        }\n\n    def calculate_risk_score(self, severity_counts: Dict[str, int]) -> int:\n        \"\"\"Risk score 0-100\"\"\"\n        weights = {'CRITICAL': 10, 'HIGH': 7, 'MEDIUM': 4, 'LOW': 1}\n        total = sum(weights[s] * c for s, c in severity_counts.items())\n        return min(100, int((total / 50) * 100))\n```\n\n## CI/CD Integration\n\n### GitHub Actions\n\n```yaml\nname: SAST Scan\non:\n  pull_request:\n    branches: [main]\n\njobs:\n  sast:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n      - uses: actions/setup-python@v4\n        with:\n          python-version: '3.11'\n\n      - name: Install tools\n        run: |\n          pip install bandit semgrep\n          npm install -g eslint @eslint/plugin-security\n\n      - name: Run scans\n        run: |\n          bandit -r . -f json -o bandit.json || true\n          semgrep --config=auto --json --output=semgrep.json || true\n\n      - name: Upload reports\n        uses: actions/upload-artifact@v3\n        with:\n          name: sast-reports\n          path: |\n            bandit.json\n            semgrep.json\n```\n\n### GitLab CI\n\n```yaml\nsast:\n  stage: test\n  image: python:3.11\n  script:\n    - pip install bandit semgrep\n    - bandit -r . -f json -o bandit.json || true\n    - semgrep --config=auto --json --output=semgrep.json || true\n  artifacts:\n    reports:\n      sast: bandit.json\n```\n\n## Best Practices\n\n1. **Run early and often** - Pre-commit hooks and CI/CD\n2. **Combine multiple tools** - Different tools catch different vulnerabilities\n3. **Tune false positives** - Configure exclusions and thresholds\n4. **Prioritize findings** - Focus on CRITICAL/HIGH first\n5. **Framework-aware scanning** - Use specific rulesets\n6. **Custom rules** - Organization-specific patterns\n7. **Developer training** - Secure coding practices\n8. **Incremental remediation** - Fix gradually\n9. **Baseline management** - Track known issues\n10. **Regular updates** - Keep tools current\n\n## Related Tools\n\n- **security-secrets.md** - Advanced credential detection\n- **security-owasp.md** - OWASP Top 10 assessment\n- **security-api.md** - API security testing\n- **security-scan.md** - Comprehensive security scanning\n"
}