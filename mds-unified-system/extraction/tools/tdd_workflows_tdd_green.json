{
  "id": "tdd_workflows_tdd_green",
  "name": "Green Phase: Simple function",
  "source": "tdd-workflows",
  "originalPath": "plugins/tdd-workflows/commands/tdd-green.md",
  "command": "/tdd-workflows:tdd-green",
  "parameters": {},
  "outputs": {},
  "agentsUsing": [],
  "fullDefinition": "Implement minimal code to make failing tests pass in TDD green phase:\n\n[Extended thinking: This tool uses the test-automator agent to implement the minimal code necessary to make tests pass. It focuses on simplicity, avoiding over-engineering while ensuring all tests become green.]\n\n## Implementation Process\n\nUse Task tool with subagent_type=\"unit-testing::test-automator\" to implement minimal passing code.\n\nPrompt: \"Implement MINIMAL code to make these failing tests pass: $ARGUMENTS. Follow TDD green phase principles:\n\n1. **Pre-Implementation Analysis**\n   - Review all failing tests and their error messages\n   - Identify the simplest path to make tests pass\n   - Map test requirements to minimal implementation needs\n   - Avoid premature optimization or over-engineering\n   - Focus only on making tests green, not perfect code\n\n2. **Implementation Strategy**\n   - **Fake It**: Return hard-coded values when appropriate\n   - **Obvious Implementation**: When solution is trivial and clear\n   - **Triangulation**: Generalize only when multiple tests require it\n   - Start with the simplest test and work incrementally\n   - One test at a time - don't try to pass all at once\n\n3. **Code Structure Guidelines**\n   - Write the minimal code that could possibly work\n   - Avoid adding functionality not required by tests\n   - Use simple data structures initially\n   - Defer architectural decisions until refactor phase\n   - Keep methods/functions small and focused\n   - Don't add error handling unless tests require it\n\n4. **Language-Specific Patterns**\n   - **JavaScript/TypeScript**: Simple functions, avoid classes initially\n   - **Python**: Functions before classes, simple returns\n   - **Java**: Minimal class structure, no patterns yet\n   - **C#**: Basic implementations, no interfaces yet\n   - **Go**: Simple functions, defer goroutines/channels\n   - **Ruby**: Procedural before object-oriented when possible\n\n5. **Progressive Implementation**\n   - Make first test pass with simplest possible code\n   - Run tests after each change to verify progress\n   - Add just enough code for next failing test\n   - Resist urge to implement beyond test requirements\n   - Keep track of technical debt for refactor phase\n   - Document assumptions and shortcuts taken\n\n6. **Common Green Phase Techniques**\n   - Hard-coded returns for initial tests\n   - Simple if/else for limited test cases\n   - Basic loops only when iteration tests require\n   - Minimal data structures (arrays before complex objects)\n   - In-memory storage before database integration\n   - Synchronous before asynchronous implementation\n\n7. **Success Criteria**\n   \u2713 All tests pass (green)\n   \u2713 No extra functionality beyond test requirements\n   \u2713 Code is readable even if not optimal\n   \u2713 No broken existing functionality\n   \u2713 Implementation time is minimized\n   \u2713 Clear path to refactoring identified\n\n8. **Anti-Patterns to Avoid**\n   - Gold plating or adding unrequested features\n   - Implementing design patterns prematurely\n   - Complex abstractions without test justification\n   - Performance optimizations without metrics\n   - Adding tests during green phase\n   - Refactoring during implementation\n   - Ignoring test failures to move forward\n\n9. **Implementation Metrics**\n   - Time to green: Track implementation duration\n   - Lines of code: Measure implementation size\n   - Cyclomatic complexity: Keep it low initially\n   - Test pass rate: Must reach 100%\n   - Code coverage: Verify all paths tested\n\n10. **Validation Steps**\n    - Run all tests and confirm they pass\n    - Verify no regression in existing tests\n    - Check that implementation is truly minimal\n    - Document any technical debt created\n    - Prepare notes for refactoring phase\n\nOutput should include:\n- Complete implementation code\n- Test execution results showing all green\n- List of shortcuts taken for later refactoring\n- Implementation time metrics\n- Technical debt documentation\n- Readiness assessment for refactor phase\"\n\n## Post-Implementation Checks\n\nAfter implementation:\n1. Run full test suite to confirm all tests pass\n2. Verify no existing tests were broken\n3. Document areas needing refactoring\n4. Check implementation is truly minimal\n5. Record implementation time for metrics\n\n## Recovery Process\n\nIf tests still fail:\n- Review test requirements carefully\n- Check for misunderstood assertions\n- Add minimal code to address specific failures\n- Avoid the temptation to rewrite from scratch\n- Consider if tests themselves need adjustment\n\n## Integration Points\n\n- Follows from tdd-red.md test creation\n- Prepares for tdd-refactor.md improvements\n- Updates test coverage metrics\n- Triggers CI/CD pipeline verification\n- Documents technical debt for tracking\n\n## Best Practices\n\n- Embrace \"good enough\" for this phase\n- Speed over perfection (perfection comes in refactor)\n- Make it work, then make it right, then make it fast\n- Trust that refactoring phase will improve code\n- Keep changes small and incremental\n- Celebrate reaching green state!\n\n## Complete Implementation Examples\n\n### Example 1: Minimal \u2192 Production-Ready (User Service)\n\n**Test Requirements:**\n```typescript\ndescribe('UserService', () => {\n  it('should create a new user', async () => {\n    const user = await userService.create({ email: 'test@example.com', name: 'Test' });\n    expect(user.id).toBeDefined();\n    expect(user.email).toBe('test@example.com');\n  });\n\n  it('should find user by email', async () => {\n    await userService.create({ email: 'test@example.com', name: 'Test' });\n    const user = await userService.findByEmail('test@example.com');\n    expect(user).toBeDefined();\n  });\n});\n```\n\n**Stage 1: Fake It (Minimal)**\n```typescript\nclass UserService {\n  create(data: { email: string; name: string }) {\n    return { id: '123', email: data.email, name: data.name };\n  }\n\n  findByEmail(email: string) {\n    return { id: '123', email: email, name: 'Test' };\n  }\n}\n```\n*Tests pass. Implementation is obviously fake but validates test structure.*\n\n**Stage 2: Simple Real Implementation**\n```typescript\nclass UserService {\n  private users: Map<string, User> = new Map();\n  private nextId = 1;\n\n  create(data: { email: string; name: string }) {\n    const user = { id: String(this.nextId++), ...data };\n    this.users.set(user.email, user);\n    return user;\n  }\n\n  findByEmail(email: string) {\n    return this.users.get(email) || null;\n  }\n}\n```\n*In-memory storage. Tests pass. Good enough for green phase.*\n\n**Stage 3: Production-Ready (Refactor Phase)**\n```typescript\nclass UserService {\n  constructor(private db: Database) {}\n\n  async create(data: { email: string; name: string }) {\n    const existing = await this.db.query('SELECT * FROM users WHERE email = ?', [data.email]);\n    if (existing) throw new Error('User exists');\n\n    const id = await this.db.insert('users', data);\n    return { id, ...data };\n  }\n\n  async findByEmail(email: string) {\n    return this.db.queryOne('SELECT * FROM users WHERE email = ?', [email]);\n  }\n}\n```\n*Database integration, error handling, validation - saved for refactor phase.*\n\n### Example 2: API-First Implementation (Express)\n\n**Test Requirements:**\n```javascript\ndescribe('POST /api/tasks', () => {\n  it('should create task and return 201', async () => {\n    const res = await request(app)\n      .post('/api/tasks')\n      .send({ title: 'Test Task' });\n\n    expect(res.status).toBe(201);\n    expect(res.body.id).toBeDefined();\n    expect(res.body.title).toBe('Test Task');\n  });\n});\n```\n\n**Stage 1: Hardcoded Response**\n```javascript\napp.post('/api/tasks', (req, res) => {\n  res.status(201).json({ id: '1', title: req.body.title });\n});\n```\n*Tests pass immediately. No logic needed yet.*\n\n**Stage 2: Simple Logic**\n```javascript\nlet tasks = [];\nlet nextId = 1;\n\napp.post('/api/tasks', (req, res) => {\n  const task = { id: String(nextId++), title: req.body.title };\n  tasks.push(task);\n  res.status(201).json(task);\n});\n```\n*Minimal state management. Ready for more tests.*\n\n**Stage 3: Layered Architecture (Refactor)**\n```javascript\n// Controller\napp.post('/api/tasks', async (req, res) => {\n  try {\n    const task = await taskService.create(req.body);\n    res.status(201).json(task);\n  } catch (error) {\n    res.status(400).json({ error: error.message });\n  }\n});\n\n// Service layer\nclass TaskService {\n  constructor(private repository: TaskRepository) {}\n\n  async create(data: CreateTaskDto): Promise<Task> {\n    this.validate(data);\n    return this.repository.save(data);\n  }\n}\n```\n*Proper separation of concerns added during refactor phase.*\n\n### Example 3: Database Integration (Django)\n\n**Test Requirements:**\n```python\ndef test_product_creation():\n    product = Product.objects.create(name=\"Widget\", price=9.99)\n    assert product.id is not None\n    assert product.name == \"Widget\"\n\ndef test_product_price_validation():\n    with pytest.raises(ValidationError):\n        Product.objects.create(name=\"Widget\", price=-1)\n```\n\n**Stage 1: Model Only**\n```python\nclass Product(models.Model):\n    name = models.CharField(max_length=200)\n    price = models.DecimalField(max_digits=10, decimal_places=2)\n```\n*First test passes. Second test fails - validation not implemented.*\n\n**Stage 2: Add Validation**\n```python\nclass Product(models.Model):\n    name = models.CharField(max_length=200)\n    price = models.DecimalField(max_digits=10, decimal_places=2)\n\n    def clean(self):\n        if self.price < 0:\n            raise ValidationError(\"Price cannot be negative\")\n\n    def save(self, *args, **kwargs):\n        self.clean()\n        super().save(*args, **kwargs)\n```\n*All tests pass. Minimal validation logic added.*\n\n**Stage 3: Rich Domain Model (Refactor)**\n```python\nclass Product(models.Model):\n    name = models.CharField(max_length=200)\n    price = models.DecimalField(max_digits=10, decimal_places=2)\n    category = models.ForeignKey(Category, on_delete=models.CASCADE)\n    created_at = models.DateTimeField(auto_now_add=True)\n    updated_at = models.DateTimeField(auto_now=True)\n\n    class Meta:\n        indexes = [models.Index(fields=['category', '-created_at'])]\n\n    def clean(self):\n        if self.price < 0:\n            raise ValidationError(\"Price cannot be negative\")\n        if self.price > 10000:\n            raise ValidationError(\"Price exceeds maximum\")\n\n    def apply_discount(self, percentage: float) -> Decimal:\n        return self.price * (1 - percentage / 100)\n```\n*Additional features, indexes, business logic added when needed.*\n\n### Example 4: React Component Implementation\n\n**Test Requirements:**\n```typescript\ndescribe('UserProfile', () => {\n  it('should display user name', () => {\n    render(<UserProfile user={{ name: 'John', email: 'john@test.com' }} />);\n    expect(screen.getByText('John')).toBeInTheDocument();\n  });\n\n  it('should display email', () => {\n    render(<UserProfile user={{ name: 'John', email: 'john@test.com' }} />);\n    expect(screen.getByText('john@test.com')).toBeInTheDocument();\n  });\n});\n```\n\n**Stage 1: Minimal JSX**\n```typescript\ninterface UserProfileProps {\n  user: { name: string; email: string };\n}\n\nconst UserProfile: React.FC<UserProfileProps> = ({ user }) => (\n  <div>\n    <div>{user.name}</div>\n    <div>{user.email}</div>\n  </div>\n);\n```\n*Tests pass. No styling, no structure.*\n\n**Stage 2: Basic Structure**\n```typescript\nconst UserProfile: React.FC<UserProfileProps> = ({ user }) => (\n  <div className=\"user-profile\">\n    <h2>{user.name}</h2>\n    <p>{user.email}</p>\n  </div>\n);\n```\n*Added semantic HTML, className for styling hook.*\n\n**Stage 3: Production Component (Refactor)**\n```typescript\nconst UserProfile: React.FC<UserProfileProps> = ({ user }) => {\n  const [isEditing, setIsEditing] = useState(false);\n\n  return (\n    <div className=\"user-profile\" role=\"article\" aria-label=\"User profile\">\n      <header>\n        <h2>{user.name}</h2>\n        <button onClick={() => setIsEditing(true)} aria-label=\"Edit profile\">\n          Edit\n        </button>\n      </header>\n      <section>\n        <p>{user.email}</p>\n        {user.bio && <p>{user.bio}</p>}\n      </section>\n    </div>\n  );\n};\n```\n*Accessibility, interaction, additional features added incrementally.*\n\n## Decision Frameworks\n\n### Framework 1: Fake vs. Real Implementation\n\n**When to Fake It:**\n- First test for a new feature\n- Complex external dependencies (payment gateways, APIs)\n- Implementation approach is still uncertain\n- Need to validate test structure first\n- Time pressure to see all tests green\n\n**When to Go Real:**\n- Second or third test reveals pattern\n- Implementation is obvious and simple\n- Faking would be more complex than real code\n- Need to test integration points\n- Tests explicitly require real behavior\n\n**Decision Matrix:**\n```\nComplexity Low     | High\n         \u2193         | \u2193\nSimple   \u2192 REAL    | FAKE first, real later\nComplex  \u2192 REAL    | FAKE, evaluate alternatives\n```\n\n### Framework 2: Complexity Trade-off Analysis\n\n**Simplicity Score Calculation:**\n```\nScore = (Lines of Code) + (Cyclomatic Complexity \u00d7 2) + (Dependencies \u00d7 3)\n\n< 20  \u2192 Simple enough, implement directly\n20-50 \u2192 Consider simpler alternative\n> 50  \u2192 Defer complexity to refactor phase\n```\n\n**Example Evaluation:**\n```typescript\n// Option A: Direct implementation (Score: 45)\nfunction calculateShipping(weight: number, distance: number, express: boolean): number {\n  let base = weight * 0.5 + distance * 0.1;\n  if (express) base *= 2;\n  if (weight > 50) base += 10;\n  if (distance > 1000) base += 20;\n  return base;\n}\n\n// Option B: Simplest for green phase (Score: 15)\nfunction calculateShipping(weight: number, distance: number, express: boolean): number {\n  return express ? 50 : 25; // Fake it until more tests drive real logic\n}\n```\n*Choose Option B for green phase, evolve to Option A as tests require.*\n\n### Framework 3: Performance Consideration Timing\n\n**Green Phase: Focus on Correctness**\n```\n\u274c Avoid:\n- Caching strategies\n- Database query optimization\n- Algorithmic complexity improvements\n- Premature memory optimization\n\n\u2713 Accept:\n- O(n\u00b2) if it makes code simpler\n- Multiple database queries\n- Synchronous operations\n- Inefficient but clear algorithms\n```\n\n**When Performance Matters in Green Phase:**\n1. Performance is explicit test requirement\n2. Implementation would cause timeout in test suite\n3. Memory leak would crash tests\n4. Resource exhaustion prevents testing\n\n**Performance Testing Integration:**\n```typescript\n// Add performance test AFTER functional tests pass\ndescribe('Performance', () => {\n  it('should handle 1000 users within 100ms', () => {\n    const start = Date.now();\n    for (let i = 0; i < 1000; i++) {\n      userService.create({ email: `user${i}@test.com`, name: `User ${i}` });\n    }\n    expect(Date.now() - start).toBeLessThan(100);\n  });\n});\n```\n\n## Framework-Specific Patterns\n\n### React Patterns\n\n**Simple Component \u2192 Hooks \u2192 Context:**\n```typescript\n// Green Phase: Props only\nconst Counter = ({ count, onIncrement }) => (\n  <button onClick={onIncrement}>{count}</button>\n);\n\n// Refactor: Add hooks\nconst Counter = () => {\n  const [count, setCount] = useState(0);\n  return <button onClick={() => setCount(c => c + 1)}>{count}</button>;\n};\n\n// Refactor: Extract to context\nconst Counter = () => {\n  const { count, increment } = useCounter();\n  return <button onClick={increment}>{count}</button>;\n};\n```\n\n### Django Patterns\n\n**Function View \u2192 Class View \u2192 Generic View:**\n```python\n# Green Phase: Simple function\ndef product_list(request):\n    products = Product.objects.all()\n    return JsonResponse({'products': list(products.values())})\n\n# Refactor: Class-based view\nclass ProductListView(View):\n    def get(self, request):\n        products = Product.objects.all()\n        return JsonResponse({'products': list(products.values())})\n\n# Refactor: Generic view\nclass ProductListView(ListView):\n    model = Product\n    context_object_name = 'products'\n```\n\n### Express Patterns\n\n**Inline \u2192 Middleware \u2192 Service Layer:**\n```javascript\n// Green Phase: Inline logic\napp.post('/api/users', (req, res) => {\n  const user = { id: Date.now(), ...req.body };\n  users.push(user);\n  res.json(user);\n});\n\n// Refactor: Extract middleware\napp.post('/api/users', validateUser, (req, res) => {\n  const user = userService.create(req.body);\n  res.json(user);\n});\n\n// Refactor: Full layering\napp.post('/api/users',\n  validateUser,\n  asyncHandler(userController.create)\n);\n```\n\n## Refactoring Resistance Patterns\n\n### Pattern 1: Test Anchor Points\n\nKeep tests green during refactoring by maintaining interface contracts:\n\n```typescript\n// Original implementation (tests green)\nfunction calculateTotal(items: Item[]): number {\n  return items.reduce((sum, item) => sum + item.price, 0);\n}\n\n// Refactoring: Add tax calculation (keep interface)\nfunction calculateTotal(items: Item[]): number {\n  const subtotal = items.reduce((sum, item) => sum + item.price, 0);\n  const tax = subtotal * 0.1;\n  return subtotal + tax;\n}\n\n// Tests still green because return type/behavior unchanged\n```\n\n### Pattern 2: Parallel Implementation\n\nRun old and new implementations side by side:\n\n```python\ndef process_order(order):\n    # Old implementation (tests depend on this)\n    result_old = legacy_process(order)\n\n    # New implementation (testing in parallel)\n    result_new = new_process(order)\n\n    # Verify they match\n    assert result_old == result_new, \"Implementation mismatch\"\n\n    return result_old  # Keep tests green\n```\n\n### Pattern 3: Feature Flags for Refactoring\n\n```javascript\nclass PaymentService {\n  processPayment(amount) {\n    if (config.USE_NEW_PAYMENT_PROCESSOR) {\n      return this.newPaymentProcessor(amount);\n    }\n    return this.legacyPaymentProcessor(amount);\n  }\n}\n```\n\n## Performance-First Green Phase Strategies\n\n### Strategy 1: Type-Driven Development\n\nUse types to guide minimal implementation:\n\n```typescript\n// Types define contract\ninterface UserRepository {\n  findById(id: string): Promise<User | null>;\n  save(user: User): Promise<void>;\n}\n\n// Green phase: In-memory implementation\nclass InMemoryUserRepository implements UserRepository {\n  private users = new Map<string, User>();\n\n  async findById(id: string) {\n    return this.users.get(id) || null;\n  }\n\n  async save(user: User) {\n    this.users.set(user.id, user);\n  }\n}\n\n// Refactor: Database implementation (same interface)\nclass DatabaseUserRepository implements UserRepository {\n  constructor(private db: Database) {}\n\n  async findById(id: string) {\n    return this.db.query('SELECT * FROM users WHERE id = ?', [id]);\n  }\n\n  async save(user: User) {\n    await this.db.insert('users', user);\n  }\n}\n```\n\n### Strategy 2: Contract Testing Integration\n\n```typescript\n// Define contract\nconst userServiceContract = {\n  create: {\n    input: { email: 'string', name: 'string' },\n    output: { id: 'string', email: 'string', name: 'string' }\n  }\n};\n\n// Green phase: Implementation matches contract\nclass UserService {\n  create(data: { email: string; name: string }) {\n    return { id: '123', ...data }; // Minimal but contract-compliant\n  }\n}\n\n// Contract test ensures compliance\ndescribe('UserService Contract', () => {\n  it('should match create contract', () => {\n    const result = userService.create({ email: 'test@test.com', name: 'Test' });\n    expect(typeof result.id).toBe('string');\n    expect(typeof result.email).toBe('string');\n    expect(typeof result.name).toBe('string');\n  });\n});\n```\n\n### Strategy 3: Continuous Refactoring Workflow\n\n**Micro-Refactoring During Green Phase:**\n\n```python\n# Test passes with this\ndef calculate_discount(price, customer_type):\n    if customer_type == 'premium':\n        return price * 0.8\n    return price\n\n# Immediate micro-refactor (tests still green)\nDISCOUNT_RATES = {\n    'premium': 0.8,\n    'standard': 1.0\n}\n\ndef calculate_discount(price, customer_type):\n    rate = DISCOUNT_RATES.get(customer_type, 1.0)\n    return price * rate\n```\n\n**Safe Refactoring Checklist:**\n- \u2713 Tests green before refactoring\n- \u2713 Change one thing at a time\n- \u2713 Run tests after each change\n- \u2713 Commit after each successful refactor\n- \u2713 No behavior changes, only structure\n\n## Modern Development Practices (2024/2025)\n\n### Type-Driven Development\n\n**Python Type Hints:**\n```python\nfrom typing import Optional, List\nfrom dataclasses import dataclass\n\n@dataclass\nclass User:\n    id: str\n    email: str\n    name: str\n\nclass UserService:\n    def create(self, email: str, name: str) -> User:\n        return User(id=\"123\", email=email, name=name)\n\n    def find_by_email(self, email: str) -> Optional[User]:\n        return None  # Minimal implementation\n```\n\n**TypeScript Strict Mode:**\n```typescript\n// Enable strict mode in tsconfig.json\n{\n  \"compilerOptions\": {\n    \"strict\": true,\n    \"noUncheckedIndexedAccess\": true,\n    \"exactOptionalPropertyTypes\": true\n  }\n}\n\n// Implementation guided by types\ninterface CreateUserDto {\n  email: string;\n  name: string;\n}\n\nclass UserService {\n  create(data: CreateUserDto): User {\n    // Type system enforces contract\n    return { id: '123', email: data.email, name: data.name };\n  }\n}\n```\n\n### AI-Assisted Green Phase\n\n**Using Copilot/AI Tools:**\n1. Write test first (human-driven)\n2. Let AI suggest minimal implementation\n3. Verify suggestion passes tests\n4. Accept if truly minimal, reject if over-engineered\n5. Iterate with AI for refactoring phase\n\n**AI Prompt Pattern:**\n```\nGiven these failing tests:\n[paste tests]\n\nProvide the MINIMAL implementation that makes tests pass.\nDo not add error handling, validation, or features beyond test requirements.\nFocus on simplicity over completeness.\n```\n\n### Cloud-Native Patterns\n\n**Local \u2192 Container \u2192 Cloud:**\n```javascript\n// Green Phase: Local implementation\nclass CacheService {\n  private cache = new Map();\n\n  get(key) { return this.cache.get(key); }\n  set(key, value) { this.cache.set(key, value); }\n}\n\n// Refactor: Redis-compatible interface\nclass CacheService {\n  constructor(private redis) {}\n\n  async get(key) { return this.redis.get(key); }\n  async set(key, value) { return this.redis.set(key, value); }\n}\n\n// Production: Distributed cache with fallback\nclass CacheService {\n  constructor(private redis, private fallback) {}\n\n  async get(key) {\n    try {\n      return await this.redis.get(key);\n    } catch {\n      return this.fallback.get(key);\n    }\n  }\n}\n```\n\n### Observability-Driven Development\n\n**Add observability hooks during green phase:**\n```typescript\nclass OrderService {\n  async createOrder(data: CreateOrderDto): Promise<Order> {\n    console.log('[OrderService] Creating order', { data }); // Simple logging\n\n    const order = { id: '123', ...data };\n\n    console.log('[OrderService] Order created', { orderId: order.id }); // Success log\n\n    return order;\n  }\n}\n\n// Refactor: Structured logging\nclass OrderService {\n  constructor(private logger: Logger) {}\n\n  async createOrder(data: CreateOrderDto): Promise<Order> {\n    this.logger.info('order.create.start', { data });\n\n    const order = await this.repository.save(data);\n\n    this.logger.info('order.create.success', {\n      orderId: order.id,\n      duration: Date.now() - start\n    });\n\n    return order;\n  }\n}\n```\n\nTests to make pass: $ARGUMENTS"
}