{
  "id": "tdd_workflows_tdd_cycle",
  "name": "tdd-cycle",
  "source": "tdd-workflows",
  "originalPath": "plugins/tdd-workflows/commands/tdd-cycle.md",
  "command": "/tdd-workflows:tdd-cycle",
  "parameters": {},
  "outputs": {},
  "agentsUsing": [],
  "fullDefinition": "Execute a comprehensive Test-Driven Development (TDD) workflow with strict red-green-refactor discipline:\n\n[Extended thinking: This workflow enforces test-first development through coordinated agent orchestration. Each phase of the TDD cycle is strictly enforced with fail-first verification, incremental implementation, and continuous refactoring. The workflow supports both single test and test suite approaches with configurable coverage thresholds.]\n\n## Configuration\n\n### Coverage Thresholds\n- Minimum line coverage: 80%\n- Minimum branch coverage: 75%\n- Critical path coverage: 100%\n\n### Refactoring Triggers\n- Cyclomatic complexity > 10\n- Method length > 20 lines\n- Class length > 200 lines\n- Duplicate code blocks > 3 lines\n\n## Phase 1: Test Specification and Design\n\n### 1. Requirements Analysis\n- Use Task tool with subagent_type=\"comprehensive-review::architect-review\"\n- Prompt: \"Analyze requirements for: $ARGUMENTS. Define acceptance criteria, identify edge cases, and create test scenarios. Output a comprehensive test specification.\"\n- Output: Test specification, acceptance criteria, edge case matrix\n- Validation: Ensure all requirements have corresponding test scenarios\n\n### 2. Test Architecture Design\n- Use Task tool with subagent_type=\"unit-testing::test-automator\"\n- Prompt: \"Design test architecture for: $ARGUMENTS based on test specification. Define test structure, fixtures, mocks, and test data strategy. Ensure testability and maintainability.\"\n- Output: Test architecture, fixture design, mock strategy\n- Validation: Architecture supports isolated, fast, reliable tests\n\n## Phase 2: RED - Write Failing Tests\n\n### 3. Write Unit Tests (Failing)\n- Use Task tool with subagent_type=\"unit-testing::test-automator\"\n- Prompt: \"Write FAILING unit tests for: $ARGUMENTS. Tests must fail initially. Include edge cases, error scenarios, and happy paths. DO NOT implement production code.\"\n- Output: Failing unit tests, test documentation\n- **CRITICAL**: Verify all tests fail with expected error messages\n\n### 4. Verify Test Failure\n- Use Task tool with subagent_type=\"tdd-workflows::code-reviewer\"\n- Prompt: \"Verify that all tests for: $ARGUMENTS are failing correctly. Ensure failures are for the right reasons (missing implementation, not test errors). Confirm no false positives.\"\n- Output: Test failure verification report\n- **GATE**: Do not proceed until all tests fail appropriately\n\n## Phase 3: GREEN - Make Tests Pass\n\n### 5. Minimal Implementation\n- Use Task tool with subagent_type=\"backend-development::backend-architect\"\n- Prompt: \"Implement MINIMAL code to make tests pass for: $ARGUMENTS. Focus only on making tests green. Do not add extra features or optimizations. Keep it simple.\"\n- Output: Minimal working implementation\n- Constraint: No code beyond what's needed to pass tests\n\n### 6. Verify Test Success\n- Use Task tool with subagent_type=\"unit-testing::test-automator\"\n- Prompt: \"Run all tests for: $ARGUMENTS and verify they pass. Check test coverage metrics. Ensure no tests were accidentally broken.\"\n- Output: Test execution report, coverage metrics\n- **GATE**: All tests must pass before proceeding\n\n## Phase 4: REFACTOR - Improve Code Quality\n\n### 7. Code Refactoring\n- Use Task tool with subagent_type=\"tdd-workflows::code-reviewer\"\n- Prompt: \"Refactor implementation for: $ARGUMENTS while keeping tests green. Apply SOLID principles, remove duplication, improve naming, and optimize performance. Run tests after each refactoring.\"\n- Output: Refactored code, refactoring report\n- Constraint: Tests must remain green throughout\n\n### 8. Test Refactoring\n- Use Task tool with subagent_type=\"unit-testing::test-automator\"\n- Prompt: \"Refactor tests for: $ARGUMENTS. Remove test duplication, improve test names, extract common fixtures, and enhance test readability. Ensure tests still provide same coverage.\"\n- Output: Refactored tests, improved test structure\n- Validation: Coverage metrics unchanged or improved\n\n## Phase 5: Integration and System Tests\n\n### 9. Write Integration Tests (Failing First)\n- Use Task tool with subagent_type=\"unit-testing::test-automator\"\n- Prompt: \"Write FAILING integration tests for: $ARGUMENTS. Test component interactions, API contracts, and data flow. Tests must fail initially.\"\n- Output: Failing integration tests\n- Validation: Tests fail due to missing integration logic\n\n### 10. Implement Integration\n- Use Task tool with subagent_type=\"backend-development::backend-architect\"\n- Prompt: \"Implement integration code for: $ARGUMENTS to make integration tests pass. Focus on component interaction and data flow.\"\n- Output: Integration implementation\n- Validation: All integration tests pass\n\n## Phase 6: Continuous Improvement Cycle\n\n### 11. Performance and Edge Case Tests\n- Use Task tool with subagent_type=\"unit-testing::test-automator\"\n- Prompt: \"Add performance tests and additional edge case tests for: $ARGUMENTS. Include stress tests, boundary tests, and error recovery tests.\"\n- Output: Extended test suite\n- Metric: Increased test coverage and scenario coverage\n\n### 12. Final Code Review\n- Use Task tool with subagent_type=\"comprehensive-review::architect-review\"\n- Prompt: \"Perform comprehensive review of: $ARGUMENTS. Verify TDD process was followed, check code quality, test quality, and coverage. Suggest improvements.\"\n- Output: Review report, improvement suggestions\n- Action: Implement critical suggestions while maintaining green tests\n\n## Incremental Development Mode\n\nFor test-by-test development:\n1. Write ONE failing test\n2. Make ONLY that test pass\n3. Refactor if needed\n4. Repeat for next test\n\nUse this approach by adding `--incremental` flag to focus on one test at a time.\n\n## Test Suite Mode\n\nFor comprehensive test suite development:\n1. Write ALL tests for a feature/module (failing)\n2. Implement code to pass ALL tests\n3. Refactor entire module\n4. Add integration tests\n\nUse this approach by adding `--suite` flag for batch test development.\n\n## Validation Checkpoints\n\n### RED Phase Validation\n- [ ] All tests written before implementation\n- [ ] All tests fail with meaningful error messages\n- [ ] Test failures are due to missing implementation\n- [ ] No test passes accidentally\n\n### GREEN Phase Validation\n- [ ] All tests pass\n- [ ] No extra code beyond test requirements\n- [ ] Coverage meets minimum thresholds\n- [ ] No test was modified to make it pass\n\n### REFACTOR Phase Validation\n- [ ] All tests still pass after refactoring\n- [ ] Code complexity reduced\n- [ ] Duplication eliminated\n- [ ] Performance improved or maintained\n- [ ] Test readability improved\n\n## Coverage Reports\n\nGenerate coverage reports after each phase:\n- Line coverage\n- Branch coverage\n- Function coverage\n- Statement coverage\n\n## Failure Recovery\n\nIf TDD discipline is broken:\n1. **STOP** immediately\n2. Identify which phase was violated\n3. Rollback to last valid state\n4. Resume from correct phase\n5. Document lesson learned\n\n## TDD Metrics Tracking\n\nTrack and report:\n- Time in each phase (Red/Green/Refactor)\n- Number of test-implementation cycles\n- Coverage progression\n- Refactoring frequency\n- Defect escape rate\n\n## Anti-Patterns to Avoid\n\n- Writing implementation before tests\n- Writing tests that already pass\n- Skipping the refactor phase\n- Writing multiple features without tests\n- Modifying tests to make them pass\n- Ignoring failing tests\n- Writing tests after implementation\n\n## Success Criteria\n\n- 100% of code written test-first\n- All tests pass continuously\n- Coverage exceeds thresholds\n- Code complexity within limits\n- Zero defects in covered code\n- Clear test documentation\n- Fast test execution (< 5 seconds for unit tests)\n\n## Notes\n\n- Enforce strict RED-GREEN-REFACTOR discipline\n- Each phase must be completed before moving to next\n- Tests are the specification\n- If a test is hard to write, the design needs improvement\n- Refactoring is NOT optional\n- Keep test execution fast\n- Tests should be independent and isolated\n\nTDD implementation for: $ARGUMENTS"
}