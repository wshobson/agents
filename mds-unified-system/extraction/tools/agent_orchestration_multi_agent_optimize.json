{
  "id": "agent_orchestration_multi_agent_optimize",
  "name": "Multi-Agent Optimization Toolkit",
  "source": "agent-orchestration",
  "originalPath": "plugins/agent-orchestration/commands/multi-agent-optimize.md",
  "command": "/agent-orchestration:multi-agent-optimize",
  "parameters": {},
  "outputs": {},
  "agentsUsing": [],
  "fullDefinition": "# Multi-Agent Optimization Toolkit\n\n## Role: AI-Powered Multi-Agent Performance Engineering Specialist\n\n### Context\nThe Multi-Agent Optimization Tool is an advanced AI-driven framework designed to holistically improve system performance through intelligent, coordinated agent-based optimization. Leveraging cutting-edge AI orchestration techniques, this tool provides a comprehensive approach to performance engineering across multiple domains.\n\n### Core Capabilities\n- Intelligent multi-agent coordination\n- Performance profiling and bottleneck identification\n- Adaptive optimization strategies\n- Cross-domain performance optimization\n- Cost and efficiency tracking\n\n## Arguments Handling\nThe tool processes optimization arguments with flexible input parameters:\n- `$TARGET`: Primary system/application to optimize\n- `$PERFORMANCE_GOALS`: Specific performance metrics and objectives\n- `$OPTIMIZATION_SCOPE`: Depth of optimization (quick-win, comprehensive)\n- `$BUDGET_CONSTRAINTS`: Cost and resource limitations\n- `$QUALITY_METRICS`: Performance quality thresholds\n\n## 1. Multi-Agent Performance Profiling\n\n### Profiling Strategy\n- Distributed performance monitoring across system layers\n- Real-time metrics collection and analysis\n- Continuous performance signature tracking\n\n#### Profiling Agents\n1. **Database Performance Agent**\n   - Query execution time analysis\n   - Index utilization tracking\n   - Resource consumption monitoring\n\n2. **Application Performance Agent**\n   - CPU and memory profiling\n   - Algorithmic complexity assessment\n   - Concurrency and async operation analysis\n\n3. **Frontend Performance Agent**\n   - Rendering performance metrics\n   - Network request optimization\n   - Core Web Vitals monitoring\n\n### Profiling Code Example\n```python\ndef multi_agent_profiler(target_system):\n    agents = [\n        DatabasePerformanceAgent(target_system),\n        ApplicationPerformanceAgent(target_system),\n        FrontendPerformanceAgent(target_system)\n    ]\n\n    performance_profile = {}\n    for agent in agents:\n        performance_profile[agent.__class__.__name__] = agent.profile()\n\n    return aggregate_performance_metrics(performance_profile)\n```\n\n## 2. Context Window Optimization\n\n### Optimization Techniques\n- Intelligent context compression\n- Semantic relevance filtering\n- Dynamic context window resizing\n- Token budget management\n\n### Context Compression Algorithm\n```python\ndef compress_context(context, max_tokens=4000):\n    # Semantic compression using embedding-based truncation\n    compressed_context = semantic_truncate(\n        context,\n        max_tokens=max_tokens,\n        importance_threshold=0.7\n    )\n    return compressed_context\n```\n\n## 3. Agent Coordination Efficiency\n\n### Coordination Principles\n- Parallel execution design\n- Minimal inter-agent communication overhead\n- Dynamic workload distribution\n- Fault-tolerant agent interactions\n\n### Orchestration Framework\n```python\nclass MultiAgentOrchestrator:\n    def __init__(self, agents):\n        self.agents = agents\n        self.execution_queue = PriorityQueue()\n        self.performance_tracker = PerformanceTracker()\n\n    def optimize(self, target_system):\n        # Parallel agent execution with coordinated optimization\n        with concurrent.futures.ThreadPoolExecutor() as executor:\n            futures = {\n                executor.submit(agent.optimize, target_system): agent\n                for agent in self.agents\n            }\n\n            for future in concurrent.futures.as_completed(futures):\n                agent = futures[future]\n                result = future.result()\n                self.performance_tracker.log(agent, result)\n```\n\n## 4. Parallel Execution Optimization\n\n### Key Strategies\n- Asynchronous agent processing\n- Workload partitioning\n- Dynamic resource allocation\n- Minimal blocking operations\n\n## 5. Cost Optimization Strategies\n\n### LLM Cost Management\n- Token usage tracking\n- Adaptive model selection\n- Caching and result reuse\n- Efficient prompt engineering\n\n### Cost Tracking Example\n```python\nclass CostOptimizer:\n    def __init__(self):\n        self.token_budget = 100000  # Monthly budget\n        self.token_usage = 0\n        self.model_costs = {\n            'gpt-5': 0.03,\n            'claude-4-sonnet': 0.015,\n            'claude-4-haiku': 0.0025\n        }\n\n    def select_optimal_model(self, complexity):\n        # Dynamic model selection based on task complexity and budget\n        pass\n```\n\n## 6. Latency Reduction Techniques\n\n### Performance Acceleration\n- Predictive caching\n- Pre-warming agent contexts\n- Intelligent result memoization\n- Reduced round-trip communication\n\n## 7. Quality vs Speed Tradeoffs\n\n### Optimization Spectrum\n- Performance thresholds\n- Acceptable degradation margins\n- Quality-aware optimization\n- Intelligent compromise selection\n\n## 8. Monitoring and Continuous Improvement\n\n### Observability Framework\n- Real-time performance dashboards\n- Automated optimization feedback loops\n- Machine learning-driven improvement\n- Adaptive optimization strategies\n\n## Reference Workflows\n\n### Workflow 1: E-Commerce Platform Optimization\n1. Initial performance profiling\n2. Agent-based optimization\n3. Cost and performance tracking\n4. Continuous improvement cycle\n\n### Workflow 2: Enterprise API Performance Enhancement\n1. Comprehensive system analysis\n2. Multi-layered agent optimization\n3. Iterative performance refinement\n4. Cost-efficient scaling strategy\n\n## Key Considerations\n- Always measure before and after optimization\n- Maintain system stability during optimization\n- Balance performance gains with resource consumption\n- Implement gradual, reversible changes\n\nTarget Optimization: $ARGUMENTS"
}