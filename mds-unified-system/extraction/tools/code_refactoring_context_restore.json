{
  "id": "code_refactoring_context_restore",
  "name": "Context Restoration: Advanced Semantic Memory Rehydration",
  "source": "code-refactoring",
  "originalPath": "plugins/code-refactoring/commands/context-restore.md",
  "command": "/code-refactoring:context-restore",
  "parameters": {},
  "outputs": {},
  "agentsUsing": [],
  "fullDefinition": "# Context Restoration: Advanced Semantic Memory Rehydration\n\n## Role Statement\n\nExpert Context Restoration Specialist focused on intelligent, semantic-aware context retrieval and reconstruction across complex multi-agent AI workflows. Specializes in preserving and reconstructing project knowledge with high fidelity and minimal information loss.\n\n## Context Overview\n\nThe Context Restoration tool is a sophisticated memory management system designed to:\n- Recover and reconstruct project context across distributed AI workflows\n- Enable seamless continuity in complex, long-running projects\n- Provide intelligent, semantically-aware context rehydration\n- Maintain historical knowledge integrity and decision traceability\n\n## Core Requirements and Arguments\n\n### Input Parameters\n- `context_source`: Primary context storage location (vector database, file system)\n- `project_identifier`: Unique project namespace\n- `restoration_mode`:\n  - `full`: Complete context restoration\n  - `incremental`: Partial context update\n  - `diff`: Compare and merge context versions\n- `token_budget`: Maximum context tokens to restore (default: 8192)\n- `relevance_threshold`: Semantic similarity cutoff for context components (default: 0.75)\n\n## Advanced Context Retrieval Strategies\n\n### 1. Semantic Vector Search\n- Utilize multi-dimensional embedding models for context retrieval\n- Employ cosine similarity and vector clustering techniques\n- Support multi-modal embedding (text, code, architectural diagrams)\n\n```python\ndef semantic_context_retrieve(project_id, query_vector, top_k=5):\n    \"\"\"Semantically retrieve most relevant context vectors\"\"\"\n    vector_db = VectorDatabase(project_id)\n    matching_contexts = vector_db.search(\n        query_vector,\n        similarity_threshold=0.75,\n        max_results=top_k\n    )\n    return rank_and_filter_contexts(matching_contexts)\n```\n\n### 2. Relevance Filtering and Ranking\n- Implement multi-stage relevance scoring\n- Consider temporal decay, semantic similarity, and historical impact\n- Dynamic weighting of context components\n\n```python\ndef rank_context_components(contexts, current_state):\n    \"\"\"Rank context components based on multiple relevance signals\"\"\"\n    ranked_contexts = []\n    for context in contexts:\n        relevance_score = calculate_composite_score(\n            semantic_similarity=context.semantic_score,\n            temporal_relevance=context.age_factor,\n            historical_impact=context.decision_weight\n        )\n        ranked_contexts.append((context, relevance_score))\n\n    return sorted(ranked_contexts, key=lambda x: x[1], reverse=True)\n```\n\n### 3. Context Rehydration Patterns\n- Implement incremental context loading\n- Support partial and full context reconstruction\n- Manage token budgets dynamically\n\n```python\ndef rehydrate_context(project_context, token_budget=8192):\n    \"\"\"Intelligent context rehydration with token budget management\"\"\"\n    context_components = [\n        'project_overview',\n        'architectural_decisions',\n        'technology_stack',\n        'recent_agent_work',\n        'known_issues'\n    ]\n\n    prioritized_components = prioritize_components(context_components)\n    restored_context = {}\n\n    current_tokens = 0\n    for component in prioritized_components:\n        component_tokens = estimate_tokens(component)\n        if current_tokens + component_tokens <= token_budget:\n            restored_context[component] = load_component(component)\n            current_tokens += component_tokens\n\n    return restored_context\n```\n\n### 4. Session State Reconstruction\n- Reconstruct agent workflow state\n- Preserve decision trails and reasoning contexts\n- Support multi-agent collaboration history\n\n### 5. Context Merging and Conflict Resolution\n- Implement three-way merge strategies\n- Detect and resolve semantic conflicts\n- Maintain provenance and decision traceability\n\n### 6. Incremental Context Loading\n- Support lazy loading of context components\n- Implement context streaming for large projects\n- Enable dynamic context expansion\n\n### 7. Context Validation and Integrity Checks\n- Cryptographic context signatures\n- Semantic consistency verification\n- Version compatibility checks\n\n### 8. Performance Optimization\n- Implement efficient caching mechanisms\n- Use probabilistic data structures for context indexing\n- Optimize vector search algorithms\n\n## Reference Workflows\n\n### Workflow 1: Project Resumption\n1. Retrieve most recent project context\n2. Validate context against current codebase\n3. Selectively restore relevant components\n4. Generate resumption summary\n\n### Workflow 2: Cross-Project Knowledge Transfer\n1. Extract semantic vectors from source project\n2. Map and transfer relevant knowledge\n3. Adapt context to target project's domain\n4. Validate knowledge transferability\n\n## Usage Examples\n\n```bash\n# Full context restoration\ncontext-restore project:ai-assistant --mode full\n\n# Incremental context update\ncontext-restore project:web-platform --mode incremental\n\n# Semantic context query\ncontext-restore project:ml-pipeline --query \"model training strategy\"\n```\n\n## Integration Patterns\n- RAG (Retrieval Augmented Generation) pipelines\n- Multi-agent workflow coordination\n- Continuous learning systems\n- Enterprise knowledge management\n\n## Future Roadmap\n- Enhanced multi-modal embedding support\n- Quantum-inspired vector search algorithms\n- Self-healing context reconstruction\n- Adaptive learning context strategies"
}