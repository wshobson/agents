{
  "id": "security_scanning_security_dependencies",
  "name": "Dependency Vulnerability Scanning",
  "source": "security-scanning",
  "originalPath": "plugins/security-scanning/commands/security-dependencies.md",
  "command": "/security-scanning:security-dependencies",
  "parameters": {},
  "outputs": {},
  "agentsUsing": [],
  "fullDefinition": "# Dependency Vulnerability Scanning\n\nYou are a security expert specializing in dependency vulnerability analysis, SBOM generation, and supply chain security. Scan project dependencies across multiple ecosystems to identify vulnerabilities, assess risks, and provide automated remediation strategies.\n\n## Context\nThe user needs comprehensive dependency security analysis to identify vulnerable packages, outdated dependencies, and license compliance issues. Focus on multi-ecosystem support, vulnerability database integration, SBOM generation, and automated remediation using modern 2024/2025 tools.\n\n## Requirements\n$ARGUMENTS\n\n## Instructions\n\n### 1. Multi-Ecosystem Dependency Scanner\n\n```python\nimport subprocess\nimport json\nimport requests\nfrom pathlib import Path\nfrom typing import Dict, List, Any\nfrom dataclasses import dataclass\nfrom datetime import datetime\n\n@dataclass\nclass Vulnerability:\n    package: str\n    version: str\n    vulnerability_id: str\n    severity: str\n    cve: List[str]\n    cvss_score: float\n    fixed_versions: List[str]\n    source: str\n\nclass DependencyScanner:\n    def __init__(self, project_path: str):\n        self.project_path = Path(project_path)\n        self.ecosystem_scanners = {\n            'npm': self.scan_npm,\n            'pip': self.scan_python,\n            'go': self.scan_go,\n            'cargo': self.scan_rust\n        }\n\n    def detect_ecosystems(self) -> List[str]:\n        ecosystem_files = {\n            'npm': ['package.json', 'package-lock.json'],\n            'pip': ['requirements.txt', 'pyproject.toml'],\n            'go': ['go.mod'],\n            'cargo': ['Cargo.toml']\n        }\n\n        detected = []\n        for ecosystem, patterns in ecosystem_files.items():\n            if any(list(self.project_path.glob(f\"**/{p}\")) for p in patterns):\n                detected.append(ecosystem)\n        return detected\n\n    def scan_all_dependencies(self) -> Dict[str, Any]:\n        ecosystems = self.detect_ecosystems()\n        results = {\n            'timestamp': datetime.now().isoformat(),\n            'ecosystems': {},\n            'vulnerabilities': [],\n            'summary': {\n                'total_vulnerabilities': 0,\n                'critical': 0,\n                'high': 0,\n                'medium': 0,\n                'low': 0\n            }\n        }\n\n        for ecosystem in ecosystems:\n            scanner = self.ecosystem_scanners.get(ecosystem)\n            if scanner:\n                ecosystem_results = scanner()\n                results['ecosystems'][ecosystem] = ecosystem_results\n                results['vulnerabilities'].extend(ecosystem_results.get('vulnerabilities', []))\n\n        self._update_summary(results)\n        results['remediation_plan'] = self.generate_remediation_plan(results['vulnerabilities'])\n        results['sbom'] = self.generate_sbom(results['ecosystems'])\n\n        return results\n\n    def scan_npm(self) -> Dict[str, Any]:\n        results = {\n            'ecosystem': 'npm',\n            'vulnerabilities': []\n        }\n\n        try:\n            npm_result = subprocess.run(\n                ['npm', 'audit', '--json'],\n                cwd=self.project_path,\n                capture_output=True,\n                text=True,\n                timeout=120\n            )\n\n            if npm_result.stdout:\n                audit_data = json.loads(npm_result.stdout)\n                for vuln_id, vuln in audit_data.get('vulnerabilities', {}).items():\n                    results['vulnerabilities'].append({\n                        'package': vuln.get('name', vuln_id),\n                        'version': vuln.get('range', ''),\n                        'vulnerability_id': vuln_id,\n                        'severity': vuln.get('severity', 'UNKNOWN').upper(),\n                        'cve': vuln.get('cves', []),\n                        'fixed_in': vuln.get('fixAvailable', {}).get('version', 'N/A'),\n                        'source': 'npm_audit'\n                    })\n        except Exception as e:\n            results['error'] = str(e)\n\n        return results\n\n    def scan_python(self) -> Dict[str, Any]:\n        results = {\n            'ecosystem': 'python',\n            'vulnerabilities': []\n        }\n\n        try:\n            safety_result = subprocess.run(\n                ['safety', 'check', '--json'],\n                cwd=self.project_path,\n                capture_output=True,\n                text=True,\n                timeout=120\n            )\n\n            if safety_result.stdout:\n                safety_data = json.loads(safety_result.stdout)\n                for vuln in safety_data:\n                    results['vulnerabilities'].append({\n                        'package': vuln.get('package_name', ''),\n                        'version': vuln.get('analyzed_version', ''),\n                        'vulnerability_id': vuln.get('vulnerability_id', ''),\n                        'severity': 'HIGH',\n                        'fixed_in': vuln.get('fixed_version', ''),\n                        'source': 'safety'\n                    })\n        except Exception as e:\n            results['error'] = str(e)\n\n        return results\n\n    def scan_go(self) -> Dict[str, Any]:\n        results = {\n            'ecosystem': 'go',\n            'vulnerabilities': []\n        }\n\n        try:\n            govuln_result = subprocess.run(\n                ['govulncheck', '-json', './...'],\n                cwd=self.project_path,\n                capture_output=True,\n                text=True,\n                timeout=180\n            )\n\n            if govuln_result.stdout:\n                for line in govuln_result.stdout.strip().split('\\n'):\n                    if line:\n                        vuln_data = json.loads(line)\n                        if vuln_data.get('finding'):\n                            finding = vuln_data['finding']\n                            results['vulnerabilities'].append({\n                                'package': finding.get('osv', ''),\n                                'vulnerability_id': finding.get('osv', ''),\n                                'severity': 'HIGH',\n                                'source': 'govulncheck'\n                            })\n        except Exception as e:\n            results['error'] = str(e)\n\n        return results\n\n    def scan_rust(self) -> Dict[str, Any]:\n        results = {\n            'ecosystem': 'rust',\n            'vulnerabilities': []\n        }\n\n        try:\n            audit_result = subprocess.run(\n                ['cargo', 'audit', '--json'],\n                cwd=self.project_path,\n                capture_output=True,\n                text=True,\n                timeout=120\n            )\n\n            if audit_result.stdout:\n                audit_data = json.loads(audit_result.stdout)\n                for vuln in audit_data.get('vulnerabilities', {}).get('list', []):\n                    advisory = vuln.get('advisory', {})\n                    results['vulnerabilities'].append({\n                        'package': vuln.get('package', {}).get('name', ''),\n                        'version': vuln.get('package', {}).get('version', ''),\n                        'vulnerability_id': advisory.get('id', ''),\n                        'severity': 'HIGH',\n                        'source': 'cargo_audit'\n                    })\n        except Exception as e:\n            results['error'] = str(e)\n\n        return results\n\n    def _update_summary(self, results: Dict[str, Any]):\n        vulnerabilities = results['vulnerabilities']\n        results['summary']['total_vulnerabilities'] = len(vulnerabilities)\n\n        for vuln in vulnerabilities:\n            severity = vuln.get('severity', '').upper()\n            if severity == 'CRITICAL':\n                results['summary']['critical'] += 1\n            elif severity == 'HIGH':\n                results['summary']['high'] += 1\n            elif severity == 'MEDIUM':\n                results['summary']['medium'] += 1\n            elif severity == 'LOW':\n                results['summary']['low'] += 1\n\n    def generate_remediation_plan(self, vulnerabilities: List[Dict]) -> Dict[str, Any]:\n        plan = {\n            'immediate_actions': [],\n            'short_term': [],\n            'automation_scripts': {}\n        }\n\n        critical_high = [v for v in vulnerabilities if v.get('severity', '').upper() in ['CRITICAL', 'HIGH']]\n\n        for vuln in critical_high[:20]:\n            plan['immediate_actions'].append({\n                'package': vuln.get('package', ''),\n                'current_version': vuln.get('version', ''),\n                'fixed_version': vuln.get('fixed_in', 'latest'),\n                'severity': vuln.get('severity', ''),\n                'priority': 1\n            })\n\n        plan['automation_scripts'] = {\n            'npm_fix': 'npm audit fix && npm update',\n            'pip_fix': 'pip-audit --fix && safety check',\n            'go_fix': 'go get -u ./... && go mod tidy',\n            'cargo_fix': 'cargo update && cargo audit'\n        }\n\n        return plan\n\n    def generate_sbom(self, ecosystems: Dict[str, Any]) -> Dict[str, Any]:\n        sbom = {\n            'bomFormat': 'CycloneDX',\n            'specVersion': '1.5',\n            'version': 1,\n            'metadata': {\n                'timestamp': datetime.now().isoformat()\n            },\n            'components': []\n        }\n\n        for ecosystem_name, ecosystem_data in ecosystems.items():\n            for vuln in ecosystem_data.get('vulnerabilities', []):\n                sbom['components'].append({\n                    'type': 'library',\n                    'name': vuln.get('package', ''),\n                    'version': vuln.get('version', ''),\n                    'purl': f\"pkg:{ecosystem_name}/{vuln.get('package', '')}@{vuln.get('version', '')}\"\n                })\n\n        return sbom\n```\n\n### 2. Vulnerability Prioritization\n\n```python\nclass VulnerabilityPrioritizer:\n    def calculate_priority_score(self, vulnerability: Dict) -> float:\n        cvss_score = vulnerability.get('cvss_score', 0) or 0\n        exploitability = 1.0 if vulnerability.get('exploit_available') else 0.5\n        fix_available = 1.0 if vulnerability.get('fixed_in') else 0.3\n\n        priority_score = (\n            cvss_score * 0.4 +\n            exploitability * 2.0 +\n            fix_available * 1.0\n        )\n\n        return round(priority_score, 2)\n\n    def prioritize_vulnerabilities(self, vulnerabilities: List[Dict]) -> List[Dict]:\n        for vuln in vulnerabilities:\n            vuln['priority_score'] = self.calculate_priority_score(vuln)\n\n        return sorted(vulnerabilities, key=lambda x: x['priority_score'], reverse=True)\n```\n\n### 3. CI/CD Integration\n\n```yaml\nname: Dependency Security Scan\n\non:\n  push:\n    branches: [main]\n  schedule:\n    - cron: '0 2 * * *'\n\njobs:\n  scan-dependencies:\n    runs-on: ubuntu-latest\n\n    strategy:\n      matrix:\n        ecosystem: [npm, python, go]\n\n    steps:\n      - uses: actions/checkout@v4\n\n      - name: NPM Audit\n        if: matrix.ecosystem == 'npm'\n        run: |\n          npm ci\n          npm audit --json > npm-audit.json || true\n          npm audit --audit-level=moderate\n\n      - name: Python Safety\n        if: matrix.ecosystem == 'python'\n        run: |\n          pip install safety pip-audit\n          safety check --json --output safety.json || true\n          pip-audit --format=json --output=pip-audit.json || true\n\n      - name: Go Vulnerability Check\n        if: matrix.ecosystem == 'go'\n        run: |\n          go install golang.org/x/vuln/cmd/govulncheck@latest\n          govulncheck -json ./... > govulncheck.json || true\n\n      - name: Upload Results\n        uses: actions/upload-artifact@v4\n        with:\n          name: scan-${{ matrix.ecosystem }}\n          path: '*.json'\n\n      - name: Check Thresholds\n        run: |\n          CRITICAL=$(grep -o '\"severity\":\"CRITICAL\"' *.json 2>/dev/null | wc -l || echo 0)\n          if [ \"$CRITICAL\" -gt 0 ]; then\n            echo \"\u274c Found $CRITICAL critical vulnerabilities!\"\n            exit 1\n          fi\n```\n\n### 4. Automated Updates\n\n```bash\n#!/bin/bash\n# automated-dependency-update.sh\n\nset -euo pipefail\n\nECOSYSTEM=\"$1\"\nUPDATE_TYPE=\"${2:-patch}\"\n\nupdate_npm() {\n    npm audit --audit-level=moderate || true\n\n    if [ \"$UPDATE_TYPE\" = \"patch\" ]; then\n        npm update --save\n    elif [ \"$UPDATE_TYPE\" = \"minor\" ]; then\n        npx npm-check-updates -u --target minor\n        npm install\n    fi\n\n    npm test\n    npm audit --audit-level=moderate\n}\n\nupdate_python() {\n    pip install --upgrade pip\n    pip-audit --fix\n    safety check\n    pytest\n}\n\nupdate_go() {\n    go get -u ./...\n    go mod tidy\n    govulncheck ./...\n    go test ./...\n}\n\ncase \"$ECOSYSTEM\" in\n    npm) update_npm ;;\n    python) update_python ;;\n    go) update_go ;;\n    *)\n        echo \"Unknown ecosystem: $ECOSYSTEM\"\n        exit 1\n        ;;\nesac\n```\n\n### 5. Reporting\n\n```python\nclass VulnerabilityReporter:\n    def generate_markdown_report(self, scan_results: Dict[str, Any]) -> str:\n        report = f\"\"\"# Dependency Vulnerability Report\n\n**Generated:** {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n\n## Executive Summary\n\n- **Total Vulnerabilities:** {scan_results['summary']['total_vulnerabilities']}\n- **Critical:** {scan_results['summary']['critical']} \ud83d\udd34\n- **High:** {scan_results['summary']['high']} \ud83d\udfe0\n- **Medium:** {scan_results['summary']['medium']} \ud83d\udfe1\n- **Low:** {scan_results['summary']['low']} \ud83d\udfe2\n\n## Critical & High Severity\n\n\"\"\"\n\n        critical_high = [v for v in scan_results['vulnerabilities']\n                        if v.get('severity', '').upper() in ['CRITICAL', 'HIGH']]\n\n        for vuln in critical_high[:20]:\n            report += f\"\"\"\n### {vuln.get('package', 'Unknown')} - {vuln.get('vulnerability_id', '')}\n\n- **Severity:** {vuln.get('severity', 'UNKNOWN')}\n- **Current Version:** {vuln.get('version', '')}\n- **Fixed In:** {vuln.get('fixed_in', 'N/A')}\n- **CVE:** {', '.join(vuln.get('cve', []))}\n\n\"\"\"\n\n        return report\n\n    def generate_sarif(self, scan_results: Dict[str, Any]) -> Dict[str, Any]:\n        return {\n            \"version\": \"2.1.0\",\n            \"$schema\": \"https://raw.githubusercontent.com/oasis-tcs/sarif-spec/master/Schemata/sarif-schema-2.1.0.json\",\n            \"runs\": [{\n                \"tool\": {\n                    \"driver\": {\n                        \"name\": \"Dependency Scanner\",\n                        \"version\": \"1.0.0\"\n                    }\n                },\n                \"results\": [\n                    {\n                        \"ruleId\": vuln.get('vulnerability_id', 'unknown'),\n                        \"level\": self._map_severity(vuln.get('severity', '')),\n                        \"message\": {\n                            \"text\": f\"{vuln.get('package', '')} has known vulnerability\"\n                        }\n                    }\n                    for vuln in scan_results['vulnerabilities']\n                ]\n            }]\n        }\n\n    def _map_severity(self, severity: str) -> str:\n        mapping = {\n            'CRITICAL': 'error',\n            'HIGH': 'error',\n            'MEDIUM': 'warning',\n            'LOW': 'note'\n        }\n        return mapping.get(severity.upper(), 'warning')\n```\n\n## Best Practices\n\n1. **Regular Scanning**: Run dependency scans daily via scheduled CI/CD\n2. **Prioritize by CVSS**: Focus on high CVSS scores and exploit availability\n3. **Staged Updates**: Auto-update patch versions, manual for major versions\n4. **Test Coverage**: Always run full test suite after updates\n5. **SBOM Generation**: Maintain up-to-date Software Bill of Materials\n6. **License Compliance**: Check for restrictive licenses\n7. **Rollback Strategy**: Create backup branches before major updates\n\n## Tool Installation\n\n```bash\n# Python\npip install safety pip-audit pipenv pip-licenses\n\n# JavaScript\nnpm install -g snyk npm-check-updates\n\n# Go\ngo install golang.org/x/vuln/cmd/govulncheck@latest\n\n# Rust\ncargo install cargo-audit\n```\n\n## Usage Examples\n\n```bash\n# Scan all dependencies\npython dependency_scanner.py scan --path .\n\n# Generate SBOM\npython dependency_scanner.py sbom --format cyclonedx\n\n# Auto-fix vulnerabilities\n./automated-dependency-update.sh npm patch\n\n# CI/CD integration\npython dependency_scanner.py scan --fail-on critical,high\n```\n\nFocus on automated vulnerability detection, risk assessment, and remediation across all major package ecosystems.\n"
}