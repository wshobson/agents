{
  "id": "tdd_workflows_tdd_refactor",
  "name": "tdd-refactor",
  "source": "tdd-workflows",
  "originalPath": "plugins/tdd-workflows/commands/tdd-refactor.md",
  "command": "/tdd-workflows:tdd-refactor",
  "parameters": {},
  "outputs": {},
  "agentsUsing": [],
  "fullDefinition": "Refactor code with confidence using comprehensive test safety net:\n\n[Extended thinking: This tool uses the tdd-orchestrator agent (opus model) for sophisticated refactoring while maintaining all tests green. It applies design patterns, improves code quality, and optimizes performance with the safety of comprehensive test coverage.]\n\n## Usage\n\nUse Task tool with subagent_type=\"tdd-orchestrator\" to perform safe refactoring.\n\nPrompt: \"Refactor this code while keeping all tests green: $ARGUMENTS. Apply TDD refactor phase:\n\n## Core Process\n\n**1. Pre-Assessment**\n- Run tests to establish green baseline\n- Analyze code smells and test coverage\n- Document current performance metrics\n- Create incremental refactoring plan\n\n**2. Code Smell Detection**\n- Duplicated code \u2192 Extract methods/classes\n- Long methods \u2192 Decompose into focused functions\n- Large classes \u2192 Split responsibilities\n- Long parameter lists \u2192 Parameter objects\n- Feature Envy \u2192 Move methods to appropriate classes\n- Primitive Obsession \u2192 Value objects\n- Switch statements \u2192 Polymorphism\n- Dead code \u2192 Remove\n\n**3. Design Patterns**\n- Apply Creational (Factory, Builder, Singleton)\n- Apply Structural (Adapter, Facade, Decorator)\n- Apply Behavioral (Strategy, Observer, Command)\n- Apply Domain (Repository, Service, Value Objects)\n- Use patterns only where they add clear value\n\n**4. SOLID Principles**\n- Single Responsibility: One reason to change\n- Open/Closed: Open for extension, closed for modification\n- Liskov Substitution: Subtypes substitutable\n- Interface Segregation: Small, focused interfaces\n- Dependency Inversion: Depend on abstractions\n\n**5. Refactoring Techniques**\n- Extract Method/Variable/Interface\n- Inline unnecessary indirection\n- Rename for clarity\n- Move Method/Field to appropriate classes\n- Replace Magic Numbers with constants\n- Encapsulate fields\n- Replace Conditional with Polymorphism\n- Introduce Null Object\n\n**6. Performance Optimization**\n- Profile to identify bottlenecks\n- Optimize algorithms and data structures\n- Implement caching where beneficial\n- Reduce database queries (N+1 elimination)\n- Lazy loading and pagination\n- Always measure before and after\n\n**7. Incremental Steps**\n- Make small, atomic changes\n- Run tests after each modification\n- Commit after each successful refactoring\n- Keep refactoring separate from behavior changes\n- Use scaffolding when needed\n\n**8. Architecture Evolution**\n- Layer separation and dependency management\n- Module boundaries and interface definition\n- Event-driven patterns for decoupling\n- Database access pattern optimization\n\n**9. Safety Verification**\n- Run full test suite after each change\n- Performance regression testing\n- Mutation testing for test effectiveness\n- Rollback plan for major changes\n\n**10. Advanced Patterns**\n- Strangler Fig: Gradual legacy replacement\n- Branch by Abstraction: Large-scale changes\n- Parallel Change: Expand-contract pattern\n- Mikado Method: Dependency graph navigation\n\n## Output Requirements\n\n- Refactored code with improvements applied\n- Test results (all green)\n- Before/after metrics comparison\n- Applied refactoring techniques list\n- Performance improvement measurements\n- Remaining technical debt assessment\n\n## Safety Checklist\n\nBefore committing:\n- \u2713 All tests pass (100% green)\n- \u2713 No functionality regression\n- \u2713 Performance metrics acceptable\n- \u2713 Code coverage maintained/improved\n- \u2713 Documentation updated\n\n## Recovery Protocol\n\nIf tests fail:\n- Immediately revert last change\n- Identify breaking refactoring\n- Apply smaller incremental changes\n- Use version control for safe experimentation\n\n## Example: Extract Method Pattern\n\n**Before:**\n```typescript\nclass OrderProcessor {\n  processOrder(order: Order): ProcessResult {\n    // Validation\n    if (!order.customerId || order.items.length === 0) {\n      return { success: false, error: \"Invalid order\" };\n    }\n\n    // Calculate totals\n    let subtotal = 0;\n    for (const item of order.items) {\n      subtotal += item.price * item.quantity;\n    }\n    let total = subtotal + (subtotal * 0.08) + (subtotal > 100 ? 0 : 15);\n\n    // Process payment...\n    // Update inventory...\n    // Send confirmation...\n  }\n}\n```\n\n**After:**\n```typescript\nclass OrderProcessor {\n  async processOrder(order: Order): Promise<ProcessResult> {\n    const validation = this.validateOrder(order);\n    if (!validation.isValid) return ProcessResult.failure(validation.error);\n\n    const orderTotal = OrderTotal.calculate(order);\n    const inventoryCheck = await this.inventoryService.checkAvailability(order.items);\n    if (!inventoryCheck.available) return ProcessResult.failure(inventoryCheck.reason);\n\n    await this.paymentService.processPayment(order.paymentMethod, orderTotal.total);\n    await this.inventoryService.reserveItems(order.items);\n    await this.notificationService.sendOrderConfirmation(order, orderTotal);\n\n    return ProcessResult.success(order.id, orderTotal.total);\n  }\n\n  private validateOrder(order: Order): ValidationResult {\n    if (!order.customerId) return ValidationResult.invalid(\"Customer ID required\");\n    if (order.items.length === 0) return ValidationResult.invalid(\"Order must contain items\");\n    return ValidationResult.valid();\n  }\n}\n```\n\n**Applied:** Extract Method, Value Objects, Dependency Injection, Async patterns\n\nCode to refactor: $ARGUMENTS\"\n"
}