{
  "id": "frontend_mobile_security_xss_scan",
  "name": "XSS Vulnerability Scanner for Frontend Code",
  "source": "frontend-mobile-security",
  "originalPath": "plugins/frontend-mobile-security/commands/xss-scan.md",
  "command": "/frontend-mobile-security:xss-scan",
  "parameters": {},
  "outputs": {},
  "agentsUsing": [],
  "fullDefinition": "# XSS Vulnerability Scanner for Frontend Code\n\nYou are a frontend security specialist focusing on Cross-Site Scripting (XSS) vulnerability detection and prevention. Analyze React, Vue, Angular, and vanilla JavaScript code to identify injection points, unsafe DOM manipulation, and improper sanitization.\n\n## Context\n\nThe user needs comprehensive XSS vulnerability scanning for client-side code, identifying dangerous patterns like unsafe HTML manipulation, URL handling issues, and improper user input rendering. Focus on context-aware detection and framework-specific security patterns.\n\n## Requirements\n\n$ARGUMENTS\n\n## Instructions\n\n### 1. XSS Vulnerability Detection\n\nScan codebase for XSS vulnerabilities using static analysis:\n\n```typescript\ninterface XSSFinding {\n  file: string;\n  line: number;\n  severity: 'critical' | 'high' | 'medium' | 'low';\n  type: string;\n  vulnerable_code: string;\n  description: string;\n  fix: string;\n  cwe: string;\n}\n\nclass XSSScanner {\n  private vulnerablePatterns = [\n    'innerHTML', 'outerHTML', 'document.write',\n    'insertAdjacentHTML', 'location.href', 'window.open'\n  ];\n\n  async scanDirectory(path: string): Promise<XSSFinding[]> {\n    const files = await this.findJavaScriptFiles(path);\n    const findings: XSSFinding[] = [];\n\n    for (const file of files) {\n      const content = await fs.readFile(file, 'utf-8');\n      findings.push(...this.scanFile(file, content));\n    }\n\n    return findings;\n  }\n\n  scanFile(filePath: string, content: string): XSSFinding[] {\n    const findings: XSSFinding[] = [];\n\n    findings.push(...this.detectHTMLManipulation(filePath, content));\n    findings.push(...this.detectReactVulnerabilities(filePath, content));\n    findings.push(...this.detectURLVulnerabilities(filePath, content));\n    findings.push(...this.detectEventHandlerIssues(filePath, content));\n\n    return findings;\n  }\n\n  detectHTMLManipulation(file: string, content: string): XSSFinding[] {\n    const findings: XSSFinding[] = [];\n    const lines = content.split('\\n');\n\n    lines.forEach((line, index) => {\n      if (line.includes('innerHTML') && this.hasUserInput(line)) {\n        findings.push({\n          file,\n          line: index + 1,\n          severity: 'critical',\n          type: 'Unsafe HTML manipulation',\n          vulnerable_code: line.trim(),\n          description: 'User-controlled data in HTML manipulation creates XSS risk',\n          fix: 'Use textContent for plain text or sanitize with DOMPurify library',\n          cwe: 'CWE-79'\n        });\n      }\n    });\n\n    return findings;\n  }\n\n  detectReactVulnerabilities(file: string, content: string): XSSFinding[] {\n    const findings: XSSFinding[] = [];\n    const lines = content.split('\\n');\n\n    lines.forEach((line, index) => {\n      if (line.includes('dangerously') && !this.hasSanitization(content)) {\n        findings.push({\n          file,\n          line: index + 1,\n          severity: 'high',\n          type: 'React unsafe HTML rendering',\n          vulnerable_code: line.trim(),\n          description: 'Unsanitized HTML in React component creates XSS vulnerability',\n          fix: 'Apply DOMPurify.sanitize() before rendering or use safe alternatives',\n          cwe: 'CWE-79'\n        });\n      }\n    });\n\n    return findings;\n  }\n\n  detectURLVulnerabilities(file: string, content: string): XSSFinding[] {\n    const findings: XSSFinding[] = [];\n    const lines = content.split('\\n');\n\n    lines.forEach((line, index) => {\n      if (line.includes('location.') && this.hasUserInput(line)) {\n        findings.push({\n          file,\n          line: index + 1,\n          severity: 'high',\n          type: 'URL injection',\n          vulnerable_code: line.trim(),\n          description: 'User input in URL assignment can execute malicious code',\n          fix: 'Validate URLs and enforce http/https protocols only',\n          cwe: 'CWE-79'\n        });\n      }\n    });\n\n    return findings;\n  }\n\n  hasUserInput(line: string): boolean {\n    const indicators = ['props', 'state', 'params', 'query', 'input', 'formData'];\n    return indicators.some(indicator => line.includes(indicator));\n  }\n\n  hasSanitization(content: string): boolean {\n    return content.includes('DOMPurify') || content.includes('sanitize');\n  }\n}\n```\n\n### 2. Framework-Specific Detection\n\n```typescript\nclass ReactXSSScanner {\n  scanReactComponent(code: string): XSSFinding[] {\n    const findings: XSSFinding[] = [];\n\n    // Check for unsafe React patterns\n    const unsafePatterns = [\n      'dangerouslySetInnerHTML',\n      'createMarkup',\n      'rawHtml'\n    ];\n\n    unsafePatterns.forEach(pattern => {\n      if (code.includes(pattern) && !code.includes('DOMPurify')) {\n        findings.push({\n          severity: 'high',\n          type: 'React XSS risk',\n          description: `Pattern ${pattern} used without sanitization`,\n          fix: 'Apply proper HTML sanitization'\n        });\n      }\n    });\n\n    return findings;\n  }\n}\n\nclass VueXSSScanner {\n  scanVueTemplate(template: string): XSSFinding[] {\n    const findings: XSSFinding[] = [];\n\n    if (template.includes('v-html')) {\n      findings.push({\n        severity: 'high',\n        type: 'Vue HTML injection',\n        description: 'v-html directive renders raw HTML',\n        fix: 'Use v-text for plain text or sanitize HTML'\n      });\n    }\n\n    return findings;\n  }\n}\n```\n\n### 3. Secure Coding Examples\n\n```typescript\nclass SecureCodingGuide {\n  getSecurePattern(vulnerability: string): string {\n    const patterns = {\n      html_manipulation: `\n// SECURE: Use textContent for plain text\nelement.textContent = userInput;\n\n// SECURE: Sanitize HTML when needed\nimport DOMPurify from 'dompurify';\nconst clean = DOMPurify.sanitize(userInput);\nelement.innerHTML = clean;`,\n\n      url_handling: `\n// SECURE: Validate and sanitize URLs\nfunction sanitizeURL(url: string): string {\n  try {\n    const parsed = new URL(url);\n    if (['http:', 'https:'].includes(parsed.protocol)) {\n      return parsed.href;\n    }\n  } catch {}\n  return '#';\n}`,\n\n      react_rendering: `\n// SECURE: Sanitize before rendering\nimport DOMPurify from 'dompurify';\n\nconst Component = ({ html }) => (\n  <div dangerouslySetInnerHTML={{\n    __html: DOMPurify.sanitize(html)\n  }} />\n);`\n    };\n\n    return patterns[vulnerability] || 'No secure pattern available';\n  }\n}\n```\n\n### 4. Automated Scanning Integration\n\n```bash\n# ESLint with security plugin\nnpm install --save-dev eslint-plugin-security\neslint . --plugin security\n\n# Semgrep for XSS patterns\nsemgrep --config=p/xss --json\n\n# Custom XSS scanner\nnode xss-scanner.js --path=src --format=json\n```\n\n### 5. Report Generation\n\n```typescript\nclass XSSReportGenerator {\n  generateReport(findings: XSSFinding[]): string {\n    const grouped = this.groupBySeverity(findings);\n\n    let report = '# XSS Vulnerability Scan Report\\n\\n';\n    report += `Total Findings: ${findings.length}\\n\\n`;\n\n    for (const [severity, issues] of Object.entries(grouped)) {\n      report += `## ${severity.toUpperCase()} (${issues.length})\\n\\n`;\n\n      for (const issue of issues) {\n        report += `- **${issue.type}**\\n`;\n        report += `  File: ${issue.file}:${issue.line}\\n`;\n        report += `  Fix: ${issue.fix}\\n\\n`;\n      }\n    }\n\n    return report;\n  }\n\n  groupBySeverity(findings: XSSFinding[]): Record<string, XSSFinding[]> {\n    return findings.reduce((acc, finding) => {\n      if (!acc[finding.severity]) acc[finding.severity] = [];\n      acc[finding.severity].push(finding);\n      return acc;\n    }, {} as Record<string, XSSFinding[]>);\n  }\n}\n```\n\n### 6. Prevention Checklist\n\n**HTML Manipulation**\n- Never use innerHTML with user input\n- Prefer textContent for text content\n- Sanitize with DOMPurify before rendering HTML\n- Avoid document.write entirely\n\n**URL Handling**\n- Validate all URLs before assignment\n- Block javascript: and data: protocols\n- Use URL constructor for validation\n- Sanitize href attributes\n\n**Event Handlers**\n- Use addEventListener instead of inline handlers\n- Sanitize all event handler input\n- Avoid string-to-code patterns\n\n**Framework-Specific**\n- React: Sanitize before using unsafe APIs\n- Vue: Prefer v-text over v-html\n- Angular: Use built-in sanitization\n- Avoid bypassing framework security features\n\n## Output Format\n\n1. **Vulnerability Report**: Detailed findings with severity levels\n2. **Risk Analysis**: Impact assessment for each vulnerability\n3. **Fix Recommendations**: Secure code examples\n4. **Sanitization Guide**: DOMPurify usage patterns\n5. **Prevention Checklist**: Best practices for XSS prevention\n\nFocus on identifying XSS attack vectors, providing actionable fixes, and establishing secure coding patterns.\n"
}